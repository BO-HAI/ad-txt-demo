/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 54);
/******/ })
/************************************************************************/
/******/ ({

/***/ 54:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * jQuery JavaScript Library v1.11.0\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-01-23T21:02Z\n */\n\n(function (global, factory) {\n\n\tif (( false ? \"undefined\" : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n\t\t// For CommonJS and CommonJS-like environments where a proper window is present,\n\t\t// execute the factory and get jQuery\n\t\t// For environments that do not inherently posses a window with a document\n\t\t// (such as Node.js), expose a jQuery-making factory as module.exports\n\t\t// This accentuates the need for the creation of a real window\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info\n\t\tmodule.exports = global.document ? factory(global, true) : function (w) {\n\t\t\tif (!w.document) {\n\t\t\t\tthrow new Error(\"jQuery requires a window with a document\");\n\t\t\t}\n\t\t\treturn factory(w);\n\t\t};\n\t} else {\n\t\tfactory(global);\n\t}\n\n\t// Pass this if window is not defined yet\n})(typeof window !== \"undefined\" ? window : undefined, function (window, noGlobal) {\n\n\t// Can't do this because several apps including ASP.NET trace\n\t// the stack via arguments.caller.callee and Firefox dies if\n\t// you try to trace through \"use strict\" call chains. (#13335)\n\t// Support: Firefox 18+\n\t//\n\n\tvar deletedIds = [];\n\n\tvar _slice = deletedIds.slice;\n\n\tvar concat = deletedIds.concat;\n\n\tvar push = deletedIds.push;\n\n\tvar indexOf = deletedIds.indexOf;\n\n\tvar class2type = {};\n\n\tvar toString = class2type.toString;\n\n\tvar hasOwn = class2type.hasOwnProperty;\n\n\tvar trim = \"\".trim;\n\n\tvar support = {};\n\n\tvar version = \"1.11.0\",\n\n\n\t// Define a local copy of jQuery\n\tjQuery = function jQuery(selector, context) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init(selector, context);\n\t},\n\n\n\t// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\t    rdashAlpha = /-([\\da-z])/gi,\n\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function fcamelCase(all, letter) {\n\t\treturn letter.toUpperCase();\n\t};\n\n\tjQuery.fn = jQuery.prototype = {\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\n\t\tconstructor: jQuery,\n\n\t\t// Start with an empty selector\n\t\tselector: \"\",\n\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\n\t\ttoArray: function toArray() {\n\t\t\treturn _slice.call(this);\n\t\t},\n\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function get(num) {\n\t\t\treturn num != null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tnum < 0 ? this[num + this.length] : this[num] :\n\n\t\t\t// Return just the object\n\t\t\t_slice.call(this);\n\t\t},\n\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function pushStack(elems) {\n\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge(this.constructor(), elems);\n\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\t\tret.context = this.context;\n\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\n\t\t// Execute a callback for every element in the matched set.\n\t\t// (You can seed the arguments with an array of args, but this is\n\t\t// only used internally.)\n\t\teach: function each(callback, args) {\n\t\t\treturn jQuery.each(this, callback, args);\n\t\t},\n\n\t\tmap: function map(callback) {\n\t\t\treturn this.pushStack(jQuery.map(this, function (elem, i) {\n\t\t\t\treturn callback.call(elem, i, elem);\n\t\t\t}));\n\t\t},\n\n\t\tslice: function slice() {\n\t\t\treturn this.pushStack(_slice.apply(this, arguments));\n\t\t},\n\n\t\tfirst: function first() {\n\t\t\treturn this.eq(0);\n\t\t},\n\n\t\tlast: function last() {\n\t\t\treturn this.eq(-1);\n\t\t},\n\n\t\teq: function eq(i) {\n\t\t\tvar len = this.length,\n\t\t\t    j = +i + (i < 0 ? len : 0);\n\t\t\treturn this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n\t\t},\n\n\t\tend: function end() {\n\t\t\treturn this.prevObject || this.constructor(null);\n\t\t},\n\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: deletedIds.sort,\n\t\tsplice: deletedIds.splice\n\t};\n\n\tjQuery.extend = jQuery.fn.extend = function () {\n\t\tvar src,\n\t\t    copyIsArray,\n\t\t    copy,\n\t\t    name,\n\t\t    options,\n\t\t    clone,\n\t\t    target = arguments[0] || {},\n\t\t    i = 1,\n\t\t    length = arguments.length,\n\t\t    deep = false;\n\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === \"boolean\") {\n\t\t\tdeep = target;\n\n\t\t\t// skip the boolean and the target\n\t\t\ttarget = arguments[i] || {};\n\t\t\ti++;\n\t\t}\n\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== \"object\" && !jQuery.isFunction(target)) {\n\t\t\ttarget = {};\n\t\t}\n\n\t\t// extend jQuery itself if only one argument is passed\n\t\tif (i === length) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\n\t\tfor (; i < length; i++) {\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ((options = arguments[i]) != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target === copy) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = jQuery.extend(deep, clone, copy);\n\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\n\tjQuery.extend({\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\n\t\terror: function error(msg) {\n\t\t\tthrow new Error(msg);\n\t\t},\n\n\t\tnoop: function noop() {},\n\n\t\t// See test/unit/core.js for details concerning isFunction.\n\t\t// Since version 1.3, DOM methods and functions like alert\n\t\t// aren't supported. They return false on IE (#2968).\n\t\tisFunction: function isFunction(obj) {\n\t\t\treturn jQuery.type(obj) === \"function\";\n\t\t},\n\n\t\tisArray: Array.isArray || function (obj) {\n\t\t\treturn jQuery.type(obj) === \"array\";\n\t\t},\n\n\t\tisWindow: function isWindow(obj) {\n\t\t\t/* jshint eqeqeq: false */\n\t\t\treturn obj != null && obj == obj.window;\n\t\t},\n\n\t\tisNumeric: function isNumeric(obj) {\n\t\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\treturn obj - parseFloat(obj) >= 0;\n\t\t},\n\n\t\tisEmptyObject: function isEmptyObject(obj) {\n\t\t\tvar name;\n\t\t\tfor (name in obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\tisPlainObject: function isPlainObject(obj) {\n\t\t\tvar key;\n\n\t\t\t// Must be an Object.\n\t\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\t\tif (!obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow(obj)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Not own constructor property must be Object\n\t\t\t\tif (obj.constructor && !hasOwn.call(obj, \"constructor\") && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Support: IE<9\n\t\t\t// Handle iteration over inherited properties before own properties.\n\t\t\tif (support.ownLast) {\n\t\t\t\tfor (key in obj) {\n\t\t\t\t\treturn hasOwn.call(obj, key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t\t// if last one is own, then all properties are own.\n\t\t\tfor (key in obj) {}\n\n\t\t\treturn key === undefined || hasOwn.call(obj, key);\n\t\t},\n\n\t\ttype: function type(obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\t\treturn (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t\t},\n\n\t\t// Evaluates a script in a global context\n\t\t// Workarounds based on findings by Jim Driscoll\n\t\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\t\tglobalEval: function globalEval(data) {\n\t\t\tif (data && jQuery.trim(data)) {\n\t\t\t\t// We use execScript on Internet Explorer\n\t\t\t\t// We use an anonymous function so that context is window\n\t\t\t\t// rather than jQuery in Firefox\n\t\t\t\t(window.execScript || function (data) {\n\t\t\t\t\twindow[\"eval\"].call(window, data);\n\t\t\t\t})(data);\n\t\t\t}\n\t\t},\n\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function camelCase(string) {\n\t\t\treturn string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n\t\t},\n\n\t\tnodeName: function nodeName(elem, name) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\n\t\t// args is for internal usage only\n\t\teach: function each(obj, callback, args) {\n\t\t\tvar value,\n\t\t\t    i = 0,\n\t\t\t    length = obj.length,\n\t\t\t    isArray = isArraylike(obj);\n\n\t\t\tif (args) {\n\t\t\t\tif (isArray) {\n\t\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\t\tvalue = callback.apply(obj[i], args);\n\n\t\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i in obj) {\n\t\t\t\t\t\tvalue = callback.apply(obj[i], args);\n\n\t\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// A special, fast, case for the most common use of each\n\t\t\t} else {\n\t\t\t\tif (isArray) {\n\t\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\t\tvalue = callback.call(obj[i], i, obj[i]);\n\n\t\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i in obj) {\n\t\t\t\t\t\tvalue = callback.call(obj[i], i, obj[i]);\n\n\t\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t},\n\n\t\t// Use native String.trim function wherever possible\n\t\ttrim: trim && !trim.call(\"\\uFEFF\\xA0\") ? function (text) {\n\t\t\treturn text == null ? \"\" : trim.call(text);\n\t\t} :\n\n\t\t// Otherwise use our own trimming functionality\n\t\tfunction (text) {\n\t\t\treturn text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n\t\t},\n\n\t\t// results is for internal usage only\n\t\tmakeArray: function makeArray(arr, results) {\n\t\t\tvar ret = results || [];\n\n\t\t\tif (arr != null) {\n\t\t\t\tif (isArraylike(Object(arr))) {\n\t\t\t\t\tjQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call(ret, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\tinArray: function inArray(elem, arr, i) {\n\t\t\tvar len;\n\n\t\t\tif (arr) {\n\t\t\t\tif (indexOf) {\n\t\t\t\t\treturn indexOf.call(arr, elem, i);\n\t\t\t\t}\n\n\t\t\t\tlen = arr.length;\n\t\t\t\ti = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\t// Skip accessing in sparse arrays\n\t\t\t\t\tif (i in arr && arr[i] === elem) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t},\n\n\t\tmerge: function merge(first, second) {\n\t\t\tvar len = +second.length,\n\t\t\t    j = 0,\n\t\t\t    i = first.length;\n\n\t\t\twhile (j < len) {\n\t\t\t\tfirst[i++] = second[j++];\n\t\t\t}\n\n\t\t\t// Support: IE<9\n\t\t\t// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)\n\t\t\tif (len !== len) {\n\t\t\t\twhile (second[j] !== undefined) {\n\t\t\t\t\tfirst[i++] = second[j++];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfirst.length = i;\n\n\t\t\treturn first;\n\t\t},\n\n\t\tgrep: function grep(elems, callback, invert) {\n\t\t\tvar callbackInverse,\n\t\t\t    matches = [],\n\t\t\t    i = 0,\n\t\t\t    length = elems.length,\n\t\t\t    callbackExpect = !invert;\n\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor (; i < length; i++) {\n\t\t\t\tcallbackInverse = !callback(elems[i], i);\n\t\t\t\tif (callbackInverse !== callbackExpect) {\n\t\t\t\t\tmatches.push(elems[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn matches;\n\t\t},\n\n\t\t// arg is for internal usage only\n\t\tmap: function map(elems, callback, arg) {\n\t\t\tvar value,\n\t\t\t    i = 0,\n\t\t\t    length = elems.length,\n\t\t\t    isArray = isArraylike(elems),\n\t\t\t    ret = [];\n\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif (isArray) {\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tvalue = callback(elems[i], i, arg);\n\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tret.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor (i in elems) {\n\t\t\t\t\tvalue = callback(elems[i], i, arg);\n\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tret.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply([], ret);\n\t\t},\n\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function proxy(fn, context) {\n\t\t\tvar args, proxy, tmp;\n\n\t\t\tif (typeof context === \"string\") {\n\t\t\t\ttmp = fn[context];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif (!jQuery.isFunction(fn)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Simulated bind\n\t\t\targs = _slice.call(arguments, 2);\n\t\t\tproxy = function proxy() {\n\t\t\t\treturn fn.apply(context || this, args.concat(_slice.call(arguments)));\n\t\t\t};\n\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\t\treturn proxy;\n\t\t},\n\n\t\tnow: function now() {\n\t\t\treturn +new Date();\n\t\t},\n\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t});\n\n\t// Populate the class2type map\n\tjQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (i, name) {\n\t\tclass2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n\t});\n\n\tfunction isArraylike(obj) {\n\t\tvar length = obj.length,\n\t\t    type = jQuery.type(obj);\n\n\t\tif (type === \"function\" || jQuery.isWindow(obj)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (obj.nodeType === 1 && length) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n  * Sizzle CSS Selector Engine v1.10.16\n  * http://sizzlejs.com/\n  *\n  * Copyright 2013 jQuery Foundation, Inc. and other contributors\n  * Released under the MIT license\n  * http://jquery.org/license\n  *\n  * Date: 2014-01-13\n  */\n\tfunction (window) {\n\n\t\tvar i,\n\t\t    support,\n\t\t    Expr,\n\t\t    getText,\n\t\t    isXML,\n\t\t    compile,\n\t\t    outermostContext,\n\t\t    sortInput,\n\t\t    hasDuplicate,\n\n\n\t\t// Local document vars\n\t\tsetDocument,\n\t\t    document,\n\t\t    docElem,\n\t\t    documentIsHTML,\n\t\t    rbuggyQSA,\n\t\t    rbuggyMatches,\n\t\t    matches,\n\t\t    contains,\n\n\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + -new Date(),\n\t\t    preferredDoc = window.document,\n\t\t    dirruns = 0,\n\t\t    done = 0,\n\t\t    classCache = createCache(),\n\t\t    tokenCache = createCache(),\n\t\t    compilerCache = createCache(),\n\t\t    sortOrder = function sortOrder(a, b) {\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\n\t\t// General-purpose constants\n\t\tstrundefined =  true ? \"undefined\" : _typeof(undefined),\n\t\t    MAX_NEGATIVE = 1 << 31,\n\n\n\t\t// Instance methods\n\t\thasOwn = {}.hasOwnProperty,\n\t\t    arr = [],\n\t\t    pop = arr.pop,\n\t\t    push_native = arr.push,\n\t\t    push = arr.push,\n\t\t    slice = arr.slice,\n\n\t\t// Use a stripped-down indexOf if we can't use a native one\n\t\tindexOf = arr.indexOf || function (elem) {\n\t\t\tvar i = 0,\n\t\t\t    len = this.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (this[i] === elem) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\t    booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\n\t\t// Regular expressions\n\n\t\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t\t// http://www.w3.org/TR/css3-syntax/#characters\n\t\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\n\t\t// Loosely modeled on CSS identifier characters\n\t\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = characterEncoding.replace(\"w\", \"w#\"),\n\n\n\t\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace + \"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n\n\t\t// Prefer arguments quoted,\n\t\t//   then not containing pseudos/brackets,\n\t\t//   then attribute selectors/non-parenthetical expressions,\n\t\t//   then anything else\n\t\t// These preferences are here to reduce the number of selectors\n\t\t//   needing tokenize in the PSEUDO preFilter\n\t\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace(3, 8) + \")*)|.*)\\\\)|)\",\n\n\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n\t\t    rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n\t\t    rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n\t\t    rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"),\n\t\t    rpseudo = new RegExp(pseudos),\n\t\t    ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n\t\t    matchExpr = {\n\t\t\t\"ID\": new RegExp(\"^#(\" + characterEncoding + \")\"),\n\t\t\t\"CLASS\": new RegExp(\"^\\\\.(\" + characterEncoding + \")\"),\n\t\t\t\"TAG\": new RegExp(\"^(\" + characterEncoding.replace(\"w\", \"w*\") + \")\"),\n\t\t\t\"ATTR\": new RegExp(\"^\" + attributes),\n\t\t\t\"PSEUDO\": new RegExp(\"^\" + pseudos),\n\t\t\t\"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n\t\t\t\"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n\t\t},\n\t\t    rinputs = /^(?:input|select|textarea|button)$/i,\n\t\t    rheader = /^h\\d$/i,\n\t\t    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\t    rsibling = /[+~]/,\n\t\t    rescape = /'|\\\\/g,\n\n\n\t\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n\t\t    funescape = function funescape(_, escaped, escapedWhitespace) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ? escaped : high < 0 ?\n\t\t\t// BMP codepoint\n\t\t\tString.fromCharCode(high + 0x10000) :\n\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\tString.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n\t\t};\n\n\t\t// Optimize for push.apply( _, NodeList )\n\t\ttry {\n\t\t\tpush.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n\t\t\t// Support: Android<4.0\n\t\t\t// Detect silently failing push.apply\n\t\t\tarr[preferredDoc.childNodes.length].nodeType;\n\t\t} catch (e) {\n\t\t\tpush = { apply: arr.length ?\n\n\t\t\t\t// Leverage slice if possible\n\t\t\t\tfunction (target, els) {\n\t\t\t\t\tpush_native.apply(target, slice.call(els));\n\t\t\t\t} :\n\n\t\t\t\t// Support: IE<9\n\t\t\t\t// Otherwise append directly\n\t\t\t\tfunction (target, els) {\n\t\t\t\t\tvar j = target.length,\n\t\t\t\t\t    i = 0;\n\t\t\t\t\t// Can't trust NodeList.length\n\t\t\t\t\twhile (target[j++] = els[i++]) {}\n\t\t\t\t\ttarget.length = j - 1;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction Sizzle(selector, context, results, seed) {\n\t\t\tvar match, elem, m, nodeType,\n\t\t\t// QSA vars\n\t\t\ti, groups, old, nid, newContext, newSelector;\n\n\t\t\tif ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n\t\t\t\tsetDocument(context);\n\t\t\t}\n\n\t\t\tcontext = context || document;\n\t\t\tresults = results || [];\n\n\t\t\tif (!selector || typeof selector !== \"string\") {\n\t\t\t\treturn results;\n\t\t\t}\n\n\t\t\tif ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (documentIsHTML && !seed) {\n\n\t\t\t\t// Shortcuts\n\t\t\t\tif (match = rquickExpr.exec(selector)) {\n\t\t\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\t\t\tif (m = match[1]) {\n\t\t\t\t\t\tif (nodeType === 9) {\n\t\t\t\t\t\t\telem = context.getElementById(m);\n\t\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\t\t\tif (elem && elem.parentNode) {\n\t\t\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\t\t\tif (elem.id === m) {\n\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Context is not a document\n\t\t\t\t\t\t\tif (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t\t\t} else if (match[2]) {\n\t\t\t\t\t\tpush.apply(results, context.getElementsByTagName(selector));\n\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t\t\t} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n\t\t\t\t\t\tpush.apply(results, context.getElementsByClassName(m));\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// QSA path\n\t\t\t\tif (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n\t\t\t\t\tnid = old = expando;\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t\t\t// IE 8 doesn't work on object elements\n\t\t\t\t\tif (nodeType === 1 && context.nodeName.toLowerCase() !== \"object\") {\n\t\t\t\t\t\tgroups = tokenize(selector);\n\n\t\t\t\t\t\tif (old = context.getAttribute(\"id\")) {\n\t\t\t\t\t\t\tnid = old.replace(rescape, \"\\\\$&\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute(\"id\", nid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tgroups[i] = nid + toSelector(groups[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n\t\t\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newSelector) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpush.apply(results, newContext.querySelectorAll(newSelector));\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t} catch (qsaError) {} finally {\n\t\t\t\t\t\t\tif (!old) {\n\t\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All others\n\t\t\treturn select(selector.replace(rtrim, \"$1\"), context, results, seed);\n\t\t}\n\n\t\t/**\n   * Create key-value caches of limited size\n   * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n   *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n   *\tdeleting the oldest entry\n   */\n\t\tfunction createCache() {\n\t\t\tvar keys = [];\n\n\t\t\tfunction cache(key, value) {\n\t\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\t\tif (keys.push(key + \" \") > Expr.cacheLength) {\n\t\t\t\t\t// Only keep the most recent entries\n\t\t\t\t\tdelete cache[keys.shift()];\n\t\t\t\t}\n\t\t\t\treturn cache[key + \" \"] = value;\n\t\t\t}\n\t\t\treturn cache;\n\t\t}\n\n\t\t/**\n   * Mark a function for special use by Sizzle\n   * @param {Function} fn The function to mark\n   */\n\t\tfunction markFunction(fn) {\n\t\t\tfn[expando] = true;\n\t\t\treturn fn;\n\t\t}\n\n\t\t/**\n   * Support testing using an element\n   * @param {Function} fn Passed the created div and expects a boolean result\n   */\n\t\tfunction assert(fn) {\n\t\t\tvar div = document.createElement(\"div\");\n\n\t\t\ttry {\n\t\t\t\treturn !!fn(div);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t} finally {\n\t\t\t\t// Remove from its parent by default\n\t\t\t\tif (div.parentNode) {\n\t\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t\t}\n\t\t\t\t// release memory in IE\n\t\t\t\tdiv = null;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Adds the same handler for all of the specified attrs\n   * @param {String} attrs Pipe-separated list of attributes\n   * @param {Function} handler The method that will be applied\n   */\n\t\tfunction addHandle(attrs, handler) {\n\t\t\tvar arr = attrs.split(\"|\"),\n\t\t\t    i = attrs.length;\n\n\t\t\twhile (i--) {\n\t\t\t\tExpr.attrHandle[arr[i]] = handler;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Checks document order of two siblings\n   * @param {Element} a\n   * @param {Element} b\n   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n   */\n\t\tfunction siblingCheck(a, b) {\n\t\t\tvar cur = b && a,\n\t\t\t    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);\n\n\t\t\t// Use IE sourceIndex if available on both nodes\n\t\t\tif (diff) {\n\t\t\t\treturn diff;\n\t\t\t}\n\n\t\t\t// Check if b follows a\n\t\t\tif (cur) {\n\t\t\t\twhile (cur = cur.nextSibling) {\n\t\t\t\t\tif (cur === b) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn a ? 1 : -1;\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for input types\n   * @param {String} type\n   */\n\t\tfunction createInputPseudo(type) {\n\t\t\treturn function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === type;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for buttons\n   * @param {String} type\n   */\n\t\tfunction createButtonPseudo(type) {\n\t\t\treturn function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for positionals\n   * @param {Function} fn\n   */\n\t\tfunction createPositionalPseudo(fn) {\n\t\t\treturn markFunction(function (argument) {\n\t\t\t\targument = +argument;\n\t\t\t\treturn markFunction(function (seed, matches) {\n\t\t\t\t\tvar j,\n\t\t\t\t\t    matchIndexes = fn([], seed.length, argument),\n\t\t\t\t\t    i = matchIndexes.length;\n\n\t\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (seed[j = matchIndexes[i]]) {\n\t\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Checks a node for validity as a Sizzle context\n   * @param {Element|Object=} context\n   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n   */\n\t\tfunction testContext(context) {\n\t\t\treturn context && _typeof(context.getElementsByTagName) !== strundefined && context;\n\t\t}\n\n\t\t// Expose support vars for convenience\n\t\tsupport = Sizzle.support = {};\n\n\t\t/**\n   * Detects XML nodes\n   * @param {Element|Object} elem An element or a document\n   * @returns {Boolean} True iff elem is a non-HTML XML node\n   */\n\t\tisXML = Sizzle.isXML = function (elem) {\n\t\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t\t// (such as loading iframes in IE - #4833)\n\t\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t\t};\n\n\t\t/**\n   * Sets document-related variables once based on the current document\n   * @param {Element|Object} [doc] An element or document object to use to set the document\n   * @returns {Object} Returns the current document\n   */\n\t\tsetDocument = Sizzle.setDocument = function (node) {\n\t\t\tvar hasCompare,\n\t\t\t    doc = node ? node.ownerDocument || node : preferredDoc,\n\t\t\t    parent = doc.defaultView;\n\n\t\t\t// If no document and documentElement is available, return\n\t\t\tif (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n\t\t\t\treturn document;\n\t\t\t}\n\n\t\t\t// Set our document\n\t\t\tdocument = doc;\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\t// Support tests\n\t\t\tdocumentIsHTML = !isXML(doc);\n\n\t\t\t// Support: IE>8\n\t\t\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t\t\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t\t\t// IE6-8 do not support the defaultView property so parent will be undefined\n\t\t\tif (parent && parent !== parent.top) {\n\t\t\t\t// IE11 does not have attachEvent, so all must suffer\n\t\t\t\tif (parent.addEventListener) {\n\t\t\t\t\tparent.addEventListener(\"unload\", function () {\n\t\t\t\t\t\tsetDocument();\n\t\t\t\t\t}, false);\n\t\t\t\t} else if (parent.attachEvent) {\n\t\t\t\t\tparent.attachEvent(\"onunload\", function () {\n\t\t\t\t\t\tsetDocument();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Attributes\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Support: IE<8\n\t\t\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n\t\t\tsupport.attributes = assert(function (div) {\n\t\t\t\tdiv.className = \"i\";\n\t\t\t\treturn !div.getAttribute(\"className\");\n\t\t\t});\n\n\t\t\t/* getElement(s)By*\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\t\tsupport.getElementsByTagName = assert(function (div) {\n\t\t\t\tdiv.appendChild(doc.createComment(\"\"));\n\t\t\t\treturn !div.getElementsByTagName(\"*\").length;\n\t\t\t});\n\n\t\t\t// Check if getElementsByClassName can be trusted\n\t\t\tsupport.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {\n\t\t\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n\n\t\t\t\t// Support: Safari<4\n\t\t\t\t// Catch class over-caching\n\t\t\t\tdiv.firstChild.className = \"i\";\n\t\t\t\t// Support: Opera<10\n\t\t\t\t// Catch gEBCN failure to find non-leading classes\n\t\t\t\treturn div.getElementsByClassName(\"i\").length === 2;\n\t\t\t});\n\n\t\t\t// Support: IE<10\n\t\t\t// Check if getElementById returns elements by name\n\t\t\t// The broken getElementById methods don't pick up programatically-set names,\n\t\t\t// so use a roundabout getElementsByName test\n\t\t\tsupport.getById = assert(function (div) {\n\t\t\t\tdocElem.appendChild(div).id = expando;\n\t\t\t\treturn !doc.getElementsByName || !doc.getElementsByName(expando).length;\n\t\t\t});\n\n\t\t\t// ID find and filter\n\t\t\tif (support.getById) {\n\t\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\t\tif (_typeof(context.getElementById) !== strundefined && documentIsHTML) {\n\t\t\t\t\t\tvar m = context.getElementById(id);\n\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Support: IE6/7\n\t\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\t\tdelete Expr.find[\"ID\"];\n\n\t\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar node = _typeof(elem.getAttributeNode) !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Tag\n\t\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n\t\t\t\tif (_typeof(context.getElementsByTagName) !== strundefined) {\n\t\t\t\t\treturn context.getElementsByTagName(tag);\n\t\t\t\t}\n\t\t\t} : function (tag, context) {\n\t\t\t\tvar elem,\n\t\t\t\t    tmp = [],\n\t\t\t\t    i = 0,\n\t\t\t\t    results = context.getElementsByTagName(tag);\n\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif (tag === \"*\") {\n\t\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\t\ttmp.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\n\t\t\t// Class\n\t\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n\t\t\t\tif (_typeof(context.getElementsByClassName) !== strundefined && documentIsHTML) {\n\t\t\t\t\treturn context.getElementsByClassName(className);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/* QSA/matchesSelector\n   ---------------------------------------------------------------------- */\n\n\t\t\t// QSA and matchesSelector support\n\n\t\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\t\trbuggyMatches = [];\n\n\t\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t\t// See http://bugs.jquery.com/ticket/13378\n\t\t\trbuggyQSA = [];\n\n\t\t\tif (support.qsa = rnative.test(doc.querySelectorAll)) {\n\t\t\t\t// Build QSA regex\n\t\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\t\tassert(function (div) {\n\t\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t\t// since its presence should be enough\n\t\t\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\t\t\tdiv.innerHTML = \"<select t=''><option selected=''></option></select>\";\n\n\t\t\t\t\t// Support: IE8, Opera 10-12\n\t\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t\tif (div.querySelectorAll(\"[t^='']\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: IE8\n\t\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\t\tif (!div.querySelectorAll(\"[selected]\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\t\tif (!div.querySelectorAll(\":checked\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tassert(function (div) {\n\t\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\t\tvar input = doc.createElement(\"input\");\n\t\t\t\t\tinput.setAttribute(\"type\", \"hidden\");\n\t\t\t\t\tdiv.appendChild(input).setAttribute(\"name\", \"D\");\n\n\t\t\t\t\t// Support: IE8\n\t\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\t\tif (div.querySelectorAll(\"[name=d]\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\t\tif (!div.querySelectorAll(\":enabled\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n\n\t\t\t\tassert(function (div) {\n\t\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\t\tsupport.disconnectedMatch = matches.call(div, \"div\");\n\n\t\t\t\t\t// This should fail with an exception\n\t\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\t\tmatches.call(div, \"[s!='']:x\");\n\t\t\t\t\trbuggyMatches.push(\"!=\", pseudos);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\trbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n\t\t\trbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n\n\t\t\t/* Contains\n   ---------------------------------------------------------------------- */\n\t\t\thasCompare = rnative.test(docElem.compareDocumentPosition);\n\n\t\t\t// Element contains another\n\t\t\t// Purposefully does not implement inclusive descendent\n\t\t\t// As in, an element does not contain itself\n\t\t\tcontains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t    bup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n\t\t\t} : function (a, b) {\n\t\t\t\tif (b) {\n\t\t\t\t\twhile (b = b.parentNode) {\n\t\t\t\t\t\tif (b === a) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\t/* Sorting\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Document order sorting\n\t\t\tsortOrder = hasCompare ? function (a, b) {\n\n\t\t\t\t// Flag for duplicate removal\n\t\t\t\tif (a === b) {\n\t\t\t\t\thasDuplicate = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\t\tif (compare) {\n\t\t\t\t\treturn compare;\n\t\t\t\t}\n\n\t\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\t\tcompare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\n\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\n\t\t\t\t// Disconnected nodes\n\t\t\t\tif (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n\n\t\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\t\tif (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Maintain original order\n\t\t\t\t\treturn sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;\n\t\t\t\t}\n\n\t\t\t\treturn compare & 4 ? -1 : 1;\n\t\t\t} : function (a, b) {\n\t\t\t\t// Exit early if the nodes are identical\n\t\t\t\tif (a === b) {\n\t\t\t\t\thasDuplicate = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tvar cur,\n\t\t\t\t    i = 0,\n\t\t\t\t    aup = a.parentNode,\n\t\t\t\t    bup = b.parentNode,\n\t\t\t\t    ap = [a],\n\t\t\t\t    bp = [b];\n\n\t\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\t\tif (!aup || !bup) {\n\t\t\t\t\treturn a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;\n\n\t\t\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t\t} else if (aup === bup) {\n\t\t\t\t\treturn siblingCheck(a, b);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\t\tcur = a;\n\t\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\t\tap.unshift(cur);\n\t\t\t\t}\n\t\t\t\tcur = b;\n\t\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\t\tbp.unshift(cur);\n\t\t\t\t}\n\n\t\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\t\twhile (ap[i] === bp[i]) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck(ap[i], bp[i]) :\n\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n\t\t\t};\n\n\t\t\treturn doc;\n\t\t};\n\n\t\tSizzle.matches = function (expr, elements) {\n\t\t\treturn Sizzle(expr, null, null, elements);\n\t\t};\n\n\t\tSizzle.matchesSelector = function (elem, expr) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\t\tsetDocument(elem);\n\t\t\t}\n\n\t\t\t// Make sure that attribute selectors are quoted\n\t\t\texpr = expr.replace(rattributeQuotes, \"='$1']\");\n\n\t\t\tif (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n\n\t\t\t\ttry {\n\t\t\t\t\tvar ret = matches.call(elem, expr);\n\n\t\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\t\tif (ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn Sizzle(expr, document, null, [elem]).length > 0;\n\t\t};\n\n\t\tSizzle.contains = function (context, elem) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((context.ownerDocument || context) !== document) {\n\t\t\t\tsetDocument(context);\n\t\t\t}\n\t\t\treturn contains(context, elem);\n\t\t};\n\n\t\tSizzle.attr = function (elem, name) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\t\tsetDocument(elem);\n\t\t\t}\n\n\t\t\tvar fn = Expr.attrHandle[name.toLowerCase()],\n\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n\n\t\t\treturn val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t};\n\n\t\tSizzle.error = function (msg) {\n\t\t\tthrow new Error(\"Syntax error, unrecognized expression: \" + msg);\n\t\t};\n\n\t\t/**\n   * Document sorting and removing duplicates\n   * @param {ArrayLike} results\n   */\n\t\tSizzle.uniqueSort = function (results) {\n\t\t\tvar elem,\n\t\t\t    duplicates = [],\n\t\t\t    j = 0,\n\t\t\t    i = 0;\n\n\t\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\t\thasDuplicate = !support.detectDuplicates;\n\t\t\tsortInput = !support.sortStable && results.slice(0);\n\t\t\tresults.sort(sortOrder);\n\n\t\t\tif (hasDuplicate) {\n\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\tif (elem === results[i]) {\n\t\t\t\t\t\tj = duplicates.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (j--) {\n\t\t\t\t\tresults.splice(duplicates[j], 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear input after sorting to release objects\n\t\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\t\tsortInput = null;\n\n\t\t\treturn results;\n\t\t};\n\n\t\t/**\n   * Utility function for retrieving the text value of an array of DOM nodes\n   * @param {Array|Element} elem\n   */\n\t\tgetText = Sizzle.getText = function (elem) {\n\t\t\tvar node,\n\t\t\t    ret = \"\",\n\t\t\t    i = 0,\n\t\t\t    nodeType = elem.nodeType;\n\n\t\t\tif (!nodeType) {\n\t\t\t\t// If no nodeType, this is expected to be an array\n\t\t\t\twhile (node = elem[i++]) {\n\t\t\t\t\t// Do not traverse comment nodes\n\t\t\t\t\tret += getText(node);\n\t\t\t\t}\n\t\t\t} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n\t\t\t\t// Use textContent for elements\n\t\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\t\tif (typeof elem.textContent === \"string\") {\n\t\t\t\t\treturn elem.textContent;\n\t\t\t\t} else {\n\t\t\t\t\t// Traverse its children\n\t\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\t\tret += getText(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (nodeType === 3 || nodeType === 4) {\n\t\t\t\treturn elem.nodeValue;\n\t\t\t}\n\t\t\t// Do not include comment or processing instruction nodes\n\n\t\t\treturn ret;\n\t\t};\n\n\t\tExpr = Sizzle.selectors = {\n\n\t\t\t// Can be adjusted by the user\n\t\t\tcacheLength: 50,\n\n\t\t\tcreatePseudo: markFunction,\n\n\t\t\tmatch: matchExpr,\n\n\t\t\tattrHandle: {},\n\n\t\t\tfind: {},\n\n\t\t\trelative: {\n\t\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t\t},\n\n\t\t\tpreFilter: {\n\t\t\t\t\"ATTR\": function ATTR(match) {\n\t\t\t\t\tmatch[1] = match[1].replace(runescape, funescape);\n\n\t\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\t\tmatch[3] = (match[4] || match[5] || \"\").replace(runescape, funescape);\n\n\t\t\t\t\tif (match[2] === \"~=\") {\n\t\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match.slice(0, 4);\n\t\t\t\t},\n\n\t\t\t\t\"CHILD\": function CHILD(match) {\n\t\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n     \t1 type (only|nth|...)\n     \t2 what (child|of-type)\n     \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n     \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n     \t5 sign of xn-component\n     \t6 x of xn-component\n     \t7 sign of y-component\n     \t8 y of y-component\n     */\n\t\t\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\t\t\tif (match[1].slice(0, 3) === \"nth\") {\n\t\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\t\tif (!match[3]) {\n\t\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\t\tmatch[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n\t\t\t\t\t\tmatch[5] = +(match[7] + match[8] || match[3] === \"odd\");\n\n\t\t\t\t\t\t// other types prohibit arguments\n\t\t\t\t\t} else if (match[3]) {\n\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match;\n\t\t\t\t},\n\n\t\t\t\t\"PSEUDO\": function PSEUDO(match) {\n\t\t\t\t\tvar excess,\n\t\t\t\t\t    unquoted = !match[5] && match[2];\n\n\t\t\t\t\tif (matchExpr[\"CHILD\"].test(match[0])) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\t\tif (match[3] && match[4] !== undefined) {\n\t\t\t\t\t\tmatch[2] = match[4];\n\n\t\t\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t\t} else if (unquoted && rpseudo.test(unquoted) && (\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\texcess = tokenize(unquoted, true)) && (\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\texcess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n\n\t\t\t\t\t\t// excess is a negative index\n\t\t\t\t\t\tmatch[0] = match[0].slice(0, excess);\n\t\t\t\t\t\tmatch[2] = unquoted.slice(0, excess);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\t\treturn match.slice(0, 3);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tfilter: {\n\n\t\t\t\t\"TAG\": function TAG(nodeNameSelector) {\n\t\t\t\t\tvar nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n\t\t\t\t\treturn nodeNameSelector === \"*\" ? function () {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} : function (elem) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"CLASS\": function CLASS(className) {\n\t\t\t\t\tvar pattern = classCache[className + \" \"];\n\n\t\t\t\t\treturn pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n\t\t\t\t\t\treturn pattern.test(typeof elem.className === \"string\" && elem.className || _typeof(elem.getAttribute) !== strundefined && elem.getAttribute(\"class\") || \"\");\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\t\"ATTR\": function ATTR(name, operator, check) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar result = Sizzle.attr(elem, name);\n\n\t\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!operator) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult += \"\";\n\n\t\t\t\t\t\treturn operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"CHILD\": function CHILD(type, what, argument, first, last) {\n\t\t\t\t\tvar simple = type.slice(0, 3) !== \"nth\",\n\t\t\t\t\t    forward = type.slice(-4) !== \"last\",\n\t\t\t\t\t    ofType = what === \"of-type\";\n\n\t\t\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction (elem) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} : function (elem, context, xml) {\n\t\t\t\t\t\tvar cache,\n\t\t\t\t\t\t    outerCache,\n\t\t\t\t\t\t    node,\n\t\t\t\t\t\t    diff,\n\t\t\t\t\t\t    nodeIndex,\n\t\t\t\t\t\t    start,\n\t\t\t\t\t\t    dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t    parent = elem.parentNode,\n\t\t\t\t\t\t    name = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t    useCache = !xml && !ofType;\n\n\t\t\t\t\t\tif (parent) {\n\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif (simple) {\n\t\t\t\t\t\t\t\twhile (dir) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile (node = node[dir]) {\n\t\t\t\t\t\t\t\t\t\tif (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstart = [forward ? parent.firstChild : parent.lastChild];\n\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif (forward && useCache) {\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\t\touterCache = parent[expando] || (parent[expando] = {});\n\t\t\t\t\t\t\t\tcache = outerCache[type] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[nodeIndex];\n\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\tdiff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif (node.nodeType === 1 && ++diff && node === elem) {\n\t\t\t\t\t\t\t\t\t\touterCache[type] = [dirruns, nodeIndex, diff];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t} else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {\n\t\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\tif ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t\t\t(node[expando] || (node[expando] = {}))[type] = [dirruns, diff];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (node === elem) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || diff % first === 0 && diff / first >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"PSEUDO\": function PSEUDO(pseudo, argument) {\n\t\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\t\tvar args,\n\t\t\t\t\t    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo);\n\n\t\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t\t// just as Sizzle does\n\t\t\t\t\tif (fn[expando]) {\n\t\t\t\t\t\treturn fn(argument);\n\t\t\t\t\t}\n\n\t\t\t\t\t// But maintain support for old signatures\n\t\t\t\t\tif (fn.length > 1) {\n\t\t\t\t\t\targs = [pseudo, pseudo, \"\", argument];\n\t\t\t\t\t\treturn Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t    matched = fn(seed, argument),\n\t\t\t\t\t\t\t    i = matched.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tidx = indexOf.call(seed, matched[i]);\n\t\t\t\t\t\t\t\tseed[idx] = !(matches[idx] = matched[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) : function (elem) {\n\t\t\t\t\t\t\treturn fn(elem, 0, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tpseudos: {\n\t\t\t\t// Potentially complex pseudos\n\t\t\t\t\"not\": markFunction(function (selector) {\n\t\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t\t// spaces as combinators\n\t\t\t\t\tvar input = [],\n\t\t\t\t\t    results = [],\n\t\t\t\t\t    matcher = compile(selector.replace(rtrim, \"$1\"));\n\n\t\t\t\t\treturn matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t    unmatched = matcher(seed, null, xml, []),\n\t\t\t\t\t\t    i = seed.length;\n\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (elem, context, xml) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher(input, null, xml, results);\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t\"has\": markFunction(function (selector) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn Sizzle(selector, elem).length > 0;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t\"contains\": markFunction(function (text) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t\t// is based solely on the element's language value\n\t\t\t\t// being equal to the identifier C,\n\t\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\t\"lang\": markFunction(function (lang) {\n\t\t\t\t\t// lang value must be a valid identifier\n\t\t\t\t\tif (!ridentifier.test(lang || \"\")) {\n\t\t\t\t\t\tSizzle.error(\"unsupported lang: \" + lang);\n\t\t\t\t\t}\n\t\t\t\t\tlang = lang.replace(runescape, funescape).toLowerCase();\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar elemLang;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n\n\t\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ((elem = elem.parentNode) && elem.nodeType === 1);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t// Miscellaneous\n\t\t\t\t\"target\": function target(elem) {\n\t\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\t\treturn hash && hash.slice(1) === elem.id;\n\t\t\t\t},\n\n\t\t\t\t\"root\": function root(elem) {\n\t\t\t\t\treturn elem === docElem;\n\t\t\t\t},\n\n\t\t\t\t\"focus\": function focus(elem) {\n\t\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t\t},\n\n\t\t\t\t// Boolean properties\n\t\t\t\t\"enabled\": function enabled(elem) {\n\t\t\t\t\treturn elem.disabled === false;\n\t\t\t\t},\n\n\t\t\t\t\"disabled\": function disabled(elem) {\n\t\t\t\t\treturn elem.disabled === true;\n\t\t\t\t},\n\n\t\t\t\t\"checked\": function checked(elem) {\n\t\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\t\treturn nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n\t\t\t\t},\n\n\t\t\t\t\"selected\": function selected(elem) {\n\t\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t\t// options in Safari work properly\n\t\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem.selected === true;\n\t\t\t\t},\n\n\t\t\t\t// Contents\n\t\t\t\t\"empty\": function empty(elem) {\n\t\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\t\tif (elem.nodeType < 6) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t\"parent\": function parent(elem) {\n\t\t\t\t\treturn !Expr.pseudos[\"empty\"](elem);\n\t\t\t\t},\n\n\t\t\t\t// Element/input types\n\t\t\t\t\"header\": function header(elem) {\n\t\t\t\t\treturn rheader.test(elem.nodeName);\n\t\t\t\t},\n\n\t\t\t\t\"input\": function input(elem) {\n\t\t\t\t\treturn rinputs.test(elem.nodeName);\n\t\t\t\t},\n\n\t\t\t\t\"button\": function button(elem) {\n\t\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t\t},\n\n\t\t\t\t\"text\": function text(elem) {\n\t\t\t\t\tvar attr;\n\t\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && (\n\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t(attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n\t\t\t\t},\n\n\t\t\t\t// Position-in-collection\n\t\t\t\t\"first\": createPositionalPseudo(function () {\n\t\t\t\t\treturn [0];\n\t\t\t\t}),\n\n\t\t\t\t\"last\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\treturn [length - 1];\n\t\t\t\t}),\n\n\t\t\t\t\"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\treturn [argument < 0 ? argument + length : argument];\n\t\t\t\t}),\n\n\t\t\t\t\"even\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"odd\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\tvar i = 1;\n\t\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\t\tfor (; --i >= 0;) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\t\tfor (; ++i < length;) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n\t\t// Add button/input type pseudos\n\t\tfor (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n\t\t\tExpr.pseudos[i] = createInputPseudo(i);\n\t\t}\n\t\tfor (i in { submit: true, reset: true }) {\n\t\t\tExpr.pseudos[i] = createButtonPseudo(i);\n\t\t}\n\n\t\t// Easy API for creating new setFilters\n\t\tfunction setFilters() {}\n\t\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\t\tExpr.setFilters = new setFilters();\n\n\t\tfunction tokenize(selector, parseOnly) {\n\t\t\tvar matched,\n\t\t\t    match,\n\t\t\t    tokens,\n\t\t\t    type,\n\t\t\t    soFar,\n\t\t\t    groups,\n\t\t\t    preFilters,\n\t\t\t    cached = tokenCache[selector + \" \"];\n\n\t\t\tif (cached) {\n\t\t\t\treturn parseOnly ? 0 : cached.slice(0);\n\t\t\t}\n\n\t\t\tsoFar = selector;\n\t\t\tgroups = [];\n\t\t\tpreFilters = Expr.preFilter;\n\n\t\t\twhile (soFar) {\n\n\t\t\t\t// Comma and first run\n\t\t\t\tif (!matched || (match = rcomma.exec(soFar))) {\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\t\tsoFar = soFar.slice(match[0].length) || soFar;\n\t\t\t\t\t}\n\t\t\t\t\tgroups.push(tokens = []);\n\t\t\t\t}\n\n\t\t\t\tmatched = false;\n\n\t\t\t\t// Combinators\n\t\t\t\tif (match = rcombinators.exec(soFar)) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\t\ttype: match[0].replace(rtrim, \" \")\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t}\n\n\t\t\t\t// Filters\n\t\t\t\tfor (type in Expr.filter) {\n\t\t\t\t\tif ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n\t\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\t\tmatches: match\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!matched) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the length of the invalid excess\n\t\t\t// if we're just parsing\n\t\t\t// Otherwise, throw an error or return tokens\n\t\t\treturn parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache(selector, groups).slice(0);\n\t\t}\n\n\t\tfunction toSelector(tokens) {\n\t\t\tvar i = 0,\n\t\t\t    len = tokens.length,\n\t\t\t    selector = \"\";\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tselector += tokens[i].value;\n\t\t\t}\n\t\t\treturn selector;\n\t\t}\n\n\t\tfunction addCombinator(matcher, combinator, base) {\n\t\t\tvar dir = combinator.dir,\n\t\t\t    checkNonElements = base && dir === \"parentNode\",\n\t\t\t    doneName = done++;\n\n\t\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction (elem, context, xml) {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\treturn matcher(elem, context, xml);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} :\n\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction (elem, context, xml) {\n\t\t\t\tvar oldCache,\n\t\t\t\t    outerCache,\n\t\t\t\t    newCache = [dirruns, doneName];\n\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\t\tif (xml) {\n\t\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\t\touterCache = elem[expando] || (elem[expando] = {});\n\t\t\t\t\t\t\tif ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn newCache[2] = oldCache[2];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\touterCache[dir] = newCache;\n\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif (newCache[2] = matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction elementMatcher(matchers) {\n\t\t\treturn matchers.length > 1 ? function (elem, context, xml) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (!matchers[i](elem, context, xml)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} : matchers[0];\n\t\t}\n\n\t\tfunction condense(unmatched, map, filter, context, xml) {\n\t\t\tvar elem,\n\t\t\t    newUnmatched = [],\n\t\t\t    i = 0,\n\t\t\t    len = unmatched.length,\n\t\t\t    mapped = map != null;\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\tif (!filter || filter(elem, context, xml)) {\n\t\t\t\t\t\tnewUnmatched.push(elem);\n\t\t\t\t\t\tif (mapped) {\n\t\t\t\t\t\t\tmap.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newUnmatched;\n\t\t}\n\n\t\tfunction setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n\t\t\tif (postFilter && !postFilter[expando]) {\n\t\t\t\tpostFilter = setMatcher(postFilter);\n\t\t\t}\n\t\t\tif (postFinder && !postFinder[expando]) {\n\t\t\t\tpostFinder = setMatcher(postFinder, postSelector);\n\t\t\t}\n\t\t\treturn markFunction(function (seed, results, context, xml) {\n\t\t\t\tvar temp,\n\t\t\t\t    i,\n\t\t\t\t    elem,\n\t\t\t\t    preMap = [],\n\t\t\t\t    postMap = [],\n\t\t\t\t    preexisting = results.length,\n\n\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n\n\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n\t\t\t\t    matcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || (seed ? preFilter : preexisting || postFilter) ?\n\n\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t[] :\n\n\t\t\t\t// ...otherwise use results directly\n\t\t\t\tresults : matcherIn;\n\n\t\t\t\t// Find primary matches\n\t\t\t\tif (matcher) {\n\t\t\t\t\tmatcher(matcherIn, matcherOut, context, xml);\n\t\t\t\t}\n\n\t\t\t\t// Apply postFilter\n\t\t\t\tif (postFilter) {\n\t\t\t\t\ttemp = condense(matcherOut, postMap);\n\t\t\t\t\tpostFilter(temp, [], context, xml);\n\n\t\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\t\ti = temp.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (elem = temp[i]) {\n\t\t\t\t\t\t\tmatcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (seed) {\n\t\t\t\t\tif (postFinder || preFilter) {\n\t\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (elem = matcherOut[i]) {\n\t\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\t\ttemp.push(matcherIn[i] = elem);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpostFinder(null, matcherOut = [], temp, xml);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {\n\n\t\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t\t} else {\n\t\t\t\t\tmatcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\tpostFinder(null, results, matcherOut, xml);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpush.apply(results, matcherOut);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction matcherFromTokens(tokens) {\n\t\t\tvar checkContext,\n\t\t\t    matcher,\n\t\t\t    j,\n\t\t\t    len = tokens.length,\n\t\t\t    leadingRelative = Expr.relative[tokens[0].type],\n\t\t\t    implicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\t    i = leadingRelative ? 1 : 0,\n\n\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator(function (elem) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true),\n\t\t\t    matchAnyContext = addCombinator(function (elem) {\n\t\t\t\treturn indexOf.call(checkContext, elem) > -1;\n\t\t\t}, implicitRelative, true),\n\t\t\t    matchers = [function (elem, context, xml) {\n\t\t\t\treturn !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n\t\t\t}];\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (matcher = Expr.relative[tokens[i].type]) {\n\t\t\t\t\tmatchers = [addCombinator(elementMatcher(matchers), matcher)];\n\t\t\t\t} else {\n\t\t\t\t\tmatcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n\n\t\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\t\tif (matcher[expando]) {\n\t\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\t\tj = ++i;\n\t\t\t\t\t\tfor (; j < len; j++) {\n\t\t\t\t\t\t\tif (Expr.relative[tokens[j].type]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === \" \" ? \"*\" : \"\" })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n\t\t\t\t\t}\n\t\t\t\t\tmatchers.push(matcher);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn elementMatcher(matchers);\n\t\t}\n\n\t\tfunction matcherFromGroupMatchers(elementMatchers, setMatchers) {\n\t\t\tvar bySet = setMatchers.length > 0,\n\t\t\t    byElement = elementMatchers.length > 0,\n\t\t\t    superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n\t\t\t\tvar elem,\n\t\t\t\t    j,\n\t\t\t\t    matcher,\n\t\t\t\t    matchedCount = 0,\n\t\t\t\t    i = \"0\",\n\t\t\t\t    unmatched = seed && [],\n\t\t\t\t    setMatched = [],\n\t\t\t\t    contextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n\t\t\t\t    len = elems.length;\n\n\t\t\t\tif (outermost) {\n\t\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\t}\n\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor (; i !== len && (elem = elems[i]) != null; i++) {\n\t\t\t\t\tif (byElement && elem) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (matcher = elementMatchers[j++]) {\n\t\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outermost) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif (bySet) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif (elem = !matcher && elem) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif (seed) {\n\t\t\t\t\t\t\tunmatched.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\tmatchedCount += i;\n\t\t\t\tif (bySet && i !== matchedCount) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile (matcher = setMatchers[j++]) {\n\t\t\t\t\t\tmatcher(unmatched, setMatched, context, xml);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (seed) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif (matchedCount > 0) {\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (!(unmatched[i] || setMatched[i])) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call(results);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense(setMatched);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply(results, setMatched);\n\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n\n\t\t\t\t\t\tSizzle.uniqueSort(results);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif (outermost) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\n\t\t\t\treturn unmatched;\n\t\t\t};\n\n\t\t\treturn bySet ? markFunction(superMatcher) : superMatcher;\n\t\t}\n\n\t\tcompile = Sizzle.compile = function (selector, group /* Internal Use Only */) {\n\t\t\tvar i,\n\t\t\t    setMatchers = [],\n\t\t\t    elementMatchers = [],\n\t\t\t    cached = compilerCache[selector + \" \"];\n\n\t\t\tif (!cached) {\n\t\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\t\tif (!group) {\n\t\t\t\t\tgroup = tokenize(selector);\n\t\t\t\t}\n\t\t\t\ti = group.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tcached = matcherFromTokens(group[i]);\n\t\t\t\t\tif (cached[expando]) {\n\t\t\t\t\t\tsetMatchers.push(cached);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telementMatchers.push(cached);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Cache the compiled function\n\t\t\t\tcached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n\t\t\t}\n\t\t\treturn cached;\n\t\t};\n\n\t\tfunction multipleContexts(selector, contexts, results) {\n\t\t\tvar i = 0,\n\t\t\t    len = contexts.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tSizzle(selector, contexts[i], results);\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tfunction select(selector, context, results, seed) {\n\t\t\tvar i,\n\t\t\t    tokens,\n\t\t\t    token,\n\t\t\t    type,\n\t\t\t    find,\n\t\t\t    match = tokenize(selector);\n\n\t\t\tif (!seed) {\n\t\t\t\t// Try to minimize operations if there is only one group\n\t\t\t\tif (match.length === 1) {\n\n\t\t\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\t\t\ttokens = match[0] = match[0].slice(0);\n\t\t\t\t\tif (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n\n\t\t\t\t\t\tcontext = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\t\t\t\t\t\tif (!context) {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselector = selector.slice(tokens.shift().value.length);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\t\t\ti = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t\t\t// Abort if we hit a combinator\n\t\t\t\t\t\tif (Expr.relative[type = token.type]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (find = Expr.find[type]) {\n\t\t\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\t\t\tif (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n\n\t\t\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\t\t\ttokens.splice(i, 1);\n\t\t\t\t\t\t\t\tselector = seed.length && toSelector(tokens);\n\t\t\t\t\t\t\t\tif (!selector) {\n\t\t\t\t\t\t\t\t\tpush.apply(results, seed);\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Compile and execute a filtering function\n\t\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t\tcompile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);\n\t\t\treturn results;\n\t\t}\n\n\t\t// One-time assignments\n\n\t\t// Sort stability\n\t\tsupport.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n\n\t\t// Support: Chrome<14\n\t\t// Always assume duplicates if they aren't passed to the comparison function\n\t\tsupport.detectDuplicates = !!hasDuplicate;\n\n\t\t// Initialize against the default document\n\t\tsetDocument();\n\n\t\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t\t// Detached nodes confoundingly follow *each other*\n\t\tsupport.sortDetached = assert(function (div1) {\n\t\t\t// Should return 1, but returns 4 (following)\n\t\t\treturn div1.compareDocumentPosition(document.createElement(\"div\")) & 1;\n\t\t});\n\n\t\t// Support: IE<8\n\t\t// Prevent attribute/property \"interpolation\"\n\t\t// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\t\tif (!assert(function (div) {\n\t\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\t\t\treturn div.firstChild.getAttribute(\"href\") === \"#\";\n\t\t})) {\n\t\t\taddHandle(\"type|href|height|width\", function (elem, name, isXML) {\n\t\t\t\tif (!isXML) {\n\t\t\t\t\treturn elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Use defaultValue in place of getAttribute(\"value\")\n\t\tif (!support.attributes || !assert(function (div) {\n\t\t\tdiv.innerHTML = \"<input/>\";\n\t\t\tdiv.firstChild.setAttribute(\"value\", \"\");\n\t\t\treturn div.firstChild.getAttribute(\"value\") === \"\";\n\t\t})) {\n\t\t\taddHandle(\"value\", function (elem, name, isXML) {\n\t\t\t\tif (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n\t\t\t\t\treturn elem.defaultValue;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\t\tif (!assert(function (div) {\n\t\t\treturn div.getAttribute(\"disabled\") == null;\n\t\t})) {\n\t\t\taddHandle(booleans, function (elem, name, isXML) {\n\t\t\t\tvar val;\n\t\t\t\tif (!isXML) {\n\t\t\t\t\treturn elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn Sizzle;\n\t}(window);\n\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\tjQuery.expr[\":\"] = jQuery.expr.pseudos;\n\tjQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\n\tvar rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/;\n\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n\t// Implement the identical functionality for filter and not\n\tfunction winnow(elements, qualifier, not) {\n\t\tif (jQuery.isFunction(qualifier)) {\n\t\t\treturn jQuery.grep(elements, function (elem, i) {\n\t\t\t\t/* jshint -W018 */\n\t\t\t\treturn !!qualifier.call(elem, i, elem) !== not;\n\t\t\t});\n\t\t}\n\n\t\tif (qualifier.nodeType) {\n\t\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\t\treturn elem === qualifier !== not;\n\t\t\t});\n\t\t}\n\n\t\tif (typeof qualifier === \"string\") {\n\t\t\tif (risSimple.test(qualifier)) {\n\t\t\t\treturn jQuery.filter(qualifier, elements, not);\n\t\t\t}\n\n\t\t\tqualifier = jQuery.filter(qualifier, elements);\n\t\t}\n\n\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\treturn jQuery.inArray(elem, qualifier) >= 0 !== not;\n\t\t});\n\t}\n\n\tjQuery.filter = function (expr, elems, not) {\n\t\tvar elem = elems[0];\n\n\t\tif (not) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n\t};\n\n\tjQuery.fn.extend({\n\t\tfind: function find(selector) {\n\t\t\tvar i,\n\t\t\t    ret = [],\n\t\t\t    self = this,\n\t\t\t    len = self.length;\n\n\t\t\tif (typeof selector !== \"string\") {\n\t\t\t\treturn this.pushStack(jQuery(selector).filter(function () {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (jQuery.contains(self[i], this)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tjQuery.find(selector, self[i], ret);\n\t\t\t}\n\n\t\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\t\tret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);\n\t\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\t\treturn ret;\n\t\t},\n\t\tfilter: function filter(selector) {\n\t\t\treturn this.pushStack(winnow(this, selector || [], false));\n\t\t},\n\t\tnot: function not(selector) {\n\t\t\treturn this.pushStack(winnow(this, selector || [], true));\n\t\t},\n\t\tis: function is(selector) {\n\t\t\treturn !!winnow(this,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n\t\t}\n\t});\n\n\t// Initialize a jQuery object\n\n\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\t    init = jQuery.fn.init = function (selector, context) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif (!selector) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif (typeof selector === \"string\") {\n\t\t\tif (selector.charAt(0) === \"<\" && selector.charAt(selector.length - 1) === \">\" && selector.length >= 3) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [null, selector, null];\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec(selector);\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif (match && (match[1] || !context)) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif (match[1]) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n\t\t\t\t\t\tfor (match in context) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif (jQuery.isFunction(this[match])) {\n\t\t\t\t\t\t\t\tthis[match](context[match]);\n\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr(match, context[match]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById(match[2]);\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif (elem && elem.parentNode) {\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif (elem.id !== match[2]) {\n\t\t\t\t\t\t\treturn rootjQuery.find(selector);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if (!context || context.jquery) {\n\t\t\t\treturn (context || rootjQuery).find(selector);\n\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor(context).find(selector);\n\t\t\t}\n\n\t\t\t// HANDLE: $(DOMElement)\n\t\t} else if (selector.nodeType) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t} else if (jQuery.isFunction(selector)) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ? rootjQuery.ready(selector) :\n\t\t\t// Execute immediately if ready is not present\n\t\t\tselector(jQuery);\n\t\t}\n\n\t\tif (selector.selector !== undefined) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray(selector, this);\n\t};\n\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\n\t// Initialize central reference\n\trootjQuery = jQuery(document);\n\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\n\tjQuery.extend({\n\t\tdir: function dir(elem, _dir, until) {\n\t\t\tvar matched = [],\n\t\t\t    cur = elem[_dir];\n\n\t\t\twhile (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {\n\t\t\t\tif (cur.nodeType === 1) {\n\t\t\t\t\tmatched.push(cur);\n\t\t\t\t}\n\t\t\t\tcur = cur[_dir];\n\t\t\t}\n\t\t\treturn matched;\n\t\t},\n\n\t\tsibling: function sibling(n, elem) {\n\t\t\tvar r = [];\n\n\t\t\tfor (; n; n = n.nextSibling) {\n\t\t\t\tif (n.nodeType === 1 && n !== elem) {\n\t\t\t\t\tr.push(n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn r;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\thas: function has(target) {\n\t\t\tvar i,\n\t\t\t    targets = jQuery(target, this),\n\t\t\t    len = targets.length;\n\n\t\t\treturn this.filter(function () {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tif (jQuery.contains(this, targets[i])) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tclosest: function closest(selectors, context) {\n\t\t\tvar cur,\n\t\t\t    i = 0,\n\t\t\t    l = this.length,\n\t\t\t    matched = [],\n\t\t\t    pos = rneedsContext.test(selectors) || typeof selectors !== \"string\" ? jQuery(selectors, context || this.context) : 0;\n\n\t\t\tfor (; i < l; i++) {\n\t\t\t\tfor (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n\n\t\t\t\t\t\tmatched.push(cur);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);\n\t\t},\n\n\t\t// Determine the position of an element within\n\t\t// the matched set of elements\n\t\tindex: function index(elem) {\n\n\t\t\t// No argument, return index in parent\n\t\t\tif (!elem) {\n\t\t\t\treturn this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n\t\t\t}\n\n\t\t\t// index in selector\n\t\t\tif (typeof elem === \"string\") {\n\t\t\t\treturn jQuery.inArray(this[0], jQuery(elem));\n\t\t\t}\n\n\t\t\t// Locate the position of the desired element\n\t\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem, this);\n\t\t},\n\n\t\tadd: function add(selector, context) {\n\t\t\treturn this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));\n\t\t},\n\n\t\taddBack: function addBack(selector) {\n\t\t\treturn this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n\t\t}\n\t});\n\n\tfunction sibling(cur, dir) {\n\t\tdo {\n\t\t\tcur = cur[dir];\n\t\t} while (cur && cur.nodeType !== 1);\n\n\t\treturn cur;\n\t}\n\n\tjQuery.each({\n\t\tparent: function parent(elem) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function parents(elem) {\n\t\t\treturn jQuery.dir(elem, \"parentNode\");\n\t\t},\n\t\tparentsUntil: function parentsUntil(elem, i, until) {\n\t\t\treturn jQuery.dir(elem, \"parentNode\", until);\n\t\t},\n\t\tnext: function next(elem) {\n\t\t\treturn sibling(elem, \"nextSibling\");\n\t\t},\n\t\tprev: function prev(elem) {\n\t\t\treturn sibling(elem, \"previousSibling\");\n\t\t},\n\t\tnextAll: function nextAll(elem) {\n\t\t\treturn jQuery.dir(elem, \"nextSibling\");\n\t\t},\n\t\tprevAll: function prevAll(elem) {\n\t\t\treturn jQuery.dir(elem, \"previousSibling\");\n\t\t},\n\t\tnextUntil: function nextUntil(elem, i, until) {\n\t\t\treturn jQuery.dir(elem, \"nextSibling\", until);\n\t\t},\n\t\tprevUntil: function prevUntil(elem, i, until) {\n\t\t\treturn jQuery.dir(elem, \"previousSibling\", until);\n\t\t},\n\t\tsiblings: function siblings(elem) {\n\t\t\treturn jQuery.sibling((elem.parentNode || {}).firstChild, elem);\n\t\t},\n\t\tchildren: function children(elem) {\n\t\t\treturn jQuery.sibling(elem.firstChild);\n\t\t},\n\t\tcontents: function contents(elem) {\n\t\t\treturn jQuery.nodeName(elem, \"iframe\") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);\n\t\t}\n\t}, function (name, fn) {\n\t\tjQuery.fn[name] = function (until, selector) {\n\t\t\tvar ret = jQuery.map(this, fn, until);\n\n\t\t\tif (name.slice(-5) !== \"Until\") {\n\t\t\t\tselector = until;\n\t\t\t}\n\n\t\t\tif (selector && typeof selector === \"string\") {\n\t\t\t\tret = jQuery.filter(selector, ret);\n\t\t\t}\n\n\t\t\tif (this.length > 1) {\n\t\t\t\t// Remove duplicates\n\t\t\t\tif (!guaranteedUnique[name]) {\n\t\t\t\t\tret = jQuery.unique(ret);\n\t\t\t\t}\n\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif (rparentsprev.test(name)) {\n\t\t\t\t\tret = ret.reverse();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack(ret);\n\t\t};\n\t});\n\tvar rnotwhite = /\\S+/g;\n\n\t// String to Object options format cache\n\tvar optionsCache = {};\n\n\t// Convert String-formatted options into Object-formatted ones and store in cache\n\tfunction createOptions(options) {\n\t\tvar object = optionsCache[options] = {};\n\t\tjQuery.each(options.match(rnotwhite) || [], function (_, flag) {\n\t\t\tobject[flag] = true;\n\t\t});\n\t\treturn object;\n\t}\n\n\t/*\n  * Create a callback list using the following parameters:\n  *\n  *\toptions: an optional list of space-separated options that will change how\n  *\t\t\tthe callback list behaves or a more traditional option object\n  *\n  * By default a callback list will act like an event callback list and can be\n  * \"fired\" multiple times.\n  *\n  * Possible options:\n  *\n  *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n  *\n  *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n  *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n  *\t\t\t\t\tvalues (like a Deferred)\n  *\n  *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n  *\n  *\tstopOnFalse:\tinterrupt callings when a callback returns false\n  *\n  */\n\tjQuery.Callbacks = function (options) {\n\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);\n\n\t\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value (for non-forgettable lists)\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\t_fired,\n\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\n\t\t// Fire callbacks\n\t\tfire = function fire(data) {\n\t\t\tmemory = options.memory && data;\n\t\t\t_fired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor (; list && firingIndex < firingLength; firingIndex++) {\n\t\t\t\tif (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif (list) {\n\t\t\t\tif (stack) {\n\t\t\t\t\tif (stack.length) {\n\t\t\t\t\t\tfire(stack.shift());\n\t\t\t\t\t}\n\t\t\t\t} else if (memory) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function add() {\n\t\t\t\tif (list) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add(args) {\n\t\t\t\t\t\tjQuery.each(args, function (_, arg) {\n\t\t\t\t\t\t\tvar type = jQuery.type(arg);\n\t\t\t\t\t\t\tif (type === \"function\") {\n\t\t\t\t\t\t\t\tif (!options.unique || !self.has(arg)) {\n\t\t\t\t\t\t\t\t\tlist.push(arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (arg && arg.length && type !== \"string\") {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd(arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})(arguments);\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif (firing) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if (memory) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire(memory);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function remove() {\n\t\t\t\tif (list) {\n\t\t\t\t\tjQuery.each(arguments, function (_, arg) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ((index = jQuery.inArray(arg, list, index)) > -1) {\n\t\t\t\t\t\t\tlist.splice(index, 1);\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif (firing) {\n\t\t\t\t\t\t\t\tif (index <= firingLength) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (index <= firingIndex) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function has(fn) {\n\t\t\t\treturn fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function empty() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function disable() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function disabled() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function lock() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif (!memory) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function locked() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function fireWith(context, args) {\n\t\t\t\tif (list && (!_fired || stack)) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [context, args.slice ? args.slice() : args];\n\t\t\t\t\tif (firing) {\n\t\t\t\t\t\tstack.push(args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire(args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function fire() {\n\t\t\t\tself.fireWith(this, arguments);\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function fired() {\n\t\t\t\treturn !!_fired;\n\t\t\t}\n\t\t};\n\n\t\treturn self;\n\t};\n\n\tjQuery.extend({\n\n\t\tDeferred: function Deferred(func) {\n\t\t\tvar tuples = [\n\t\t\t// action, add listener, listener list, final state\n\t\t\t[\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n\t\t\t    _state = \"pending\",\n\t\t\t    _promise = {\n\t\t\t\tstate: function state() {\n\t\t\t\t\treturn _state;\n\t\t\t\t},\n\t\t\t\talways: function always() {\n\t\t\t\t\tdeferred.done(arguments).fail(arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function then() /* fnDone, fnFail, fnProgress */{\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\t\t\t\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction(fns[i]) && fns[i];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[tuple[1]](function () {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply(this, arguments);\n\t\t\t\t\t\t\t\tif (returned && jQuery.isFunction(returned.promise)) {\n\t\t\t\t\t\t\t\t\treturned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[tuple[0] + \"With\"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function promise(obj) {\n\t\t\t\t\treturn obj != null ? jQuery.extend(obj, _promise) : _promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\t    deferred = {};\n\n\t\t\t// Keep pipe for back-compat\n\t\t\t_promise.pipe = _promise.then;\n\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\tvar list = tuple[2],\n\t\t\t\t    stateString = tuple[3];\n\n\t\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\t\t_promise[tuple[1]] = list.add;\n\n\t\t\t\t// Handle state\n\t\t\t\tif (stateString) {\n\t\t\t\t\tlist.add(function () {\n\t\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\t\t_state = stateString;\n\n\t\t\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t\t}, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n\t\t\t\t}\n\n\t\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\t\tdeferred[tuple[0]] = function () {\n\t\t\t\t\tdeferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\t\t\tdeferred[tuple[0] + \"With\"] = list.fireWith;\n\t\t\t});\n\n\t\t\t// Make the deferred a promise\n\t\t\t_promise.promise(deferred);\n\n\t\t\t// Call given func if any\n\t\t\tif (func) {\n\t\t\t\tfunc.call(deferred, deferred);\n\t\t\t}\n\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\n\t\t// Deferred helper\n\t\twhen: function when(subordinate /* , ..., subordinateN */) {\n\t\t\tvar i = 0,\n\t\t\t    resolveValues = _slice.call(arguments),\n\t\t\t    length = resolveValues.length,\n\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function updateFunc(i, contexts, values) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tcontexts[i] = this;\n\t\t\t\t\tvalues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\t\t\t\t\tif (values === progressValues) {\n\t\t\t\t\t\tdeferred.notifyWith(contexts, values);\n\t\t\t\t\t} else if (! --remaining) {\n\t\t\t\t\t\tdeferred.resolveWith(contexts, values);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\t    progressValues,\n\t\t\t    progressContexts,\n\t\t\t    resolveContexts;\n\n\t\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\t\tif (length > 1) {\n\t\t\t\tprogressValues = new Array(length);\n\t\t\t\tprogressContexts = new Array(length);\n\t\t\t\tresolveContexts = new Array(length);\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tif (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n\t\t\t\t\t\tresolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we're not waiting on anything, resolve the master\n\t\t\tif (!remaining) {\n\t\t\t\tdeferred.resolveWith(resolveContexts, resolveValues);\n\t\t\t}\n\n\t\t\treturn deferred.promise();\n\t\t}\n\t});\n\n\t// The deferred used on DOM ready\n\tvar readyList;\n\n\tjQuery.fn.ready = function (fn) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done(fn);\n\n\t\treturn this;\n\t};\n\n\tjQuery.extend({\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function holdReady(hold) {\n\t\t\tif (hold) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready(true);\n\t\t\t}\n\t\t},\n\n\t\t// Handle when the DOM is ready\n\t\tready: function ready(wait) {\n\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\t\tif (!document.body) {\n\t\t\t\treturn setTimeout(jQuery.ready);\n\t\t\t}\n\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif (wait !== true && --jQuery.readyWait > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith(document, [jQuery]);\n\n\t\t\t// Trigger any bound ready events\n\t\t\tif (jQuery.fn.trigger) {\n\t\t\t\tjQuery(document).trigger(\"ready\").off(\"ready\");\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n  * Clean-up method for dom ready events\n  */\n\tfunction detach() {\n\t\tif (document.addEventListener) {\n\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", completed, false);\n\t\t\twindow.removeEventListener(\"load\", completed, false);\n\t\t} else {\n\t\t\tdocument.detachEvent(\"onreadystatechange\", completed);\n\t\t\twindow.detachEvent(\"onload\", completed);\n\t\t}\n\t}\n\n\t/**\n  * The ready event handler and self cleanup method\n  */\n\tfunction completed() {\n\t\t// readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\t\tif (document.addEventListener || event.type === \"load\" || document.readyState === \"complete\") {\n\t\t\tdetach();\n\t\t\tjQuery.ready();\n\t\t}\n\t}\n\n\tjQuery.ready.promise = function (obj) {\n\t\tif (!readyList) {\n\n\t\t\treadyList = jQuery.Deferred();\n\n\t\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\t\tif (document.readyState === \"complete\") {\n\t\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\t\tsetTimeout(jQuery.ready);\n\n\t\t\t\t// Standards-based browsers support DOMContentLoaded\n\t\t\t} else if (document.addEventListener) {\n\t\t\t\t// Use the handy event callback\n\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", completed, false);\n\n\t\t\t\t// A fallback to window.onload, that will always work\n\t\t\t\twindow.addEventListener(\"load\", completed, false);\n\n\t\t\t\t// If IE event model is used\n\t\t\t} else {\n\t\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\t\t\t\tdocument.attachEvent(\"onreadystatechange\", completed);\n\n\t\t\t\t// A fallback to window.onload, that will always work\n\t\t\t\twindow.attachEvent(\"onload\", completed);\n\n\t\t\t\t// If IE and not a frame\n\t\t\t\t// continually check to see if the document is ready\n\t\t\t\tvar top = false;\n\n\t\t\t\ttry {\n\t\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\t\t\t\t} catch (e) {}\n\n\t\t\t\tif (top && top.doScroll) {\n\t\t\t\t\t(function doScrollCheck() {\n\t\t\t\t\t\tif (!jQuery.isReady) {\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\t\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\t\t\ttop.doScroll(\"left\");\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn setTimeout(doScrollCheck, 50);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// detach all dom ready events\n\t\t\t\t\t\t\tdetach();\n\n\t\t\t\t\t\t\t// and execute any waiting functions\n\t\t\t\t\t\t\tjQuery.ready();\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn readyList.promise(obj);\n\t};\n\n\tvar strundefined =  true ? \"undefined\" : _typeof(undefined);\n\n\t// Support: IE<9\n\t// Iteration over object's inherited properties before its own\n\tvar i;\n\tfor (i in jQuery(support)) {\n\t\tbreak;\n\t}\n\tsupport.ownLast = i !== \"0\";\n\n\t// Note: most support tests are defined in their respective modules.\n\t// false until the test is run\n\tsupport.inlineBlockNeedsLayout = false;\n\n\tjQuery(function () {\n\t\t// We need to execute this one support test ASAP because we need to know\n\t\t// if body.style.zoom needs to be set.\n\n\t\tvar container,\n\t\t    div,\n\t\t    body = document.getElementsByTagName(\"body\")[0];\n\n\t\tif (!body) {\n\t\t\t// Return for frameset docs that don't have a body\n\t\t\treturn;\n\t\t}\n\n\t\t// Setup\n\t\tcontainer = document.createElement(\"div\");\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n\n\t\tdiv = document.createElement(\"div\");\n\t\tbody.appendChild(container).appendChild(div);\n\n\t\tif (_typeof(div.style.zoom) !== strundefined) {\n\t\t\t// Support: IE<8\n\t\t\t// Check if natively block-level elements act like inline-block\n\t\t\t// elements when setting their display to 'inline' and giving\n\t\t\t// them layout\n\t\t\tdiv.style.cssText = \"border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1\";\n\n\t\t\tif (support.inlineBlockNeedsLayout = div.offsetWidth === 3) {\n\t\t\t\t// Prevent IE 6 from affecting layout for positioned elements #11048\n\t\t\t\t// Prevent IE from shrinking the body in IE 7 mode #12869\n\t\t\t\t// Support: IE<8\n\t\t\t\tbody.style.zoom = 1;\n\t\t\t}\n\t\t}\n\n\t\tbody.removeChild(container);\n\n\t\t// Null elements to avoid leaks in IE\n\t\tcontainer = div = null;\n\t});\n\n\t(function () {\n\t\tvar div = document.createElement(\"div\");\n\n\t\t// Execute the test only if not already executed in another module.\n\t\tif (support.deleteExpando == null) {\n\t\t\t// Support: IE<9\n\t\t\tsupport.deleteExpando = true;\n\t\t\ttry {\n\t\t\t\tdelete div.test;\n\t\t\t} catch (e) {\n\t\t\t\tsupport.deleteExpando = false;\n\t\t\t}\n\t\t}\n\n\t\t// Null elements to avoid leaks in IE.\n\t\tdiv = null;\n\t})();\n\n\t/**\n  * Determines whether an object can have data\n  */\n\tjQuery.acceptData = function (elem) {\n\t\tvar noData = jQuery.noData[(elem.nodeName + \" \").toLowerCase()],\n\t\t    nodeType = +elem.nodeType || 1;\n\n\t\t// Do not set data on non-element DOM nodes because it will not be cleared (#8335).\n\t\treturn nodeType !== 1 && nodeType !== 9 ? false :\n\n\t\t// Nodes accept data unless otherwise specified; rejection can be conditional\n\t\t!noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n\t};\n\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t    rmultiDash = /([A-Z])/g;\n\n\tfunction dataAttr(elem, key, data) {\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif (data === undefined && elem.nodeType === 1) {\n\n\t\t\tvar name = \"data-\" + key.replace(rmultiDash, \"-$1\").toLowerCase();\n\n\t\t\tdata = elem.getAttribute(name);\n\n\t\t\tif (typeof data === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tdata = data === \"true\" ? true : data === \"false\" ? false : data === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tjQuery.data(elem, key, data);\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t// checks a cache object for emptiness\n\tfunction isEmptyDataObject(obj) {\n\t\tvar name;\n\t\tfor (name in obj) {\n\n\t\t\t// if the public data object is empty, the private is still empty\n\t\t\tif (name === \"data\" && jQuery.isEmptyObject(obj[name])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (name !== \"toJSON\") {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction internalData(elem, name, data, pvt /* Internal Use Only */) {\n\t\tif (!jQuery.acceptData(elem)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ret,\n\t\t    thisCache,\n\t\t    internalKey = jQuery.expando,\n\n\n\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t// can't GC object references properly across the DOM-JS boundary\n\t\tisNode = elem.nodeType,\n\n\n\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t// attached directly to the object so GC can occur automatically\n\t\tcache = isNode ? jQuery.cache : elem,\n\n\n\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\tid = isNode ? elem[internalKey] : elem[internalKey] && internalKey;\n\n\t\t// Avoid doing any more work than we need to when trying to get data on an\n\t\t// object that has no data at all\n\t\tif ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === \"string\") {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!id) {\n\t\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t\t// ends up in the global cache\n\t\t\tif (isNode) {\n\t\t\t\tid = elem[internalKey] = deletedIds.pop() || jQuery.guid++;\n\t\t\t} else {\n\t\t\t\tid = internalKey;\n\t\t\t}\n\t\t}\n\n\t\tif (!cache[id]) {\n\t\t\t// Avoid exposing jQuery metadata on plain JS objects when the object\n\t\t\t// is serialized using JSON.stringify\n\t\t\tcache[id] = isNode ? {} : { toJSON: jQuery.noop };\n\t\t}\n\n\t\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t\t// shallow copied over onto the existing cache\n\t\tif ((typeof name === \"undefined\" ? \"undefined\" : _typeof(name)) === \"object\" || typeof name === \"function\") {\n\t\t\tif (pvt) {\n\t\t\t\tcache[id] = jQuery.extend(cache[id], name);\n\t\t\t} else {\n\t\t\t\tcache[id].data = jQuery.extend(cache[id].data, name);\n\t\t\t}\n\t\t}\n\n\t\tthisCache = cache[id];\n\n\t\t// jQuery data() is stored in a separate object inside the object's internal data\n\t\t// cache in order to avoid key collisions between internal data and user-defined\n\t\t// data.\n\t\tif (!pvt) {\n\t\t\tif (!thisCache.data) {\n\t\t\t\tthisCache.data = {};\n\t\t\t}\n\n\t\t\tthisCache = thisCache.data;\n\t\t}\n\n\t\tif (data !== undefined) {\n\t\t\tthisCache[jQuery.camelCase(name)] = data;\n\t\t}\n\n\t\t// Check for both converted-to-camel and non-converted data property names\n\t\t// If a data property was specified\n\t\tif (typeof name === \"string\") {\n\n\t\t\t// First Try to find as-is property data\n\t\t\tret = thisCache[name];\n\n\t\t\t// Test for null|undefined property data\n\t\t\tif (ret == null) {\n\n\t\t\t\t// Try to find the camelCased property\n\t\t\t\tret = thisCache[jQuery.camelCase(name)];\n\t\t\t}\n\t\t} else {\n\t\t\tret = thisCache;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tfunction internalRemoveData(elem, name, pvt) {\n\t\tif (!jQuery.acceptData(elem)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar thisCache,\n\t\t    i,\n\t\t    isNode = elem.nodeType,\n\n\n\t\t// See jQuery.data for more information\n\t\tcache = isNode ? jQuery.cache : elem,\n\t\t    id = isNode ? elem[jQuery.expando] : jQuery.expando;\n\n\t\t// If there is already no cache entry for this object, there is no\n\t\t// purpose in continuing\n\t\tif (!cache[id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (name) {\n\n\t\t\tthisCache = pvt ? cache[id] : cache[id].data;\n\n\t\t\tif (thisCache) {\n\n\t\t\t\t// Support array or space separated string names for data keys\n\t\t\t\tif (!jQuery.isArray(name)) {\n\n\t\t\t\t\t// try the string as a key before any manipulation\n\t\t\t\t\tif (name in thisCache) {\n\t\t\t\t\t\tname = [name];\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\t\t\t\t\t\tname = jQuery.camelCase(name);\n\t\t\t\t\t\tif (name in thisCache) {\n\t\t\t\t\t\t\tname = [name];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tname = name.split(\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\t\tname = name.concat(jQuery.map(name, jQuery.camelCase));\n\t\t\t\t}\n\n\t\t\t\ti = name.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tdelete thisCache[name[i]];\n\t\t\t\t}\n\n\t\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t\t// and let the cache object itself get destroyed\n\t\t\t\tif (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// See jQuery.data for more information\n\t\tif (!pvt) {\n\t\t\tdelete cache[id].data;\n\n\t\t\t// Don't destroy the parent cache unless the internal data object\n\t\t\t// had been the only thing left in it\n\t\t\tif (!isEmptyDataObject(cache[id])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Destroy the cache\n\t\tif (isNode) {\n\t\t\tjQuery.cleanData([elem], true);\n\n\t\t\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\t\t\t/* jshint eqeqeq: false */\n\t\t} else if (support.deleteExpando || cache != cache.window) {\n\t\t\t/* jshint eqeqeq: true */\n\t\t\tdelete cache[id];\n\n\t\t\t// When all else fails, null\n\t\t} else {\n\t\t\tcache[id] = null;\n\t\t}\n\t}\n\n\tjQuery.extend({\n\t\tcache: {},\n\n\t\t// The following elements (space-suffixed to avoid Object.prototype collisions)\n\t\t// throw uncatchable exceptions if you attempt to set expando properties\n\t\tnoData: {\n\t\t\t\"applet \": true,\n\t\t\t\"embed \": true,\n\t\t\t// ...but Flash objects (which have this classid) *can* handle expandos\n\t\t\t\"object \": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n\t\t},\n\n\t\thasData: function hasData(elem) {\n\t\t\telem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];\n\t\t\treturn !!elem && !isEmptyDataObject(elem);\n\t\t},\n\n\t\tdata: function data(elem, name, _data) {\n\t\t\treturn internalData(elem, name, _data);\n\t\t},\n\n\t\tremoveData: function removeData(elem, name) {\n\t\t\treturn internalRemoveData(elem, name);\n\t\t},\n\n\t\t// For internal use only.\n\t\t_data: function _data(elem, name, data) {\n\t\t\treturn internalData(elem, name, data, true);\n\t\t},\n\n\t\t_removeData: function _removeData(elem, name) {\n\t\t\treturn internalRemoveData(elem, name, true);\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdata: function data(key, value) {\n\t\t\tvar i,\n\t\t\t    name,\n\t\t\t    data,\n\t\t\t    elem = this[0],\n\t\t\t    attrs = elem && elem.attributes;\n\n\t\t\t// Special expections of .data basically thwart jQuery.access,\n\t\t\t// so implement the relevant behavior ourselves\n\n\t\t\t// Gets all values\n\t\t\tif (key === undefined) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\tdata = jQuery.data(elem);\n\n\t\t\t\t\tif (elem.nodeType === 1 && !jQuery._data(elem, \"parsedAttrs\")) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tname = attrs[i].name;\n\n\t\t\t\t\t\t\tif (name.indexOf(\"data-\") === 0) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase(name.slice(5));\n\n\t\t\t\t\t\t\t\tdataAttr(elem, name, data[name]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjQuery._data(elem, \"parsedAttrs\", true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Sets multiple values\n\t\t\tif ((typeof key === \"undefined\" ? \"undefined\" : _typeof(key)) === \"object\") {\n\t\t\t\treturn this.each(function () {\n\t\t\t\t\tjQuery.data(this, key);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn arguments.length > 1 ?\n\n\t\t\t// Sets one value\n\t\t\tthis.each(function () {\n\t\t\t\tjQuery.data(this, key, value);\n\t\t\t}) :\n\n\t\t\t// Gets one value\n\t\t\t// Try to fetch any internally stored data first\n\t\t\telem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;\n\t\t},\n\n\t\tremoveData: function removeData(key) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.removeData(this, key);\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tqueue: function queue(elem, type, data) {\n\t\t\tvar queue;\n\n\t\t\tif (elem) {\n\t\t\t\ttype = (type || \"fx\") + \"queue\";\n\t\t\t\tqueue = jQuery._data(elem, type);\n\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif (data) {\n\t\t\t\t\tif (!queue || jQuery.isArray(data)) {\n\t\t\t\t\t\tqueue = jQuery._data(elem, type, jQuery.makeArray(data));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\n\t\tdequeue: function dequeue(elem, type) {\n\t\t\ttype = type || \"fx\";\n\n\t\t\tvar queue = jQuery.queue(elem, type),\n\t\t\t    startLength = queue.length,\n\t\t\t    fn = queue.shift(),\n\t\t\t    hooks = jQuery._queueHooks(elem, type),\n\t\t\t    next = function next() {\n\t\t\t\tjQuery.dequeue(elem, type);\n\t\t\t};\n\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif (fn === \"inprogress\") {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\n\t\t\tif (fn) {\n\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif (type === \"fx\") {\n\t\t\t\t\tqueue.unshift(\"inprogress\");\n\t\t\t\t}\n\n\t\t\t\t// clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call(elem, next, hooks);\n\t\t\t}\n\n\t\t\tif (!startLength && hooks) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\n\t\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t\t_queueHooks: function _queueHooks(elem, type) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn jQuery._data(elem, key) || jQuery._data(elem, key, {\n\t\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function () {\n\t\t\t\t\tjQuery._removeData(elem, type + \"queue\");\n\t\t\t\t\tjQuery._removeData(elem, key);\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tqueue: function queue(type, data) {\n\t\t\tvar setter = 2;\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\n\t\t\tif (arguments.length < setter) {\n\t\t\t\treturn jQuery.queue(this[0], type);\n\t\t\t}\n\n\t\t\treturn data === undefined ? this : this.each(function () {\n\t\t\t\tvar queue = jQuery.queue(this, type, data);\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks(this, type);\n\n\t\t\t\tif (type === \"fx\" && queue[0] !== \"inprogress\") {\n\t\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdequeue: function dequeue(type) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t});\n\t\t},\n\t\tclearQueue: function clearQueue(type) {\n\t\t\treturn this.queue(type || \"fx\", []);\n\t\t},\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function promise(type, obj) {\n\t\t\tvar tmp,\n\t\t\t    count = 1,\n\t\t\t    defer = jQuery.Deferred(),\n\t\t\t    elements = this,\n\t\t\t    i = this.length,\n\t\t\t    resolve = function resolve() {\n\t\t\t\tif (! --count) {\n\t\t\t\t\tdefer.resolveWith(elements, [elements]);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\n\t\t\twhile (i--) {\n\t\t\t\ttmp = jQuery._data(elements[i], type + \"queueHooks\");\n\t\t\t\tif (tmp && tmp.empty) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add(resolve);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise(obj);\n\t\t}\n\t});\n\tvar pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n\n\tvar cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n\n\tvar isHidden = function isHidden(elem, el) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css(elem, \"display\") === \"none\" || !jQuery.contains(elem.ownerDocument, elem);\n\t};\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {\n\t\tvar i = 0,\n\t\t    length = elems.length,\n\t\t    bulk = key == null;\n\n\t\t// Sets many values\n\t\tif (jQuery.type(key) === \"object\") {\n\t\t\tchainable = true;\n\t\t\tfor (i in key) {\n\t\t\t\tjQuery.access(elems, fn, i, key[i], true, emptyGet, raw);\n\t\t\t}\n\n\t\t\t// Sets one value\n\t\t} else if (value !== undefined) {\n\t\t\tchainable = true;\n\n\t\t\tif (!jQuery.isFunction(value)) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif (bulk) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif (raw) {\n\t\t\t\t\tfn.call(elems, value);\n\t\t\t\t\tfn = null;\n\n\t\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function fn(elem, key, value) {\n\t\t\t\t\t\treturn bulk.call(jQuery(elem), value);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fn) {\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tfn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ? elems :\n\n\t\t// Gets\n\t\tbulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;\n\t};\n\tvar rcheckableType = /^(?:checkbox|radio)$/i;\n\n\t(function () {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t    div = document.createElement(\"div\"),\n\t\t    input = document.createElement(\"input\");\n\n\t\t// Setup\n\t\tdiv.setAttribute(\"className\", \"t\");\n\t\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a>\";\n\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tsupport.leadingWhitespace = div.firstChild.nodeType === 3;\n\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\tsupport.tbody = !div.getElementsByTagName(\"tbody\").length;\n\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\tsupport.htmlSerialize = !!div.getElementsByTagName(\"link\").length;\n\n\t\t// Makes sure cloning an html5 element does not cause problems\n\t\t// Where outerHTML is undefined, this still works\n\t\tsupport.html5Clone = document.createElement(\"nav\").cloneNode(true).outerHTML !== \"<:nav></:nav>\";\n\n\t\t// Check if a disconnected checkbox will retain its checked\n\t\t// value of true after appended to the DOM (IE6/7)\n\t\tinput.type = \"checkbox\";\n\t\tinput.checked = true;\n\t\tfragment.appendChild(input);\n\t\tsupport.appendChecked = input.checked;\n\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\t// Support: IE6-IE11+\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n\n\t\t// #11217 - WebKit loses check when the name is after the checked attribute\n\t\tfragment.appendChild(div);\n\t\tdiv.innerHTML = \"<input type='radio' checked='checked' name='t'/>\";\n\n\t\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t\t// old WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n\n\t\t// Support: IE<9\n\t\t// Opera does not clone events (and typeof div.attachEvent === undefined).\n\t\t// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\t\tsupport.noCloneEvent = true;\n\t\tif (div.attachEvent) {\n\t\t\tdiv.attachEvent(\"onclick\", function () {\n\t\t\t\tsupport.noCloneEvent = false;\n\t\t\t});\n\n\t\t\tdiv.cloneNode(true).click();\n\t\t}\n\n\t\t// Execute the test only if not already executed in another module.\n\t\tif (support.deleteExpando == null) {\n\t\t\t// Support: IE<9\n\t\t\tsupport.deleteExpando = true;\n\t\t\ttry {\n\t\t\t\tdelete div.test;\n\t\t\t} catch (e) {\n\t\t\t\tsupport.deleteExpando = false;\n\t\t\t}\n\t\t}\n\n\t\t// Null elements to avoid leaks in IE.\n\t\tfragment = div = input = null;\n\t})();\n\n\t(function () {\n\t\tvar i,\n\t\t    eventName,\n\t\t    div = document.createElement(\"div\");\n\n\t\t// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)\n\t\tfor (i in { submit: true, change: true, focusin: true }) {\n\t\t\teventName = \"on\" + i;\n\n\t\t\tif (!(support[i + \"Bubbles\"] = eventName in window)) {\n\t\t\t\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n\t\t\t\tdiv.setAttribute(eventName, \"t\");\n\t\t\t\tsupport[i + \"Bubbles\"] = div.attributes[eventName].expando === false;\n\t\t\t}\n\t\t}\n\n\t\t// Null elements to avoid leaks in IE.\n\t\tdiv = null;\n\t})();\n\n\tvar rformElems = /^(?:input|select|textarea)$/i,\n\t    rkeyEvent = /^key/,\n\t    rmouseEvent = /^(?:mouse|contextmenu)|click/,\n\t    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\t    rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch (err) {}\n\t}\n\n\t/*\n  * Helper functions for managing events -- not part of the public interface.\n  * Props to Dean Edwards' addEvent library for many of the ideas.\n  */\n\tjQuery.event = {\n\n\t\tglobal: {},\n\n\t\tadd: function add(elem, types, handler, data, selector) {\n\t\t\tvar tmp,\n\t\t\t    events,\n\t\t\t    t,\n\t\t\t    handleObjIn,\n\t\t\t    special,\n\t\t\t    eventHandle,\n\t\t\t    handleObj,\n\t\t\t    handlers,\n\t\t\t    type,\n\t\t\t    namespaces,\n\t\t\t    origType,\n\t\t\t    elemData = jQuery._data(elem);\n\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif (!elemData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif (handler.handler) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif (!handler.guid) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif (!(events = elemData.events)) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif (!(eventHandle = elemData.handle)) {\n\t\t\t\teventHandle = elemData.handle = function (e) {\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn (typeof jQuery === \"undefined\" ? \"undefined\" : _typeof(jQuery)) !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;\n\t\t\t\t};\n\t\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\t\teventHandle.elem = elem;\n\t\t\t}\n\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = (types || \"\").match(rnotwhite) || [\"\"];\n\t\t\tt = types.length;\n\t\t\twhile (t--) {\n\t\t\t\ttmp = rtypenamespace.exec(types[t]) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = (tmp[2] || \"\").split(\".\").sort();\n\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif (!type) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = (selector ? special.delegateType : special.bindType) || type;\n\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend({\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test(selector),\n\t\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t\t}, handleObjIn);\n\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif (!(handlers = events[type])) {\n\t\t\t\t\thandlers = events[type] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\t\t\t\t\tif (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n\t\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\t\tif (elem.addEventListener) {\n\t\t\t\t\t\t\telem.addEventListener(type, eventHandle, false);\n\t\t\t\t\t\t} else if (elem.attachEvent) {\n\t\t\t\t\t\t\telem.attachEvent(\"on\" + type, eventHandle);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (special.add) {\n\t\t\t\t\tspecial.add.call(elem, handleObj);\n\n\t\t\t\t\tif (!handleObj.handler.guid) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif (selector) {\n\t\t\t\t\thandlers.splice(handlers.delegateCount++, 0, handleObj);\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push(handleObj);\n\t\t\t\t}\n\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[type] = true;\n\t\t\t}\n\n\t\t\t// Nullify elem to prevent memory leaks in IE\n\t\t\telem = null;\n\t\t},\n\n\t\t// Detach an event or set of events from an element\n\t\tremove: function remove(elem, types, handler, selector, mappedTypes) {\n\t\t\tvar j,\n\t\t\t    handleObj,\n\t\t\t    tmp,\n\t\t\t    origCount,\n\t\t\t    t,\n\t\t\t    events,\n\t\t\t    special,\n\t\t\t    handlers,\n\t\t\t    type,\n\t\t\t    namespaces,\n\t\t\t    origType,\n\t\t\t    elemData = jQuery.hasData(elem) && jQuery._data(elem);\n\n\t\t\tif (!elemData || !(events = elemData.events)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = (types || \"\").match(rnotwhite) || [\"\"];\n\t\t\tt = types.length;\n\t\t\twhile (t--) {\n\t\t\t\ttmp = rtypenamespace.exec(types[t]) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = (tmp[2] || \"\").split(\".\").sort();\n\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif (!type) {\n\t\t\t\t\tfor (type in events) {\n\t\t\t\t\t\tjQuery.event.remove(elem, type + types[t], handler, selector, true);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\t\t\t\ttype = (selector ? special.delegateType : special.bindType) || type;\n\t\t\t\thandlers = events[type] || [];\n\t\t\t\ttmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\");\n\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile (j--) {\n\t\t\t\t\thandleObj = handlers[j];\n\n\t\t\t\t\tif ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n\t\t\t\t\t\thandlers.splice(j, 1);\n\n\t\t\t\t\t\tif (handleObj.selector) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (special.remove) {\n\t\t\t\t\t\t\tspecial.remove.call(elem, handleObj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif (origCount && !handlers.length) {\n\t\t\t\t\tif (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n\t\t\t\t\t\tjQuery.removeEvent(elem, type, elemData.handle);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete events[type];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tif (jQuery.isEmptyObject(events)) {\n\t\t\t\tdelete elemData.handle;\n\n\t\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\t\t\t\t// so use it instead of delete\n\t\t\t\tjQuery._removeData(elem, \"events\");\n\t\t\t}\n\t\t},\n\n\t\ttrigger: function trigger(event, data, elem, onlyHandlers) {\n\t\t\tvar handle,\n\t\t\t    ontype,\n\t\t\t    cur,\n\t\t\t    bubbleType,\n\t\t\t    special,\n\t\t\t    tmp,\n\t\t\t    i,\n\t\t\t    eventPath = [elem || document],\n\t\t\t    type = hasOwn.call(event, \"type\") ? event.type : event,\n\t\t\t    namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n\n\t\t\tcur = tmp = elem = elem || document;\n\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif (elem.nodeType === 3 || elem.nodeType === 8) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif (rfocusMorph.test(type + jQuery.event.triggered)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (type.indexOf(\".\") >= 0) {\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split(\".\");\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === \"undefined\" ? \"undefined\" : _typeof(event)) === \"object\" && event);\n\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join(\".\");\n\t\t\tevent.namespace_re = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif (!event.target) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ? [event] : jQuery.makeArray(data, [event]);\n\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[type] || {};\n\t\t\tif (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif (!rfocusMorph.test(bubbleType + type)) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor (; cur; cur = cur.parentNode) {\n\t\t\t\t\teventPath.push(cur);\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif (tmp === (elem.ownerDocument || document)) {\n\t\t\t\t\teventPath.push(tmp.defaultView || tmp.parentWindow || window);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n\n\t\t\t\tevent.type = i > 1 ? bubbleType : special.bindType || type;\n\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = (jQuery._data(cur, \"events\") || {})[event.type] && jQuery._data(cur, \"handle\");\n\t\t\t\tif (handle) {\n\t\t\t\t\thandle.apply(cur, data);\n\t\t\t\t}\n\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ontype];\n\t\t\t\tif (handle && handle.apply && jQuery.acceptData(cur)) {\n\t\t\t\t\tevent.result = handle.apply(cur, data);\n\t\t\t\t\tif (event.result === false) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif (!onlyHandlers && !event.isDefaultPrevented()) {\n\n\t\t\t\tif ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {\n\n\t\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif (ontype && elem[type] && !jQuery.isWindow(elem)) {\n\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ontype];\n\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\telem[ontype] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\telem[type]();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n\t\t\t\t\t\t\t// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\telem[ontype] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\tdispatch: function dispatch(event) {\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix(event);\n\n\t\t\tvar i,\n\t\t\t    ret,\n\t\t\t    handleObj,\n\t\t\t    matched,\n\t\t\t    j,\n\t\t\t    handlerQueue = [],\n\t\t\t    args = _slice.call(arguments),\n\t\t\t    handlers = (jQuery._data(this, \"events\") || {})[event.type] || [],\n\t\t\t    special = jQuery.event.special[event.type] || {};\n\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[0] = event;\n\t\t\tevent.delegateTarget = this;\n\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif (special.preDispatch && special.preDispatch.call(this, event) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call(this, event, handlers);\n\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\t\tj = 0;\n\t\t\t\twhile ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {\n\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\t\tret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n\t\t\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t\t\tif ((event.result = ret) === false) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif (special.postDispatch) {\n\t\t\t\tspecial.postDispatch.call(this, event);\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\thandlers: function handlers(event, _handlers) {\n\t\t\tvar sel,\n\t\t\t    handleObj,\n\t\t\t    matches,\n\t\t\t    i,\n\t\t\t    handlerQueue = [],\n\t\t\t    delegateCount = _handlers.delegateCount,\n\t\t\t    cur = event.target;\n\n\t\t\t// Find delegate handlers\n\t\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\t\tif (delegateCount && cur.nodeType && (!event.button || event.type !== \"click\")) {\n\n\t\t\t\t/* jshint eqeqeq: false */\n\t\t\t\tfor (; cur != this; cur = cur.parentNode || this) {\n\t\t\t\t\t/* jshint eqeqeq: true */\n\n\t\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif (cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\")) {\n\t\t\t\t\t\tmatches = [];\n\t\t\t\t\t\tfor (i = 0; i < delegateCount; i++) {\n\t\t\t\t\t\t\thandleObj = _handlers[i];\n\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\t\tif (matches[sel] === undefined) {\n\t\t\t\t\t\t\t\tmatches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (matches[sel]) {\n\t\t\t\t\t\t\t\tmatches.push(handleObj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (matches.length) {\n\t\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tif (delegateCount < _handlers.length) {\n\t\t\t\thandlerQueue.push({ elem: this, handlers: _handlers.slice(delegateCount) });\n\t\t\t}\n\n\t\t\treturn handlerQueue;\n\t\t},\n\n\t\tfix: function fix(event) {\n\t\t\tif (event[jQuery.expando]) {\n\t\t\t\treturn event;\n\t\t\t}\n\n\t\t\t// Create a writable copy of the event object and normalize some properties\n\t\t\tvar i,\n\t\t\t    prop,\n\t\t\t    copy,\n\t\t\t    type = event.type,\n\t\t\t    originalEvent = event,\n\t\t\t    fixHook = this.fixHooks[type];\n\n\t\t\tif (!fixHook) {\n\t\t\t\tthis.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};\n\t\t\t}\n\t\t\tcopy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n\n\t\t\tevent = new jQuery.Event(originalEvent);\n\n\t\t\ti = copy.length;\n\t\t\twhile (i--) {\n\t\t\t\tprop = copy[i];\n\t\t\t\tevent[prop] = originalEvent[prop];\n\t\t\t}\n\n\t\t\t// Support: IE<9\n\t\t\t// Fix target property (#1925)\n\t\t\tif (!event.target) {\n\t\t\t\tevent.target = originalEvent.srcElement || document;\n\t\t\t}\n\n\t\t\t// Support: Chrome 23+, Safari?\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tif (event.target.nodeType === 3) {\n\t\t\t\tevent.target = event.target.parentNode;\n\t\t\t}\n\n\t\t\t// Support: IE<9\n\t\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\t\t\tevent.metaKey = !!event.metaKey;\n\n\t\t\treturn fixHook.filter ? fixHook.filter(event, originalEvent) : event;\n\t\t},\n\n\t\t// Includes some event props shared by KeyEvent and MouseEvent\n\t\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\t\tfixHooks: {},\n\n\t\tkeyHooks: {\n\t\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\t\tfilter: function filter(event, original) {\n\n\t\t\t\t// Add which for key events\n\t\t\t\tif (event.which == null) {\n\t\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t\t}\n\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\n\t\tmouseHooks: {\n\t\t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\t\tfilter: function filter(event, original) {\n\t\t\t\tvar body,\n\t\t\t\t    eventDoc,\n\t\t\t\t    doc,\n\t\t\t\t    button = original.button,\n\t\t\t\t    fromElement = original.fromElement;\n\n\t\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\t\tif (event.pageX == null && original.clientX != null) {\n\t\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\t\tevent.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n\t\t\t\t\tevent.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n\t\t\t\t}\n\n\t\t\t\t// Add relatedTarget, if necessary\n\t\t\t\tif (!event.relatedTarget && fromElement) {\n\t\t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n\t\t\t\t}\n\n\t\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t\t// Note: button is not normalized, so don't use it\n\t\t\t\tif (!event.which && button !== undefined) {\n\t\t\t\t\tevent.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n\t\t\t\t}\n\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\n\t\tspecial: {\n\t\t\tload: {\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this !== safeActiveElement() && this.focus) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t\t// If we error on focus to hidden element (#1486, #12518),\n\t\t\t\t\t\t\t// let .trigger() run the handlers\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this === safeActiveElement() && this.blur) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (jQuery.nodeName(this, \"input\") && this.type === \"checkbox\" && this.click) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function _default(event) {\n\t\t\t\t\treturn jQuery.nodeName(event.target, \"a\");\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function postDispatch(event) {\n\n\t\t\t\t\t// Even when returnValue equals to undefined Firefox will still show alert\n\t\t\t\t\tif (event.result !== undefined) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tsimulate: function simulate(type, elem, event, bubble) {\n\t\t\t// Piggyback on a donor event to simulate a different one.\n\t\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t\t// simulated event prevents default then we do the same on the donor.\n\t\t\tvar e = jQuery.extend(new jQuery.Event(), event, {\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t});\n\t\t\tif (bubble) {\n\t\t\t\tjQuery.event.trigger(e, null, elem);\n\t\t\t} else {\n\t\t\t\tjQuery.event.dispatch.call(elem, e);\n\t\t\t}\n\t\t\tif (e.isDefaultPrevented()) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {\n\t\tif (elem.removeEventListener) {\n\t\t\telem.removeEventListener(type, handle, false);\n\t\t}\n\t} : function (elem, type, handle) {\n\t\tvar name = \"on\" + type;\n\n\t\tif (elem.detachEvent) {\n\n\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8\n\t\t\t// detachEvent needed property on element, by name of that event, to properly expose it to GC\n\t\t\tif (_typeof(elem[name]) === strundefined) {\n\t\t\t\telem[name] = null;\n\t\t\t}\n\n\t\t\telem.detachEvent(name, handle);\n\t\t}\n\t};\n\n\tjQuery.Event = function (src, props) {\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif (!(this instanceof jQuery.Event)) {\n\t\t\treturn new jQuery.Event(src, props);\n\t\t}\n\n\t\t// Event object\n\t\tif (src && src.type) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && (\n\t\t\t// Support: IE < 9\n\t\t\tsrc.returnValue === false ||\n\t\t\t// Support: Android < 4.0\n\t\t\tsrc.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;\n\n\t\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\n\t\t// Put explicitly provided properties onto the event object\n\t\tif (props) {\n\t\t\tjQuery.extend(this, props);\n\t\t}\n\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t\t// Mark it as fixed\n\t\tthis[jQuery.expando] = true;\n\t};\n\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\n\t\tpreventDefault: function preventDefault() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\t\t\tif (!e) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If preventDefault exists, run it on the original event\n\t\t\tif (e.preventDefault) {\n\t\t\t\te.preventDefault();\n\n\t\t\t\t// Support: IE\n\t\t\t\t// Otherwise set the returnValue property of the original event to false\n\t\t\t} else {\n\t\t\t\te.returnValue = false;\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function stopPropagation() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isPropagationStopped = returnTrue;\n\t\t\tif (!e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If stopPropagation exists, run it on the original event\n\t\t\tif (e.stopPropagation) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\n\t\t\t// Support: IE\n\t\t\t// Set the cancelBubble property of the original event to true\n\t\t\te.cancelBubble = true;\n\t\t},\n\t\tstopImmediatePropagation: function stopImmediatePropagation() {\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\tjQuery.each({\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\"\n\t}, function (orig, fix) {\n\t\tjQuery.event.special[orig] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\n\t\t\thandle: function handle(event) {\n\t\t\t\tvar ret,\n\t\t\t\t    target = this,\n\t\t\t\t    related = event.relatedTarget,\n\t\t\t\t    handleObj = event.handleObj;\n\n\t\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif (!related || related !== target && !jQuery.contains(target, related)) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply(this, arguments);\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t});\n\n\t// IE submit delegation\n\tif (!support.submitBubbles) {\n\n\t\tjQuery.event.special.submit = {\n\t\t\tsetup: function setup() {\n\t\t\t\t// Only need this for delegated form submit events\n\t\t\t\tif (jQuery.nodeName(this, \"form\")) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\t\t\t\tjQuery.event.add(this, \"click._submit keypress._submit\", function (e) {\n\t\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\t\t\t\t\tvar elem = e.target,\n\t\t\t\t\t    form = jQuery.nodeName(elem, \"input\") || jQuery.nodeName(elem, \"button\") ? elem.form : undefined;\n\t\t\t\t\tif (form && !jQuery._data(form, \"submitBubbles\")) {\n\t\t\t\t\t\tjQuery.event.add(form, \"submit._submit\", function (event) {\n\t\t\t\t\t\t\tevent._submit_bubble = true;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tjQuery._data(form, \"submitBubbles\", true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// return undefined since we don't need an event listener\n\t\t\t},\n\n\t\t\tpostDispatch: function postDispatch(event) {\n\t\t\t\t// If form was submitted by the user, bubble the event up the tree\n\t\t\t\tif (event._submit_bubble) {\n\t\t\t\t\tdelete event._submit_bubble;\n\t\t\t\t\tif (this.parentNode && !event.isTrigger) {\n\t\t\t\t\t\tjQuery.event.simulate(\"submit\", this.parentNode, event, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tteardown: function teardown() {\n\t\t\t\t// Only need this for delegated form submit events\n\t\t\t\tif (jQuery.nodeName(this, \"form\")) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\t\t\t\tjQuery.event.remove(this, \"._submit\");\n\t\t\t}\n\t\t};\n\t}\n\n\t// IE change delegation and checkbox/radio fix\n\tif (!support.changeBubbles) {\n\n\t\tjQuery.event.special.change = {\n\n\t\t\tsetup: function setup() {\n\n\t\t\t\tif (rformElems.test(this.nodeName)) {\n\t\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\t\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\t\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\t\t\t\t\tif (this.type === \"checkbox\" || this.type === \"radio\") {\n\t\t\t\t\t\tjQuery.event.add(this, \"propertychange._change\", function (event) {\n\t\t\t\t\t\t\tif (event.originalEvent.propertyName === \"checked\") {\n\t\t\t\t\t\t\t\tthis._just_changed = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tjQuery.event.add(this, \"click._change\", function (event) {\n\t\t\t\t\t\t\tif (this._just_changed && !event.isTrigger) {\n\t\t\t\t\t\t\t\tthis._just_changed = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\t\t\t\t\t\t\tjQuery.event.simulate(\"change\", this, event, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\t\t\t\tjQuery.event.add(this, \"beforeactivate._change\", function (e) {\n\t\t\t\t\tvar elem = e.target;\n\n\t\t\t\t\tif (rformElems.test(elem.nodeName) && !jQuery._data(elem, \"changeBubbles\")) {\n\t\t\t\t\t\tjQuery.event.add(elem, \"change._change\", function (event) {\n\t\t\t\t\t\t\tif (this.parentNode && !event.isSimulated && !event.isTrigger) {\n\t\t\t\t\t\t\t\tjQuery.event.simulate(\"change\", this.parentNode, event, true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tjQuery._data(elem, \"changeBubbles\", true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\thandle: function handle(event) {\n\t\t\t\tvar elem = event.target;\n\n\t\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\t\t\t\tif (this !== elem || event.isSimulated || event.isTrigger || elem.type !== \"radio\" && elem.type !== \"checkbox\") {\n\t\t\t\t\treturn event.handleObj.handler.apply(this, arguments);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tteardown: function teardown() {\n\t\t\t\tjQuery.event.remove(this, \"._change\");\n\n\t\t\t\treturn !rformElems.test(this.nodeName);\n\t\t\t}\n\t\t};\n\t}\n\n\t// Create \"bubbling\" focus and blur events\n\tif (!support.focusinBubbles) {\n\t\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function (orig, fix) {\n\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function handler(event) {\n\t\t\t\tjQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);\n\t\t\t};\n\n\t\t\tjQuery.event.special[fix] = {\n\t\t\t\tsetup: function setup() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t    attaches = jQuery._data(doc, fix);\n\n\t\t\t\t\tif (!attaches) {\n\t\t\t\t\t\tdoc.addEventListener(orig, handler, true);\n\t\t\t\t\t}\n\t\t\t\t\tjQuery._data(doc, fix, (attaches || 0) + 1);\n\t\t\t\t},\n\t\t\t\tteardown: function teardown() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t    attaches = jQuery._data(doc, fix) - 1;\n\n\t\t\t\t\tif (!attaches) {\n\t\t\t\t\t\tdoc.removeEventListener(orig, handler, true);\n\t\t\t\t\t\tjQuery._removeData(doc, fix);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjQuery._data(doc, fix, attaches);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tjQuery.fn.extend({\n\n\t\ton: function on(types, selector, data, fn, /*INTERNAL*/one) {\n\t\t\tvar type, origFn;\n\n\t\t\t// Types can be a map of types/handlers\n\t\t\tif ((typeof types === \"undefined\" ? \"undefined\" : _typeof(types)) === \"object\") {\n\t\t\t\t// ( types-Object, selector, data )\n\t\t\t\tif (typeof selector !== \"string\") {\n\t\t\t\t\t// ( types-Object, data )\n\t\t\t\t\tdata = data || selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t\tfor (type in types) {\n\t\t\t\t\tthis.on(type, selector, data, types[type], one);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (data == null && fn == null) {\n\t\t\t\t// ( types, fn )\n\t\t\t\tfn = selector;\n\t\t\t\tdata = selector = undefined;\n\t\t\t} else if (fn == null) {\n\t\t\t\tif (typeof selector === \"string\") {\n\t\t\t\t\t// ( types, selector, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = undefined;\n\t\t\t\t} else {\n\t\t\t\t\t// ( types, data, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fn === false) {\n\t\t\t\tfn = returnFalse;\n\t\t\t} else if (!fn) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (one === 1) {\n\t\t\t\torigFn = fn;\n\t\t\t\tfn = function fn(event) {\n\t\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\t\tjQuery().off(event);\n\t\t\t\t\treturn origFn.apply(this, arguments);\n\t\t\t\t};\n\t\t\t\t// Use same guid so caller can remove using origFn\n\t\t\t\tfn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.add(this, types, fn, data, selector);\n\t\t\t});\n\t\t},\n\t\tone: function one(types, selector, data, fn) {\n\t\t\treturn this.on(types, selector, data, fn, 1);\n\t\t},\n\t\toff: function off(types, selector, fn) {\n\t\t\tvar handleObj, type;\n\t\t\tif (types && types.preventDefault && types.handleObj) {\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ((typeof types === \"undefined\" ? \"undefined\" : _typeof(types)) === \"object\") {\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor (type in types) {\n\t\t\t\t\tthis.off(type, selector, types[type]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (selector === false || typeof selector === \"function\") {\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif (fn === false) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.remove(this, types, fn, selector);\n\t\t\t});\n\t\t},\n\n\t\ttrigger: function trigger(type, data) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.trigger(type, data, this);\n\t\t\t});\n\t\t},\n\t\ttriggerHandler: function triggerHandler(type, data) {\n\t\t\tvar elem = this[0];\n\t\t\tif (elem) {\n\t\t\t\treturn jQuery.event.trigger(type, data, elem, true);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction createSafeFragment(document) {\n\t\tvar list = nodeNames.split(\"|\"),\n\t\t    safeFrag = document.createDocumentFragment();\n\n\t\tif (safeFrag.createElement) {\n\t\t\twhile (list.length) {\n\t\t\t\tsafeFrag.createElement(list.pop());\n\t\t\t}\n\t\t}\n\t\treturn safeFrag;\n\t}\n\n\tvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" + \"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n\t    rinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\t    rnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n\t    rleadingWhitespace = /^\\s+/,\n\t    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\t    rtagName = /<([\\w:]+)/,\n\t    rtbody = /<tbody/i,\n\t    rhtml = /<|&#?\\w+;/,\n\t    rnoInnerhtml = /<(?:script|style|link)/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t    rscriptType = /^$|\\/(?:java|ecma)script/i,\n\t    rscriptTypeMasked = /^true\\/(.*)/,\n\t    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\t\toption: [1, \"<select multiple='multiple'>\", \"</select>\"],\n\t\tlegend: [1, \"<fieldset>\", \"</fieldset>\"],\n\t\tarea: [1, \"<map>\", \"</map>\"],\n\t\tparam: [1, \"<object>\", \"</object>\"],\n\t\tthead: [1, \"<table>\", \"</table>\"],\n\t\ttr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n\t\tcol: [2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\"],\n\t\ttd: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n\n\t\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\t\t// unless wrapped in a div with non-breaking characters in front of it.\n\t\t_default: support.htmlSerialize ? [0, \"\", \"\"] : [1, \"X<div>\", \"</div>\"]\n\t},\n\t    safeFragment = createSafeFragment(document),\n\t    fragmentDiv = safeFragment.appendChild(document.createElement(\"div\"));\n\n\twrapMap.optgroup = wrapMap.option;\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\n\tfunction getAll(context, tag) {\n\t\tvar elems,\n\t\t    elem,\n\t\t    i = 0,\n\t\t    found = _typeof(context.getElementsByTagName) !== strundefined ? context.getElementsByTagName(tag || \"*\") : _typeof(context.querySelectorAll) !== strundefined ? context.querySelectorAll(tag || \"*\") : undefined;\n\n\t\tif (!found) {\n\t\t\tfor (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {\n\t\t\t\tif (!tag || jQuery.nodeName(elem, tag)) {\n\t\t\t\t\tfound.push(elem);\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.merge(found, getAll(elem, tag));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;\n\t}\n\n\t// Used in buildFragment, fixes the defaultChecked property\n\tfunction fixDefaultChecked(elem) {\n\t\tif (rcheckableType.test(elem.type)) {\n\t\t\telem.defaultChecked = elem.checked;\n\t\t}\n\t}\n\n\t// Support: IE<8\n\t// Manipulating tables requires a tbody\n\tfunction manipulationTarget(elem, content) {\n\t\treturn jQuery.nodeName(elem, \"table\") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\") ? elem.getElementsByTagName(\"tbody\")[0] || elem.appendChild(elem.ownerDocument.createElement(\"tbody\")) : elem;\n\t}\n\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript(elem) {\n\t\telem.type = (jQuery.find.attr(elem, \"type\") !== null) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript(elem) {\n\t\tvar match = rscriptTypeMasked.exec(elem.type);\n\t\tif (match) {\n\t\t\telem.type = match[1];\n\t\t} else {\n\t\t\telem.removeAttribute(\"type\");\n\t\t}\n\t\treturn elem;\n\t}\n\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval(elems, refElements) {\n\t\tvar elem,\n\t\t    i = 0;\n\t\tfor (; (elem = elems[i]) != null; i++) {\n\t\t\tjQuery._data(elem, \"globalEval\", !refElements || jQuery._data(refElements[i], \"globalEval\"));\n\t\t}\n\t}\n\n\tfunction cloneCopyEvent(src, dest) {\n\n\t\tif (dest.nodeType !== 1 || !jQuery.hasData(src)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar type,\n\t\t    i,\n\t\t    l,\n\t\t    oldData = jQuery._data(src),\n\t\t    curData = jQuery._data(dest, oldData),\n\t\t    events = oldData.events;\n\n\t\tif (events) {\n\t\t\tdelete curData.handle;\n\t\t\tcurData.events = {};\n\n\t\t\tfor (type in events) {\n\t\t\t\tfor (i = 0, l = events[type].length; i < l; i++) {\n\t\t\t\t\tjQuery.event.add(dest, type, events[type][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// make the cloned public data object a copy from the original\n\t\tif (curData.data) {\n\t\t\tcurData.data = jQuery.extend({}, curData.data);\n\t\t}\n\t}\n\n\tfunction fixCloneNodeIssues(src, dest) {\n\t\tvar nodeName, e, data;\n\n\t\t// We do not need to do anything for non-Elements\n\t\tif (dest.nodeType !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tnodeName = dest.nodeName.toLowerCase();\n\n\t\t// IE6-8 copies events bound via attachEvent when using cloneNode.\n\t\tif (!support.noCloneEvent && dest[jQuery.expando]) {\n\t\t\tdata = jQuery._data(dest);\n\n\t\t\tfor (e in data.events) {\n\t\t\t\tjQuery.removeEvent(dest, e, data.handle);\n\t\t\t}\n\n\t\t\t// Event data gets referenced instead of copied if the expando gets copied too\n\t\t\tdest.removeAttribute(jQuery.expando);\n\t\t}\n\n\t\t// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\t\tif (nodeName === \"script\" && dest.text !== src.text) {\n\t\t\tdisableScript(dest).text = src.text;\n\t\t\trestoreScript(dest);\n\n\t\t\t// IE6-10 improperly clones children of object elements using classid.\n\t\t\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\t\t} else if (nodeName === \"object\") {\n\t\t\tif (dest.parentNode) {\n\t\t\t\tdest.outerHTML = src.outerHTML;\n\t\t\t}\n\n\t\t\t// This path appears unavoidable for IE9. When cloning an object\n\t\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\t\t\t// If the src has innerHTML and the destination does not,\n\t\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\t\t\tif (support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {\n\t\t\t\tdest.innerHTML = src.innerHTML;\n\t\t\t}\n\t\t} else if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n\t\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t\t// a checked appearance if the defaultChecked value isn't also set\n\n\t\t\tdest.defaultChecked = dest.checked = src.checked;\n\n\t\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\t\tif (dest.value !== src.value) {\n\t\t\t\tdest.value = src.value;\n\t\t\t}\n\n\t\t\t// IE6-8 fails to return the selected option to the default selected\n\t\t\t// state when cloning options\n\t\t} else if (nodeName === \"option\") {\n\t\t\tdest.defaultSelected = dest.selected = src.defaultSelected;\n\n\t\t\t// IE6-8 fails to set the defaultValue to the correct value when\n\t\t\t// cloning other types of input fields\n\t\t} else if (nodeName === \"input\" || nodeName === \"textarea\") {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\n\tjQuery.extend({\n\t\tclone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n\t\t\tvar destElements,\n\t\t\t    node,\n\t\t\t    clone,\n\t\t\t    i,\n\t\t\t    srcElements,\n\t\t\t    inPage = jQuery.contains(elem.ownerDocument, elem);\n\n\t\t\tif (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test(\"<\" + elem.nodeName + \">\")) {\n\t\t\t\tclone = elem.cloneNode(true);\n\n\t\t\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\t\t\t} else {\n\t\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\t\t\t\tfragmentDiv.removeChild(clone = fragmentDiv.firstChild);\n\t\t\t}\n\n\t\t\tif ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n\n\t\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll(clone);\n\t\t\t\tsrcElements = getAll(elem);\n\n\t\t\t\t// Fix all IE cloning issues\n\t\t\t\tfor (i = 0; (node = srcElements[i]) != null; ++i) {\n\t\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\t\t\t\t\tif (destElements[i]) {\n\t\t\t\t\t\tfixCloneNodeIssues(node, destElements[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif (dataAndEvents) {\n\t\t\t\tif (deepDataAndEvents) {\n\t\t\t\t\tsrcElements = srcElements || getAll(elem);\n\t\t\t\t\tdestElements = destElements || getAll(clone);\n\n\t\t\t\t\tfor (i = 0; (node = srcElements[i]) != null; i++) {\n\t\t\t\t\t\tcloneCopyEvent(node, destElements[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent(elem, clone);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll(clone, \"script\");\n\t\t\tif (destElements.length > 0) {\n\t\t\t\tsetGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n\t\t\t}\n\n\t\t\tdestElements = srcElements = node = null;\n\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\n\t\tbuildFragment: function buildFragment(elems, context, scripts, selection) {\n\t\t\tvar j,\n\t\t\t    elem,\n\t\t\t    contains,\n\t\t\t    tmp,\n\t\t\t    tag,\n\t\t\t    tbody,\n\t\t\t    wrap,\n\t\t\t    l = elems.length,\n\n\n\t\t\t// Ensure a safe fragment\n\t\t\tsafe = createSafeFragment(context),\n\t\t\t    nodes = [],\n\t\t\t    i = 0;\n\n\t\t\tfor (; i < l; i++) {\n\t\t\t\telem = elems[i];\n\n\t\t\t\tif (elem || elem === 0) {\n\n\t\t\t\t\t// Add nodes directly\n\t\t\t\t\tif (jQuery.type(elem) === \"object\") {\n\t\t\t\t\t\tjQuery.merge(nodes, elem.nodeType ? [elem] : elem);\n\n\t\t\t\t\t\t// Convert non-html into a text node\n\t\t\t\t\t} else if (!rhtml.test(elem)) {\n\t\t\t\t\t\tnodes.push(context.createTextNode(elem));\n\n\t\t\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp = tmp || safe.appendChild(context.createElement(\"div\"));\n\n\t\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\t\ttag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n\t\t\t\t\t\twrap = wrapMap[tag] || wrapMap._default;\n\n\t\t\t\t\t\ttmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, \"<$1></$2>\") + wrap[2];\n\n\t\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\t\tj = wrap[0];\n\t\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Manually add leading whitespace removed by IE\n\t\t\t\t\t\tif (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {\n\t\t\t\t\t\t\tnodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\t\t\tif (!support.tbody) {\n\n\t\t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\t\t\telem = tag === \"table\" && !rtbody.test(elem) ? tmp.firstChild :\n\n\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\twrap[1] === \"<table>\" && !rtbody.test(elem) ? tmp : 0;\n\n\t\t\t\t\t\t\tj = elem && elem.childNodes.length;\n\t\t\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\t\t\tif (jQuery.nodeName(tbody = elem.childNodes[j], \"tbody\") && !tbody.childNodes.length) {\n\t\t\t\t\t\t\t\t\telem.removeChild(tbody);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tjQuery.merge(nodes, tmp.childNodes);\n\n\t\t\t\t\t\t// Fix #12392 for WebKit and IE > 9\n\t\t\t\t\t\ttmp.textContent = \"\";\n\n\t\t\t\t\t\t// Fix #12392 for oldIE\n\t\t\t\t\t\twhile (tmp.firstChild) {\n\t\t\t\t\t\t\ttmp.removeChild(tmp.firstChild);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remember the top-level container for proper cleanup\n\t\t\t\t\t\ttmp = safe.lastChild;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fix #11356: Clear elements from fragment\n\t\t\tif (tmp) {\n\t\t\t\tsafe.removeChild(tmp);\n\t\t\t}\n\n\t\t\t// Reset defaultChecked for any radios and checkboxes\n\t\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n\t\t\tif (!support.appendChecked) {\n\t\t\t\tjQuery.grep(getAll(nodes, \"input\"), fixDefaultChecked);\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\twhile (elem = nodes[i++]) {\n\n\t\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t\t// that element, do not do anything\n\t\t\t\tif (selection && jQuery.inArray(elem, selection) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcontains = jQuery.contains(elem.ownerDocument, elem);\n\n\t\t\t\t// Append to fragment\n\t\t\t\ttmp = getAll(safe.appendChild(elem), \"script\");\n\n\t\t\t\t// Preserve script evaluation history\n\t\t\t\tif (contains) {\n\t\t\t\t\tsetGlobalEval(tmp);\n\t\t\t\t}\n\n\t\t\t\t// Capture executables\n\t\t\t\tif (scripts) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile (elem = tmp[j++]) {\n\t\t\t\t\t\tif (rscriptType.test(elem.type || \"\")) {\n\t\t\t\t\t\t\tscripts.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp = null;\n\n\t\t\treturn safe;\n\t\t},\n\n\t\tcleanData: function cleanData(elems, /* internal */acceptData) {\n\t\t\tvar elem,\n\t\t\t    type,\n\t\t\t    id,\n\t\t\t    data,\n\t\t\t    i = 0,\n\t\t\t    internalKey = jQuery.expando,\n\t\t\t    cache = jQuery.cache,\n\t\t\t    deleteExpando = support.deleteExpando,\n\t\t\t    special = jQuery.event.special;\n\n\t\t\tfor (; (elem = elems[i]) != null; i++) {\n\t\t\t\tif (acceptData || jQuery.acceptData(elem)) {\n\n\t\t\t\t\tid = elem[internalKey];\n\t\t\t\t\tdata = id && cache[id];\n\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tif (data.events) {\n\t\t\t\t\t\t\tfor (type in data.events) {\n\t\t\t\t\t\t\t\tif (special[type]) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove(elem, type);\n\n\t\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent(elem, type, data.handle);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\t\t\t\t\t\tif (cache[id]) {\n\n\t\t\t\t\t\t\tdelete cache[id];\n\n\t\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes,\n\t\t\t\t\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\t\t\t\t\t\t\t// we must handle all of these cases\n\t\t\t\t\t\t\tif (deleteExpando) {\n\t\t\t\t\t\t\t\tdelete elem[internalKey];\n\t\t\t\t\t\t\t} else if (_typeof(elem.removeAttribute) !== strundefined) {\n\t\t\t\t\t\t\t\telem.removeAttribute(internalKey);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telem[internalKey] = null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdeletedIds.push(id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\ttext: function text(value) {\n\t\t\treturn access(this, function (value) {\n\t\t\t\treturn value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));\n\t\t\t}, null, value, arguments.length);\n\t\t},\n\n\t\tappend: function append() {\n\t\t\treturn this.domManip(arguments, function (elem) {\n\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\tvar target = manipulationTarget(this, elem);\n\t\t\t\t\ttarget.appendChild(elem);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tprepend: function prepend() {\n\t\t\treturn this.domManip(arguments, function (elem) {\n\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\tvar target = manipulationTarget(this, elem);\n\t\t\t\t\ttarget.insertBefore(elem, target.firstChild);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tbefore: function before() {\n\t\t\treturn this.domManip(arguments, function (elem) {\n\t\t\t\tif (this.parentNode) {\n\t\t\t\t\tthis.parentNode.insertBefore(elem, this);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tafter: function after() {\n\t\t\treturn this.domManip(arguments, function (elem) {\n\t\t\t\tif (this.parentNode) {\n\t\t\t\t\tthis.parentNode.insertBefore(elem, this.nextSibling);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tremove: function remove(selector, keepData /* Internal Use Only */) {\n\t\t\tvar elem,\n\t\t\t    elems = selector ? jQuery.filter(selector, this) : this,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = elems[i]) != null; i++) {\n\n\t\t\t\tif (!keepData && elem.nodeType === 1) {\n\t\t\t\t\tjQuery.cleanData(getAll(elem));\n\t\t\t\t}\n\n\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\tif (keepData && jQuery.contains(elem.ownerDocument, elem)) {\n\t\t\t\t\t\tsetGlobalEval(getAll(elem, \"script\"));\n\t\t\t\t\t}\n\t\t\t\t\telem.parentNode.removeChild(elem);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tempty: function empty() {\n\t\t\tvar elem,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = this[i]) != null; i++) {\n\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\tjQuery.cleanData(getAll(elem, false));\n\t\t\t\t}\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\twhile (elem.firstChild) {\n\t\t\t\t\telem.removeChild(elem.firstChild);\n\t\t\t\t}\n\n\t\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t\t// Support: IE<9\n\t\t\t\tif (elem.options && jQuery.nodeName(elem, \"select\")) {\n\t\t\t\t\telem.options.length = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tclone: function clone(dataAndEvents, deepDataAndEvents) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\t\treturn this.map(function () {\n\t\t\t\treturn jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n\t\t\t});\n\t\t},\n\n\t\thtml: function html(value) {\n\t\t\treturn access(this, function (value) {\n\t\t\t\tvar elem = this[0] || {},\n\t\t\t\t    i = 0,\n\t\t\t\t    l = this.length;\n\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\treturn elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, \"\") : undefined;\n\t\t\t\t}\n\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif (typeof value === \"string\" && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n\n\t\t\t\t\tvalue = value.replace(rxhtmlTag, \"<$1></$2>\");\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\telem = this[i] || {};\n\t\t\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\t\t\tjQuery.cleanData(getAll(elem, false));\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telem = 0;\n\n\t\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\n\t\t\t\tif (elem) {\n\t\t\t\t\tthis.empty().append(value);\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length);\n\t\t},\n\n\t\treplaceWith: function replaceWith() {\n\t\t\tvar arg = arguments[0];\n\n\t\t\t// Make the changes, replacing each context element with the new content\n\t\t\tthis.domManip(arguments, function (elem) {\n\t\t\t\targ = this.parentNode;\n\n\t\t\t\tjQuery.cleanData(getAll(this));\n\n\t\t\t\tif (arg) {\n\t\t\t\t\targ.replaceChild(elem, this);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t\t},\n\n\t\tdetach: function detach(selector) {\n\t\t\treturn this.remove(selector, true);\n\t\t},\n\n\t\tdomManip: function domManip(args, callback) {\n\n\t\t\t// Flatten any nested arrays\n\t\t\targs = concat.apply([], args);\n\n\t\t\tvar first,\n\t\t\t    node,\n\t\t\t    hasScripts,\n\t\t\t    scripts,\n\t\t\t    doc,\n\t\t\t    fragment,\n\t\t\t    i = 0,\n\t\t\t    l = this.length,\n\t\t\t    set = this,\n\t\t\t    iNoClone = l - 1,\n\t\t\t    value = args[0],\n\t\t\t    isFunction = jQuery.isFunction(value);\n\n\t\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\t\tif (isFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n\t\t\t\treturn this.each(function (index) {\n\t\t\t\t\tvar self = set.eq(index);\n\t\t\t\t\tif (isFunction) {\n\t\t\t\t\t\targs[0] = value.call(this, index, self.html());\n\t\t\t\t\t}\n\t\t\t\t\tself.domManip(args, callback);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (l) {\n\t\t\t\tfragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);\n\t\t\t\tfirst = fragment.firstChild;\n\n\t\t\t\tif (fragment.childNodes.length === 1) {\n\t\t\t\t\tfragment = first;\n\t\t\t\t}\n\n\t\t\t\tif (first) {\n\t\t\t\t\tscripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n\t\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\t\tif (i !== iNoClone) {\n\t\t\t\t\t\t\tnode = jQuery.clone(node, true, true);\n\n\t\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\t\tif (hasScripts) {\n\t\t\t\t\t\t\t\tjQuery.merge(scripts, getAll(node, \"script\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback.call(this[i], node, i);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hasScripts) {\n\t\t\t\t\t\tdoc = scripts[scripts.length - 1].ownerDocument;\n\n\t\t\t\t\t\t// Reenable scripts\n\t\t\t\t\t\tjQuery.map(scripts, restoreScript);\n\n\t\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\t\tfor (i = 0; i < hasScripts; i++) {\n\t\t\t\t\t\t\tnode = scripts[i];\n\t\t\t\t\t\t\tif (rscriptType.test(node.type || \"\") && !jQuery._data(node, \"globalEval\") && jQuery.contains(doc, node)) {\n\n\t\t\t\t\t\t\t\tif (node.src) {\n\t\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\t\tif (jQuery._evalUrl) {\n\t\t\t\t\t\t\t\t\t\tjQuery._evalUrl(node.src);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.globalEval((node.text || node.textContent || node.innerHTML || \"\").replace(rcleanScript, \"\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fix #11809: Avoid leaking memory\n\t\t\t\t\tfragment = first = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tjQuery.each({\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function (name, original) {\n\t\tjQuery.fn[name] = function (selector) {\n\t\t\tvar elems,\n\t\t\t    i = 0,\n\t\t\t    ret = [],\n\t\t\t    insert = jQuery(selector),\n\t\t\t    last = insert.length - 1;\n\n\t\t\tfor (; i <= last; i++) {\n\t\t\t\telems = i === last ? this : this.clone(true);\n\t\t\t\tjQuery(insert[i])[original](elems);\n\n\t\t\t\t// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\t\t\t\tpush.apply(ret, elems.get());\n\t\t\t}\n\n\t\t\treturn this.pushStack(ret);\n\t\t};\n\t});\n\n\tvar iframe,\n\t    elemdisplay = {};\n\n\t/**\n  * Retrieve the actual display of a element\n  * @param {String} name nodeName of the element\n  * @param {Object} doc Document object\n  */\n\t// Called only from within defaultDisplay\n\tfunction actualDisplay(name, doc) {\n\t\tvar elem = jQuery(doc.createElement(name)).appendTo(doc.body),\n\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle ?\n\n\t\t// Use of this method is a temporary fix (more like optmization) until something better comes along,\n\t\t// since it was removed from specification and supported only in FF\n\t\twindow.getDefaultComputedStyle(elem[0]).display : jQuery.css(elem[0], \"display\");\n\n\t\t// We don't have any data stored on the element,\n\t\t// so use \"detach\" method as fast way to get rid of the element\n\t\telem.detach();\n\n\t\treturn display;\n\t}\n\n\t/**\n  * Try to determine the default display value of an element\n  * @param {String} nodeName\n  */\n\tfunction defaultDisplay(nodeName) {\n\t\tvar doc = document,\n\t\t    display = elemdisplay[nodeName];\n\n\t\tif (!display) {\n\t\t\tdisplay = actualDisplay(nodeName, doc);\n\n\t\t\t// If the simple way fails, read from inside an iframe\n\t\t\tif (display === \"none\" || !display) {\n\n\t\t\t\t// Use the already-created iframe if possible\n\t\t\t\tiframe = (iframe || jQuery(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(doc.documentElement);\n\n\t\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\t\tdoc = (iframe[0].contentWindow || iframe[0].contentDocument).document;\n\n\t\t\t\t// Support: IE\n\t\t\t\tdoc.write();\n\t\t\t\tdoc.close();\n\n\t\t\t\tdisplay = actualDisplay(nodeName, doc);\n\t\t\t\tiframe.detach();\n\t\t\t}\n\n\t\t\t// Store the correct default display\n\t\t\telemdisplay[nodeName] = display;\n\t\t}\n\n\t\treturn display;\n\t}\n\n\t(function () {\n\t\tvar a,\n\t\t    shrinkWrapBlocksVal,\n\t\t    div = document.createElement(\"div\"),\n\t\t    divReset = \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;\" + \"display:block;padding:0;margin:0;border:0\";\n\n\t\t// Setup\n\t\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\t\ta = div.getElementsByTagName(\"a\")[0];\n\n\t\ta.style.cssText = \"float:left;opacity:.5\";\n\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\t// Use a regex to work around a WebKit issue. See #5145\n\t\tsupport.opacity = /^0.5/.test(a.style.opacity);\n\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tsupport.cssFloat = !!a.style.cssFloat;\n\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode(true).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t\t// Null elements to avoid leaks in IE.\n\t\ta = div = null;\n\n\t\tsupport.shrinkWrapBlocks = function () {\n\t\t\tvar body, container, div, containerStyles;\n\n\t\t\tif (shrinkWrapBlocksVal == null) {\n\t\t\t\tbody = document.getElementsByTagName(\"body\")[0];\n\t\t\t\tif (!body) {\n\t\t\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcontainerStyles = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px\";\n\t\t\t\tcontainer = document.createElement(\"div\");\n\t\t\t\tdiv = document.createElement(\"div\");\n\n\t\t\t\tbody.appendChild(container).appendChild(div);\n\n\t\t\t\t// Will be changed later if needed.\n\t\t\t\tshrinkWrapBlocksVal = false;\n\n\t\t\t\tif (_typeof(div.style.zoom) !== strundefined) {\n\t\t\t\t\t// Support: IE6\n\t\t\t\t\t// Check if elements with layout shrink-wrap their children\n\t\t\t\t\tdiv.style.cssText = divReset + \";width:1px;padding:1px;zoom:1\";\n\t\t\t\t\tdiv.innerHTML = \"<div></div>\";\n\t\t\t\t\tdiv.firstChild.style.width = \"5px\";\n\t\t\t\t\tshrinkWrapBlocksVal = div.offsetWidth !== 3;\n\t\t\t\t}\n\n\t\t\t\tbody.removeChild(container);\n\n\t\t\t\t// Null elements to avoid leaks in IE.\n\t\t\t\tbody = container = div = null;\n\t\t\t}\n\n\t\t\treturn shrinkWrapBlocksVal;\n\t\t};\n\t})();\n\tvar rmargin = /^margin/;\n\n\tvar rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n\tvar getStyles,\n\t    curCSS,\n\t    rposition = /^(top|right|bottom|left)$/;\n\n\tif (window.getComputedStyle) {\n\t\tgetStyles = function getStyles(elem) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n\t\t};\n\n\t\tcurCSS = function curCSS(elem, name, computed) {\n\t\t\tvar width,\n\t\t\t    minWidth,\n\t\t\t    maxWidth,\n\t\t\t    ret,\n\t\t\t    style = elem.style;\n\n\t\t\tcomputed = computed || getStyles(elem);\n\n\t\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\t\tret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;\n\n\t\t\tif (computed) {\n\n\t\t\t\tif (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\n\t\t\t\t\tret = jQuery.style(elem, name);\n\t\t\t\t}\n\n\t\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n\t\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\t\tif (rnumnonpx.test(ret) && rmargin.test(name)) {\n\n\t\t\t\t\t// Remember the original values\n\t\t\t\t\twidth = style.width;\n\t\t\t\t\tminWidth = style.minWidth;\n\t\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\t\tret = computed.width;\n\n\t\t\t\t\t// Revert the changed values\n\t\t\t\t\tstyle.width = width;\n\t\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Support: IE\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\treturn ret === undefined ? ret : ret + \"\";\n\t\t};\n\t} else if (document.documentElement.currentStyle) {\n\t\tgetStyles = function getStyles(elem) {\n\t\t\treturn elem.currentStyle;\n\t\t};\n\n\t\tcurCSS = function curCSS(elem, name, computed) {\n\t\t\tvar left,\n\t\t\t    rs,\n\t\t\t    rsLeft,\n\t\t\t    ret,\n\t\t\t    style = elem.style;\n\n\t\t\tcomputed = computed || getStyles(elem);\n\t\t\tret = computed ? computed[name] : undefined;\n\n\t\t\t// Avoid setting ret to empty string here\n\t\t\t// so we don't default to auto\n\t\t\tif (ret == null && style && style[name]) {\n\t\t\t\tret = style[name];\n\t\t\t}\n\n\t\t\t// From the awesome hack by Dean Edwards\n\t\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t\t// If we're not dealing with a regular pixel number\n\t\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t\t// but not position css attributes, as those are proportional to the parent element instead\n\t\t\t// and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\t\t\tif (rnumnonpx.test(ret) && !rposition.test(name)) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\tleft = style.left;\n\t\t\t\trs = elem.runtimeStyle;\n\t\t\t\trsLeft = rs && rs.left;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tif (rsLeft) {\n\t\t\t\t\trs.left = elem.currentStyle.left;\n\t\t\t\t}\n\t\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\t\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.left = left;\n\t\t\t\tif (rsLeft) {\n\t\t\t\t\trs.left = rsLeft;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Support: IE\n\t\t\t// IE returns zIndex value as an integer.\n\t\t\treturn ret === undefined ? ret : ret + \"\" || \"auto\";\n\t\t};\n\t}\n\n\tfunction addGetHookIf(conditionFn, hookFn) {\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function get() {\n\t\t\t\tvar condition = conditionFn();\n\n\t\t\t\tif (condition == null) {\n\t\t\t\t\t// The test was not ready at this point; screw the hook this time\n\t\t\t\t\t// but check again when needed next time.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (condition) {\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due to missing dependency),\n\t\t\t\t\t// remove it.\n\t\t\t\t\t// Since there are no other hooks for marginRight, remove the whole object.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\n\t\t\t\treturn (this.get = hookFn).apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}\n\n\t(function () {\n\t\tvar a,\n\t\t    reliableHiddenOffsetsVal,\n\t\t    boxSizingVal,\n\t\t    boxSizingReliableVal,\n\t\t    pixelPositionVal,\n\t\t    reliableMarginRightVal,\n\t\t    div = document.createElement(\"div\"),\n\t\t    containerStyles = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px\",\n\t\t    divReset = \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;\" + \"display:block;padding:0;margin:0;border:0\";\n\n\t\t// Setup\n\t\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\t\ta = div.getElementsByTagName(\"a\")[0];\n\n\t\ta.style.cssText = \"float:left;opacity:.5\";\n\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\t// Use a regex to work around a WebKit issue. See #5145\n\t\tsupport.opacity = /^0.5/.test(a.style.opacity);\n\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tsupport.cssFloat = !!a.style.cssFloat;\n\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode(true).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t\t// Null elements to avoid leaks in IE.\n\t\ta = div = null;\n\n\t\tjQuery.extend(support, {\n\t\t\treliableHiddenOffsets: function reliableHiddenOffsets() {\n\t\t\t\tif (reliableHiddenOffsetsVal != null) {\n\t\t\t\t\treturn reliableHiddenOffsetsVal;\n\t\t\t\t}\n\n\t\t\t\tvar container,\n\t\t\t\t    tds,\n\t\t\t\t    isSupported,\n\t\t\t\t    div = document.createElement(\"div\"),\n\t\t\t\t    body = document.getElementsByTagName(\"body\")[0];\n\n\t\t\t\tif (!body) {\n\t\t\t\t\t// Return for frameset docs that don't have a body\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Setup\n\t\t\t\tdiv.setAttribute(\"className\", \"t\");\n\t\t\t\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n\t\t\t\tcontainer = document.createElement(\"div\");\n\t\t\t\tcontainer.style.cssText = containerStyles;\n\n\t\t\t\tbody.appendChild(container).appendChild(div);\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t\t\t// to display:none and there are still other visible table cells in a\n\t\t\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t\t\t// determining if an element has been hidden directly using\n\t\t\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\t\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\t\t\t\ttds = div.getElementsByTagName(\"td\");\n\t\t\t\ttds[0].style.cssText = \"padding:0;margin:0;border:0;display:none\";\n\t\t\t\tisSupported = tds[0].offsetHeight === 0;\n\n\t\t\t\ttds[0].style.display = \"\";\n\t\t\t\ttds[1].style.display = \"none\";\n\n\t\t\t\t// Support: IE8\n\t\t\t\t// Check if empty table cells still have offsetWidth/Height\n\t\t\t\treliableHiddenOffsetsVal = isSupported && tds[0].offsetHeight === 0;\n\n\t\t\t\tbody.removeChild(container);\n\n\t\t\t\t// Null elements to avoid leaks in IE.\n\t\t\t\tdiv = body = null;\n\n\t\t\t\treturn reliableHiddenOffsetsVal;\n\t\t\t},\n\n\t\t\tboxSizing: function boxSizing() {\n\t\t\t\tif (boxSizingVal == null) {\n\t\t\t\t\tcomputeStyleTests();\n\t\t\t\t}\n\t\t\t\treturn boxSizingVal;\n\t\t\t},\n\n\t\t\tboxSizingReliable: function boxSizingReliable() {\n\t\t\t\tif (boxSizingReliableVal == null) {\n\t\t\t\t\tcomputeStyleTests();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\n\t\t\tpixelPosition: function pixelPosition() {\n\t\t\t\tif (pixelPositionVal == null) {\n\t\t\t\t\tcomputeStyleTests();\n\t\t\t\t}\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\n\t\t\treliableMarginRight: function reliableMarginRight() {\n\t\t\t\tvar body, container, div, marginDiv;\n\n\t\t\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\t\t\t\tif (reliableMarginRightVal == null && window.getComputedStyle) {\n\t\t\t\t\tbody = document.getElementsByTagName(\"body\")[0];\n\t\t\t\t\tif (!body) {\n\t\t\t\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer = document.createElement(\"div\");\n\t\t\t\t\tdiv = document.createElement(\"div\");\n\t\t\t\t\tcontainer.style.cssText = containerStyles;\n\n\t\t\t\t\tbody.appendChild(container).appendChild(div);\n\n\t\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t\t// Fails in WebKit before Feb 2011 nightlies\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\tmarginDiv = div.appendChild(document.createElement(\"div\"));\n\t\t\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\t\tdiv.style.width = \"1px\";\n\n\t\t\t\t\treliableMarginRightVal = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);\n\n\t\t\t\t\tbody.removeChild(container);\n\t\t\t\t}\n\n\t\t\t\treturn reliableMarginRightVal;\n\t\t\t}\n\t\t});\n\n\t\tfunction computeStyleTests() {\n\t\t\tvar container,\n\t\t\t    div,\n\t\t\t    body = document.getElementsByTagName(\"body\")[0];\n\n\t\t\tif (!body) {\n\t\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcontainer = document.createElement(\"div\");\n\t\t\tdiv = document.createElement(\"div\");\n\t\t\tcontainer.style.cssText = containerStyles;\n\n\t\t\tbody.appendChild(container).appendChild(div);\n\n\t\t\tdiv.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;\" + \"position:absolute;display:block;padding:1px;border:1px;width:4px;\" + \"margin-top:1%;top:1%\";\n\n\t\t\t// Workaround failing boxSizing test due to offsetWidth returning wrong value\n\t\t\t// with some non-1 values of body zoom, ticket #13543\n\t\t\tjQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {\n\t\t\t\tboxSizingVal = div.offsetWidth === 4;\n\t\t\t});\n\n\t\t\t// Will be changed later if needed.\n\t\t\tboxSizingReliableVal = true;\n\t\t\tpixelPositionVal = false;\n\t\t\treliableMarginRightVal = true;\n\n\t\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\t\t\tif (window.getComputedStyle) {\n\t\t\t\tpixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== \"1%\";\n\t\t\t\tboxSizingReliableVal = (window.getComputedStyle(div, null) || { width: \"4px\" }).width === \"4px\";\n\t\t\t}\n\n\t\t\tbody.removeChild(container);\n\n\t\t\t// Null elements to avoid leaks in IE.\n\t\t\tdiv = body = null;\n\t\t}\n\t})();\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\n\tjQuery.swap = function (elem, options, callback, args) {\n\t\tvar ret,\n\t\t    name,\n\t\t    old = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor (name in options) {\n\t\t\told[name] = elem.style[name];\n\t\t\telem.style[name] = options[name];\n\t\t}\n\n\t\tret = callback.apply(elem, args || []);\n\n\t\t// Revert the old values\n\t\tfor (name in options) {\n\t\t\telem.style[name] = old[name];\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tvar ralpha = /alpha\\([^)]*\\)/i,\n\t    ropacity = /opacity\\s*=\\s*([^)]*)/,\n\n\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t    rnumsplit = new RegExp(\"^(\" + pnum + \")(.*)$\", \"i\"),\n\t    rrelNum = new RegExp(\"^([+-])=(\" + pnum + \")\", \"i\"),\n\t    cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t    cssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\t    cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\n\n\t// return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName(style, name) {\n\n\t\t// shortcut for names that are not vendor prefixed\n\t\tif (name in style) {\n\t\t\treturn name;\n\t\t}\n\n\t\t// check for vendor prefixed names\n\t\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\t    origName = name,\n\t\t    i = cssPrefixes.length;\n\n\t\twhile (i--) {\n\t\t\tname = cssPrefixes[i] + capName;\n\t\t\tif (name in style) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\treturn origName;\n\t}\n\n\tfunction showHide(elements, show) {\n\t\tvar display,\n\t\t    elem,\n\t\t    hidden,\n\t\t    values = [],\n\t\t    index = 0,\n\t\t    length = elements.length;\n\n\t\tfor (; index < length; index++) {\n\t\t\telem = elements[index];\n\t\t\tif (!elem.style) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvalues[index] = jQuery._data(elem, \"olddisplay\");\n\t\t\tdisplay = elem.style.display;\n\t\t\tif (show) {\n\t\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t\t// being hidden by cascaded rules or not\n\t\t\t\tif (!values[index] && display === \"none\") {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\n\t\t\t\t// Set elements which have been overridden with display: none\n\t\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t\t// for such an element\n\t\t\t\tif (elem.style.display === \"\" && isHidden(elem)) {\n\t\t\t\t\tvalues[index] = jQuery._data(elem, \"olddisplay\", defaultDisplay(elem.nodeName));\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (!values[index]) {\n\t\t\t\t\thidden = isHidden(elem);\n\n\t\t\t\t\tif (display && display !== \"none\" || !hidden) {\n\t\t\t\t\t\tjQuery._data(elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the display of most of the elements in a second loop\n\t\t// to avoid the constant reflow\n\t\tfor (index = 0; index < length; index++) {\n\t\t\telem = elements[index];\n\t\t\tif (!elem.style) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!show || elem.style.display === \"none\" || elem.style.display === \"\") {\n\t\t\t\telem.style.display = show ? values[index] || \"\" : \"none\";\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\tfunction setPositiveNumber(elem, value, subtract) {\n\t\tvar matches = rnumsplit.exec(value);\n\t\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max(0, matches[1] - (subtract || 0)) + (matches[2] || \"px\") : value;\n\t}\n\n\tfunction augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n\t\tvar i = extra === (isBorderBox ? \"border\" : \"content\") ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\t\t    val = 0;\n\n\t\tfor (; i < 4; i += 2) {\n\t\t\t// both box models exclude margin, so add it if we want it\n\t\t\tif (extra === \"margin\") {\n\t\t\t\tval += jQuery.css(elem, extra + cssExpand[i], true, styles);\n\t\t\t}\n\n\t\t\tif (isBorderBox) {\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif (extra === \"content\") {\n\t\t\t\t\tval -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n\t\t\t\t}\n\n\t\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\t\tif (extra !== \"margin\") {\n\t\t\t\t\tval -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// at this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n\n\t\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\t\tif (extra !== \"padding\") {\n\t\t\t\t\tval += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn val;\n\t}\n\n\tfunction getWidthOrHeight(elem, name, extra) {\n\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar valueIsBorderBox = true,\n\t\t    val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\t    styles = getStyles(elem),\n\t\t    isBorderBox = support.boxSizing() && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\";\n\n\t\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif (val <= 0 || val == null) {\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS(elem, name, styles);\n\t\t\tif (val < 0 || val == null) {\n\t\t\t\tval = elem.style[name];\n\t\t\t}\n\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif (rnumnonpx.test(val)) {\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);\n\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat(val) || 0;\n\t\t}\n\n\t\t// use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles) + \"px\";\n\t}\n\n\tjQuery.extend({\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function get(elem, computed) {\n\t\t\t\t\tif (computed) {\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS(elem, \"opacity\");\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t// normalize float css property\n\t\t\t\"float\": support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t\t},\n\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function style(elem, name, value, extra) {\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret,\n\t\t\t    type,\n\t\t\t    hooks,\n\t\t\t    origName = jQuery.camelCase(name),\n\t\t\t    style = elem.style;\n\n\t\t\tname = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));\n\n\t\t\t// gets hook for the prefixed version\n\t\t\t// followed by the unprefixed version\n\t\t\thooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n\t\t\t// Check if we're setting a value\n\t\t\tif (value !== undefined) {\n\t\t\t\ttype = typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\n\n\t\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\t\tif (type === \"string\" && (ret = rrelNum.exec(value))) {\n\t\t\t\t\tvalue = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\n\t\t\t\t// Make sure that null and NaN values aren't set. See: #7116\n\t\t\t\tif (value == null || value !== value) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\t\tif (type === \"number\" && !jQuery.cssNumber[origName]) {\n\t\t\t\t\tvalue += \"px\";\n\t\t\t\t}\n\n\t\t\t\t// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n\t\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\t\tif (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n\t\t\t\t\tstyle[name] = \"inherit\";\n\t\t\t\t}\n\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n\n\t\t\t\t\t// Support: IE\n\t\t\t\t\t// Swallow errors from 'invalid' CSS values (#5509)\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Support: Chrome, Safari\n\t\t\t\t\t\t// Setting style to blank string required to delete \"style: x !important;\"\n\t\t\t\t\t\tstyle[name] = \"\";\n\t\t\t\t\t\tstyle[name] = value;\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[name];\n\t\t\t}\n\t\t},\n\n\t\tcss: function css(elem, name, extra, styles) {\n\t\t\tvar num,\n\t\t\t    val,\n\t\t\t    hooks,\n\t\t\t    origName = jQuery.camelCase(name);\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));\n\n\t\t\t// gets hook for the prefixed version\n\t\t\t// followed by the unprefixed version\n\t\t\thooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif (hooks && \"get\" in hooks) {\n\t\t\t\tval = hooks.get(elem, true, extra);\n\t\t\t}\n\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif (val === undefined) {\n\t\t\t\tval = curCSS(elem, name, styles);\n\t\t\t}\n\n\t\t\t//convert \"normal\" to computed value\n\t\t\tif (val === \"normal\" && name in cssNormalTransform) {\n\t\t\t\tval = cssNormalTransform[name];\n\t\t\t}\n\n\t\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\t\tif (extra === \"\" || extra) {\n\t\t\t\tnum = parseFloat(val);\n\t\t\t\treturn extra === true || jQuery.isNumeric(num) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t});\n\n\tjQuery.each([\"height\", \"width\"], function (i, name) {\n\t\tjQuery.cssHooks[name] = {\n\t\t\tget: function get(elem, computed, extra) {\n\t\t\t\tif (computed) {\n\t\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, \"display\")) ? jQuery.swap(elem, cssShow, function () {\n\t\t\t\t\t\treturn getWidthOrHeight(elem, name, extra);\n\t\t\t\t\t}) : getWidthOrHeight(elem, name, extra);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset: function set(elem, value, extra) {\n\t\t\t\tvar styles = extra && getStyles(elem);\n\t\t\t\treturn setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing() && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles) : 0);\n\t\t\t}\n\t\t};\n\t});\n\n\tif (!support.opacity) {\n\t\tjQuery.cssHooks.opacity = {\n\t\t\tget: function get(elem, computed) {\n\t\t\t\t// IE uses filters for opacity\n\t\t\t\treturn ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\") ? 0.01 * parseFloat(RegExp.$1) + \"\" : computed ? \"1\" : \"\";\n\t\t\t},\n\n\t\t\tset: function set(elem, value) {\n\t\t\t\tvar style = elem.style,\n\t\t\t\t    currentStyle = elem.currentStyle,\n\t\t\t\t    opacity = jQuery.isNumeric(value) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\t\t\t\t    filter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n\t\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t\t// Force it by setting the zoom level\n\t\t\t\tstyle.zoom = 1;\n\n\t\t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\t\t\t\t// if value === \"\", then remove inline opacity #12685\n\t\t\t\tif ((value >= 1 || value === \"\") && jQuery.trim(filter.replace(ralpha, \"\")) === \"\" && style.removeAttribute) {\n\n\t\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\t\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\t\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\t\t\t\t\tstyle.removeAttribute(\"filter\");\n\n\t\t\t\t\t// if there is no filter style applied in a css rule or unset inline opacity, we are done\n\t\t\t\t\tif (value === \"\" || currentStyle && !currentStyle.filter) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// otherwise, set new filter values\n\t\t\t\tstyle.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + \" \" + opacity;\n\t\t\t}\n\t\t};\n\t}\n\n\tjQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {\n\t\tif (computed) {\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\treturn jQuery.swap(elem, { \"display\": \"inline-block\" }, curCSS, [elem, \"marginRight\"]);\n\t\t}\n\t});\n\n\t// These hooks are used by animate to expand properties\n\tjQuery.each({\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function (prefix, suffix) {\n\t\tjQuery.cssHooks[prefix + suffix] = {\n\t\t\texpand: function expand(value) {\n\t\t\t\tvar i = 0,\n\t\t\t\t    expanded = {},\n\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n\t\t\t\tfor (; i < 4; i++) {\n\t\t\t\t\texpanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n\t\t\t\t}\n\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\n\t\tif (!rmargin.test(prefix)) {\n\t\t\tjQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tcss: function css(name, value) {\n\t\t\treturn access(this, function (elem, name, value) {\n\t\t\t\tvar styles,\n\t\t\t\t    len,\n\t\t\t\t    map = {},\n\t\t\t\t    i = 0;\n\n\t\t\t\tif (jQuery.isArray(name)) {\n\t\t\t\t\tstyles = getStyles(elem);\n\t\t\t\t\tlen = name.length;\n\n\t\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\t\tmap[name[i]] = jQuery.css(elem, name[i], false, styles);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\n\t\t\t\treturn value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n\t\t\t}, name, value, arguments.length > 1);\n\t\t},\n\t\tshow: function show() {\n\t\t\treturn showHide(this, true);\n\t\t},\n\t\thide: function hide() {\n\t\t\treturn showHide(this);\n\t\t},\n\t\ttoggle: function toggle(state) {\n\t\t\tif (typeof state === \"boolean\") {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tif (isHidden(this)) {\n\t\t\t\t\tjQuery(this).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery(this).hide();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\tfunction Tween(elem, options, prop, end, easing) {\n\t\treturn new Tween.prototype.init(elem, options, prop, end, easing);\n\t}\n\tjQuery.Tween = Tween;\n\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function init(elem, options, prop, end, easing, unit) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || \"swing\";\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n\t\t},\n\t\tcur: function cur() {\n\t\t\tvar hooks = Tween.propHooks[this.prop];\n\n\t\t\treturn hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n\t\t},\n\t\trun: function run(percent) {\n\t\t\tvar eased,\n\t\t\t    hooks = Tween.propHooks[this.prop];\n\n\t\t\tif (this.options.duration) {\n\t\t\t\tthis.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = (this.end - this.start) * eased + this.start;\n\n\t\t\tif (this.options.step) {\n\t\t\t\tthis.options.step.call(this.elem, this.now, this);\n\t\t\t}\n\n\t\t\tif (hooks && hooks.set) {\n\t\t\t\thooks.set(this);\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set(this);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tTween.prototype.init.prototype = Tween.prototype;\n\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function get(tween) {\n\t\t\t\tvar result;\n\n\t\t\t\tif (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {\n\t\t\t\t\treturn tween.elem[tween.prop];\n\t\t\t\t}\n\n\t\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\t\tresult = jQuery.css(tween.elem, tween.prop, \"\");\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function set(tween) {\n\t\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t\t// available and use plain properties where available\n\t\t\t\tif (jQuery.fx.step[tween.prop]) {\n\t\t\t\t\tjQuery.fx.step[tween.prop](tween);\n\t\t\t\t} else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n\t\t\t\t\tjQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[tween.prop] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Support: IE <=9\n\t// Panic based approach to setting things on disconnected nodes\n\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function set(tween) {\n\t\t\tif (tween.elem.nodeType && tween.elem.parentNode) {\n\t\t\t\ttween.elem[tween.prop] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.easing = {\n\t\tlinear: function linear(p) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function swing(p) {\n\t\t\treturn 0.5 - Math.cos(p * Math.PI) / 2;\n\t\t}\n\t};\n\n\tjQuery.fx = Tween.prototype.init;\n\n\t// Back Compat <1.8 extension point\n\tjQuery.fx.step = {};\n\n\tvar fxNow,\n\t    timerId,\n\t    rfxtypes = /^(?:toggle|show|hide)$/,\n\t    rfxnum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\"),\n\t    rrun = /queueHooks$/,\n\t    animationPrefilters = [defaultPrefilter],\n\t    tweeners = {\n\t\t\"*\": [function (prop, value) {\n\t\t\tvar tween = this.createTween(prop, value),\n\t\t\t    target = tween.cur(),\n\t\t\t    parts = rfxnum.exec(value),\n\t\t\t    unit = parts && parts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n\n\n\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\tstart = (jQuery.cssNumber[prop] || unit !== \"px\" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),\n\t\t\t    scale = 1,\n\t\t\t    maxIterations = 20;\n\n\t\t\tif (start && start[3] !== unit) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[3];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style(tween.elem, prop, start + unit);\n\n\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif (parts) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t}]\n\t};\n\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\tsetTimeout(function () {\n\t\t\tfxNow = undefined;\n\t\t});\n\t\treturn fxNow = jQuery.now();\n\t}\n\n\t// Generate parameters to create a standard animation\n\tfunction genFx(type, includeWidth) {\n\t\tvar which,\n\t\t    attrs = { height: type },\n\t\t    i = 0;\n\n\t\t// if we include width, step value is 1 to do all cssExpand values,\n\t\t// if we don't include width, step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor (; i < 4; i += 2 - includeWidth) {\n\t\t\twhich = cssExpand[i];\n\t\t\tattrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n\t\t}\n\n\t\tif (includeWidth) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\tfunction createTween(value, prop, animation) {\n\t\tvar tween,\n\t\t    collection = (tweeners[prop] || []).concat(tweeners[\"*\"]),\n\t\t    index = 0,\n\t\t    length = collection.length;\n\t\tfor (; index < length; index++) {\n\t\t\tif (tween = collection[index].call(animation, prop, value)) {\n\n\t\t\t\t// we're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defaultPrefilter(elem, props, opts) {\n\t\t/* jshint validthis: true */\n\t\tvar prop,\n\t\t    value,\n\t\t    toggle,\n\t\t    tween,\n\t\t    hooks,\n\t\t    oldfire,\n\t\t    display,\n\t\t    dDisplay,\n\t\t    anim = this,\n\t\t    orig = {},\n\t\t    style = elem.style,\n\t\t    hidden = elem.nodeType && isHidden(elem),\n\t\t    dataShow = jQuery._data(elem, \"fxshow\");\n\n\t\t// handle queue: false promises\n\t\tif (!opts.queue) {\n\t\t\thooks = jQuery._queueHooks(elem, \"fx\");\n\t\t\tif (hooks.unqueued == null) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function () {\n\t\t\t\t\tif (!hooks.unqueued) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\n\t\t\tanim.always(function () {\n\t\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t\t// before this completes\n\t\t\t\tanim.always(function () {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif (!jQuery.queue(elem, \"fx\").length) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// height/width overflow pass\n\t\tif (elem.nodeType === 1 && (\"height\" in props || \"width\" in props)) {\n\t\t\t// Make sure that nothing sneaks out\n\t\t\t// Record all 3 overflow attributes because IE does not\n\t\t\t// change the overflow attribute when overflowX and\n\t\t\t// overflowY are set to the same value\n\t\t\topts.overflow = [style.overflow, style.overflowX, style.overflowY];\n\n\t\t\t// Set display property to inline-block for height/width\n\t\t\t// animations on inline elements that are having width/height animated\n\t\t\tdisplay = jQuery.css(elem, \"display\");\n\t\t\tdDisplay = defaultDisplay(elem.nodeName);\n\t\t\tif (display === \"none\") {\n\t\t\t\tdisplay = dDisplay;\n\t\t\t}\n\t\t\tif (display === \"inline\" && jQuery.css(elem, \"float\") === \"none\") {\n\n\t\t\t\t// inline-level elements accept inline-block;\n\t\t\t\t// block-level elements need to be inline with layout\n\t\t\t\tif (!support.inlineBlockNeedsLayout || dDisplay === \"inline\") {\n\t\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t\t} else {\n\t\t\t\t\tstyle.zoom = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (opts.overflow) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tif (!support.shrinkWrapBlocks()) {\n\t\t\t\tanim.always(function () {\n\t\t\t\t\tstyle.overflow = opts.overflow[0];\n\t\t\t\t\tstyle.overflowX = opts.overflow[1];\n\t\t\t\t\tstyle.overflowY = opts.overflow[2];\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// show/hide pass\n\t\tfor (prop in props) {\n\t\t\tvalue = props[prop];\n\t\t\tif (rfxtypes.exec(value)) {\n\t\t\t\tdelete props[prop];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif (value === (hidden ? \"hide\" : \"show\")) {\n\n\t\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\t\tif (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n\t\t\t\t\t\thidden = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n\t\t\t}\n\t\t}\n\n\t\tif (!jQuery.isEmptyObject(orig)) {\n\t\t\tif (dataShow) {\n\t\t\t\tif (\"hidden\" in dataShow) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = jQuery._data(elem, \"fxshow\", {});\n\t\t\t}\n\n\t\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\t\tif (toggle) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\t\t\tif (hidden) {\n\t\t\t\tjQuery(elem).show();\n\t\t\t} else {\n\t\t\t\tanim.done(function () {\n\t\t\t\t\tjQuery(elem).hide();\n\t\t\t\t});\n\t\t\t}\n\t\t\tanim.done(function () {\n\t\t\t\tvar prop;\n\t\t\t\tjQuery._removeData(elem, \"fxshow\");\n\t\t\t\tfor (prop in orig) {\n\t\t\t\t\tjQuery.style(elem, prop, orig[prop]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor (prop in orig) {\n\t\t\t\ttween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n\t\t\t\tif (!(prop in dataShow)) {\n\t\t\t\t\tdataShow[prop] = tween.start;\n\t\t\t\t\tif (hidden) {\n\t\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction propFilter(props, specialEasing) {\n\t\tvar index, name, easing, value, hooks;\n\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor (index in props) {\n\t\t\tname = jQuery.camelCase(index);\n\t\t\teasing = specialEasing[name];\n\t\t\tvalue = props[index];\n\t\t\tif (jQuery.isArray(value)) {\n\t\t\t\teasing = value[1];\n\t\t\t\tvalue = props[index] = value[0];\n\t\t\t}\n\n\t\t\tif (index !== name) {\n\t\t\t\tprops[name] = value;\n\t\t\t\tdelete props[index];\n\t\t\t}\n\n\t\t\thooks = jQuery.cssHooks[name];\n\t\t\tif (hooks && \"expand\" in hooks) {\n\t\t\t\tvalue = hooks.expand(value);\n\t\t\t\tdelete props[name];\n\n\t\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\t\tfor (index in value) {\n\t\t\t\t\tif (!(index in props)) {\n\t\t\t\t\t\tprops[index] = value[index];\n\t\t\t\t\t\tspecialEasing[index] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[name] = easing;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction Animation(elem, properties, options) {\n\t\tvar result,\n\t\t    stopped,\n\t\t    index = 0,\n\t\t    length = animationPrefilters.length,\n\t\t    deferred = jQuery.Deferred().always(function () {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\t    tick = function tick() {\n\t\t\tif (stopped) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n\n\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t    percent = 1 - temp,\n\t\t\t    index = 0,\n\t\t\t    length = animation.tweens.length;\n\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tanimation.tweens[index].run(percent);\n\t\t\t}\n\n\t\t\tdeferred.notifyWith(elem, [animation, percent, remaining]);\n\n\t\t\tif (percent < 1 && length) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith(elem, [animation]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t    animation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend({}, properties),\n\t\t\topts: jQuery.extend(true, { specialEasing: {} }, options),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function createTween(prop, end) {\n\t\t\t\tvar tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n\t\t\t\tanimation.tweens.push(tween);\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function stop(gotoEnd) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t// otherwise we skip this part\n\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif (stopped) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor (; index < length; index++) {\n\t\t\t\t\tanimation.tweens[index].run(1);\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif (gotoEnd) {\n\t\t\t\t\tdeferred.resolveWith(elem, [animation, gotoEnd]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(elem, [animation, gotoEnd]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\t    props = animation.props;\n\n\t\tpropFilter(props, animation.opts.specialEasing);\n\n\t\tfor (; index < length; index++) {\n\t\t\tresult = animationPrefilters[index].call(animation, elem, props, animation.opts);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tjQuery.map(props, createTween, animation);\n\n\t\tif (jQuery.isFunction(animation.opts.start)) {\n\t\t\tanimation.opts.start.call(elem, animation);\n\t\t}\n\n\t\tjQuery.fx.timer(jQuery.extend(tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t}));\n\n\t\t// attach callbacks from options\n\t\treturn animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n\t}\n\n\tjQuery.Animation = jQuery.extend(Animation, {\n\t\ttweener: function tweener(props, callback) {\n\t\t\tif (jQuery.isFunction(props)) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [\"*\"];\n\t\t\t} else {\n\t\t\t\tprops = props.split(\" \");\n\t\t\t}\n\n\t\t\tvar prop,\n\t\t\t    index = 0,\n\t\t\t    length = props.length;\n\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tprop = props[index];\n\t\t\t\ttweeners[prop] = tweeners[prop] || [];\n\t\t\t\ttweeners[prop].unshift(callback);\n\t\t\t}\n\t\t},\n\n\t\tprefilter: function prefilter(callback, prepend) {\n\t\t\tif (prepend) {\n\t\t\t\tanimationPrefilters.unshift(callback);\n\t\t\t} else {\n\t\t\t\tanimationPrefilters.push(callback);\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.speed = function (speed, easing, fn) {\n\t\tvar opt = speed && (typeof speed === \"undefined\" ? \"undefined\" : _typeof(speed)) === \"object\" ? jQuery.extend({}, speed) : {\n\t\t\tcomplete: fn || !fn && easing || jQuery.isFunction(speed) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n\t\t};\n\n\t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;\n\n\t\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif (opt.queue == null || opt.queue === true) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\n\t\topt.complete = function () {\n\t\t\tif (jQuery.isFunction(opt.old)) {\n\t\t\t\topt.old.call(this);\n\t\t\t}\n\n\t\t\tif (opt.queue) {\n\t\t\t\tjQuery.dequeue(this, opt.queue);\n\t\t\t}\n\t\t};\n\n\t\treturn opt;\n\t};\n\n\tjQuery.fn.extend({\n\t\tfadeTo: function fadeTo(speed, to, easing, callback) {\n\n\t\t\t// show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter(isHidden).css(\"opacity\", 0).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback);\n\t\t},\n\t\tanimate: function animate(prop, speed, easing, callback) {\n\t\t\tvar empty = jQuery.isEmptyObject(prop),\n\t\t\t    optall = jQuery.speed(speed, easing, callback),\n\t\t\t    doAnimation = function doAnimation() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation(this, jQuery.extend({}, prop), optall);\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif (empty || jQuery._data(this, \"finish\")) {\n\t\t\t\t\tanim.stop(true);\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\t\treturn empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n\t\t},\n\t\tstop: function stop(type, clearQueue, gotoEnd) {\n\t\t\tvar stopQueue = function stopQueue(hooks) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop(gotoEnd);\n\t\t\t};\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif (clearQueue && type !== false) {\n\t\t\t\tthis.queue(type || \"fx\", []);\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t    index = type != null && type + \"queueHooks\",\n\t\t\t\t    timers = jQuery.timers,\n\t\t\t\t    data = jQuery._data(this);\n\n\t\t\t\tif (index) {\n\t\t\t\t\tif (data[index] && data[index].stop) {\n\t\t\t\t\t\tstopQueue(data[index]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (index in data) {\n\t\t\t\t\t\tif (data[index] && data[index].stop && rrun.test(index)) {\n\t\t\t\t\t\t\tstopQueue(data[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (index = timers.length; index--;) {\n\t\t\t\t\tif (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n\t\t\t\t\t\ttimers[index].anim.stop(gotoEnd);\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t\t// but only if they were gotoEnd\n\t\t\t\tif (dequeue || !gotoEnd) {\n\t\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tfinish: function finish(type) {\n\t\t\tif (type !== false) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tvar index,\n\t\t\t\t    data = jQuery._data(this),\n\t\t\t\t    queue = data[type + \"queue\"],\n\t\t\t\t    hooks = data[type + \"queueHooks\"],\n\t\t\t\t    timers = jQuery.timers,\n\t\t\t\t    length = queue ? queue.length : 0;\n\n\t\t\t\t// enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\n\t\t\t\t// empty the queue first\n\t\t\t\tjQuery.queue(this, type, []);\n\n\t\t\t\tif (hooks && hooks.stop) {\n\t\t\t\t\thooks.stop.call(this, true);\n\t\t\t\t}\n\n\t\t\t\t// look for any active animations, and finish them\n\t\t\t\tfor (index = timers.length; index--;) {\n\t\t\t\t\tif (timers[index].elem === this && timers[index].queue === type) {\n\t\t\t\t\t\ttimers[index].anim.stop(true);\n\t\t\t\t\t\ttimers.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// look for any animations in the old queue and finish them\n\t\t\t\tfor (index = 0; index < length; index++) {\n\t\t\t\t\tif (queue[index] && queue[index].finish) {\n\t\t\t\t\t\tqueue[index].finish.call(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n\t\tvar cssFn = jQuery.fn[name];\n\t\tjQuery.fn[name] = function (speed, easing, callback) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n\t\t};\n\t});\n\n\t// Generate shortcuts for custom animations\n\tjQuery.each({\n\t\tslideDown: genFx(\"show\"),\n\t\tslideUp: genFx(\"hide\"),\n\t\tslideToggle: genFx(\"toggle\"),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function (name, props) {\n\t\tjQuery.fn[name] = function (speed, easing, callback) {\n\t\t\treturn this.animate(props, speed, easing, callback);\n\t\t};\n\t});\n\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function () {\n\t\tvar timer,\n\t\t    timers = jQuery.timers,\n\t\t    i = 0;\n\n\t\tfxNow = jQuery.now();\n\n\t\tfor (; i < timers.length; i++) {\n\t\t\ttimer = timers[i];\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif (!timer() && timers[i] === timer) {\n\t\t\t\ttimers.splice(i--, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!timers.length) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\n\tjQuery.fx.timer = function (timer) {\n\t\tjQuery.timers.push(timer);\n\t\tif (timer()) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\n\tjQuery.fx.interval = 13;\n\n\tjQuery.fx.start = function () {\n\t\tif (!timerId) {\n\t\t\ttimerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);\n\t\t}\n\t};\n\n\tjQuery.fx.stop = function () {\n\t\tclearInterval(timerId);\n\t\ttimerId = null;\n\t};\n\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function (time, type) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue(type, function (next, hooks) {\n\t\t\tvar timeout = setTimeout(next, time);\n\t\t\thooks.stop = function () {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t};\n\t\t});\n\t};\n\n\t(function () {\n\t\tvar a,\n\t\t    input,\n\t\t    select,\n\t\t    opt,\n\t\t    div = document.createElement(\"div\");\n\n\t\t// Setup\n\t\tdiv.setAttribute(\"className\", \"t\");\n\t\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\t\ta = div.getElementsByTagName(\"a\")[0];\n\n\t\t// First batch of tests.\n\t\tselect = document.createElement(\"select\");\n\t\topt = select.appendChild(document.createElement(\"option\"));\n\t\tinput = div.getElementsByTagName(\"input\")[0];\n\n\t\ta.style.cssText = \"top:1px\";\n\n\t\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\t\tsupport.getSetAttribute = div.className !== \"t\";\n\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText instead)\n\t\tsupport.style = /top/.test(a.getAttribute(\"style\"));\n\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\tsupport.hrefNormalized = a.getAttribute(\"href\") === \"/a\";\n\n\t\t// Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\t\tsupport.checkOn = !!input.value;\n\n\t\t// Make sure that a selected-by-default option has a working selected property.\n\t\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\t\tsupport.optSelected = opt.selected;\n\n\t\t// Tests for enctype support on a form (#6743)\n\t\tsupport.enctype = !!document.createElement(\"form\").enctype;\n\n\t\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t\t// (WebKit marks them as disabled)\n\t\tselect.disabled = true;\n\t\tsupport.optDisabled = !opt.disabled;\n\n\t\t// Support: IE8 only\n\t\t// Check if we can trust getAttribute(\"value\")\n\t\tinput = document.createElement(\"input\");\n\t\tinput.setAttribute(\"value\", \"\");\n\t\tsupport.input = input.getAttribute(\"value\") === \"\";\n\n\t\t// Check if an input maintains its value after becoming a radio\n\t\tinput.value = \"t\";\n\t\tinput.setAttribute(\"type\", \"radio\");\n\t\tsupport.radioValue = input.value === \"t\";\n\n\t\t// Null elements to avoid leaks in IE.\n\t\ta = input = select = opt = div = null;\n\t})();\n\n\tvar rreturn = /\\r/g;\n\n\tjQuery.fn.extend({\n\t\tval: function val(value) {\n\t\t\tvar hooks,\n\t\t\t    ret,\n\t\t\t    isFunction,\n\t\t\t    elem = this[0];\n\n\t\t\tif (!arguments.length) {\n\t\t\t\tif (elem) {\n\t\t\t\t\thooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n\t\t\t\t\tif (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = elem.value;\n\n\t\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisFunction = jQuery.isFunction(value);\n\n\t\t\treturn this.each(function (i) {\n\t\t\t\tvar val;\n\n\t\t\t\tif (this.nodeType !== 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isFunction) {\n\t\t\t\t\tval = value.call(this, i, jQuery(this).val());\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif (val == null) {\n\t\t\t\t\tval = \"\";\n\t\t\t\t} else if (typeof val === \"number\") {\n\t\t\t\t\tval += \"\";\n\t\t\t\t} else if (jQuery.isArray(val)) {\n\t\t\t\t\tval = jQuery.map(val, function (value) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\thooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\tvar val = jQuery.find.attr(elem, \"value\");\n\t\t\t\t\treturn val != null ? val : jQuery.text(elem);\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\tvar value,\n\t\t\t\t\t    option,\n\t\t\t\t\t    options = elem.options,\n\t\t\t\t\t    index = elem.selectedIndex,\n\t\t\t\t\t    one = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\t    values = one ? null : [],\n\t\t\t\t\t    max = one ? index + 1 : options.length,\n\t\t\t\t\t    i = index < 0 ? max : one ? index : 0;\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor (; i < max; i++) {\n\t\t\t\t\t\toption = options[i];\n\n\t\t\t\t\t\t// oldIE doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ((option.selected || i === index) && (\n\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\tsupport.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\n\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery(option).val();\n\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif (one) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tvar optionSet,\n\t\t\t\t\t    option,\n\t\t\t\t\t    options = elem.options,\n\t\t\t\t\t    values = jQuery.makeArray(value),\n\t\t\t\t\t    i = options.length;\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\toption = options[i];\n\n\t\t\t\t\t\tif (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {\n\n\t\t\t\t\t\t\t// Support: IE6\n\t\t\t\t\t\t\t// When new option element is added to select box we need to\n\t\t\t\t\t\t\t// force reflow of newly added node in order to workaround delay\n\t\t\t\t\t\t\t// of initialization properties\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toption.selected = optionSet = true;\n\t\t\t\t\t\t\t} catch (_) {\n\n\t\t\t\t\t\t\t\t// Will be executed only in IE6\n\t\t\t\t\t\t\t\toption.scrollHeight;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toption.selected = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif (!optionSet) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn options;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Radios and checkboxes getter/setter\n\tjQuery.each([\"radio\", \"checkbox\"], function () {\n\t\tjQuery.valHooks[this] = {\n\t\t\tset: function set(elem, value) {\n\t\t\t\tif (jQuery.isArray(value)) {\n\t\t\t\t\treturn elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (!support.checkOn) {\n\t\t\tjQuery.valHooks[this].get = function (elem) {\n\t\t\t\t// Support: Webkit\n\t\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t});\n\n\tvar nodeHook,\n\t    boolHook,\n\t    attrHandle = jQuery.expr.attrHandle,\n\t    ruseDefault = /^(?:checked|selected)$/i,\n\t    getSetAttribute = support.getSetAttribute,\n\t    getSetInput = support.input;\n\n\tjQuery.fn.extend({\n\t\tattr: function attr(name, value) {\n\t\t\treturn access(this, jQuery.attr, name, value, arguments.length > 1);\n\t\t},\n\n\t\tremoveAttr: function removeAttr(name) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.removeAttr(this, name);\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tattr: function attr(elem, name, value) {\n\t\t\tvar hooks,\n\t\t\t    ret,\n\t\t\t    nType = elem.nodeType;\n\n\t\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\t\tif (!elem || nType === 3 || nType === 8 || nType === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif (_typeof(elem.getAttribute) === strundefined) {\n\t\t\t\treturn jQuery.prop(elem, name, value);\n\t\t\t}\n\n\t\t\t// All attributes are lowercase\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n\t\t\t\tname = name.toLowerCase();\n\t\t\t\thooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\tjQuery.removeAttr(elem, name);\n\t\t\t\t} else if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n\t\t\t\t\treturn ret;\n\t\t\t\t} else {\n\t\t\t\t\telem.setAttribute(name, value + \"\");\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t} else if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tret = jQuery.find.attr(elem, name);\n\n\t\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\t\treturn ret == null ? undefined : ret;\n\t\t\t}\n\t\t},\n\n\t\tremoveAttr: function removeAttr(elem, value) {\n\t\t\tvar name,\n\t\t\t    propName,\n\t\t\t    i = 0,\n\t\t\t    attrNames = value && value.match(rnotwhite);\n\n\t\t\tif (attrNames && elem.nodeType === 1) {\n\t\t\t\twhile (name = attrNames[i++]) {\n\t\t\t\t\tpropName = jQuery.propFix[name] || name;\n\n\t\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\t\tif (jQuery.expr.match.bool.test(name)) {\n\t\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\t\tif (getSetInput && getSetAttribute || !ruseDefault.test(name)) {\n\t\t\t\t\t\t\telem[propName] = false;\n\t\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t\t// Also clear defaultChecked/defaultSelected (if appropriate)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telem[jQuery.camelCase(\"default-\" + name)] = elem[propName] = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjQuery.attr(elem, name, \"\");\n\t\t\t\t\t}\n\n\t\t\t\t\telem.removeAttribute(getSetAttribute ? name : propName);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tif (!support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\")) {\n\t\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute(\"type\", value);\n\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Hook for boolean attributes\n\tboolHook = {\n\t\tset: function set(elem, value, name) {\n\t\t\tif (value === false) {\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr(elem, name);\n\t\t\t} else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {\n\t\t\t\t// IE<8 needs the *property* name\n\t\t\t\telem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);\n\n\t\t\t\t// Use defaultChecked and defaultSelected for oldIE\n\t\t\t} else {\n\t\t\t\telem[jQuery.camelCase(\"default-\" + name)] = elem[name] = true;\n\t\t\t}\n\n\t\t\treturn name;\n\t\t}\n\t};\n\n\t// Retrieve booleans specially\n\tjQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n\n\t\tvar getter = attrHandle[name] || jQuery.find.attr;\n\n\t\tattrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function (elem, name, isXML) {\n\t\t\tvar ret, handle;\n\t\t\tif (!isXML) {\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[name];\n\t\t\t\tattrHandle[name] = ret;\n\t\t\t\tret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;\n\t\t\t\tattrHandle[name] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t} : function (elem, name, isXML) {\n\t\t\tif (!isXML) {\n\t\t\t\treturn elem[jQuery.camelCase(\"default-\" + name)] ? name.toLowerCase() : null;\n\t\t\t}\n\t\t};\n\t});\n\n\t// fix oldIE attroperties\n\tif (!getSetInput || !getSetAttribute) {\n\t\tjQuery.attrHooks.value = {\n\t\t\tset: function set(elem, value, name) {\n\t\t\t\tif (jQuery.nodeName(elem, \"input\")) {\n\t\t\t\t\t// Does not return so that setAttribute is also used\n\t\t\t\t\telem.defaultValue = value;\n\t\t\t\t} else {\n\t\t\t\t\t// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n\t\t\t\t\treturn nodeHook && nodeHook.set(elem, value, name);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// IE6/7 do not support getting/setting some attributes with get/setAttribute\n\tif (!getSetAttribute) {\n\n\t\t// Use this for any attribute in IE6/7\n\t\t// This fixes almost every IE6/7 issue\n\t\tnodeHook = {\n\t\t\tset: function set(elem, value, name) {\n\t\t\t\t// Set the existing or create a new attribute node\n\t\t\t\tvar ret = elem.getAttributeNode(name);\n\t\t\t\tif (!ret) {\n\t\t\t\t\telem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));\n\t\t\t\t}\n\n\t\t\t\tret.value = value += \"\";\n\n\t\t\t\t// Break association with cloned elements by also using setAttribute (#9646)\n\t\t\t\tif (name === \"value\" || value === elem.getAttribute(name)) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Some attributes are constructed with empty-string values when not defined\n\t\tattrHandle.id = attrHandle.name = attrHandle.coords = function (elem, name, isXML) {\n\t\t\tvar ret;\n\t\t\tif (!isXML) {\n\t\t\t\treturn (ret = elem.getAttributeNode(name)) && ret.value !== \"\" ? ret.value : null;\n\t\t\t}\n\t\t};\n\n\t\t// Fixing value retrieval on a button requires this module\n\t\tjQuery.valHooks.button = {\n\t\t\tget: function get(elem, name) {\n\t\t\t\tvar ret = elem.getAttributeNode(name);\n\t\t\t\tif (ret && ret.specified) {\n\t\t\t\t\treturn ret.value;\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: nodeHook.set\n\t\t};\n\n\t\t// Set contenteditable to false on removals(#10429)\n\t\t// Setting to empty string throws an error as an invalid value\n\t\tjQuery.attrHooks.contenteditable = {\n\t\t\tset: function set(elem, value, name) {\n\t\t\t\tnodeHook.set(elem, value === \"\" ? false : value, name);\n\t\t\t}\n\t\t};\n\n\t\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\t\t// This is for removals\n\t\tjQuery.each([\"width\", \"height\"], function (i, name) {\n\t\t\tjQuery.attrHooks[name] = {\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tif (value === \"\") {\n\t\t\t\t\t\telem.setAttribute(name, \"auto\");\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tif (!support.style) {\n\t\tjQuery.attrHooks.style = {\n\t\t\tget: function get(elem) {\n\t\t\t\t// Return undefined in the case of empty string\n\t\t\t\t// Note: IE uppercases css property names, but if we were to .toLowerCase()\n\t\t\t\t// .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n\t\t\t\treturn elem.style.cssText || undefined;\n\t\t\t},\n\t\t\tset: function set(elem, value) {\n\t\t\t\treturn elem.style.cssText = value + \"\";\n\t\t\t}\n\t\t};\n\t}\n\n\tvar rfocusable = /^(?:input|select|textarea|button|object)$/i,\n\t    rclickable = /^(?:a|area)$/i;\n\n\tjQuery.fn.extend({\n\t\tprop: function prop(name, value) {\n\t\t\treturn access(this, jQuery.prop, name, value, arguments.length > 1);\n\t\t},\n\n\t\tremoveProp: function removeProp(name) {\n\t\t\tname = jQuery.propFix[name] || name;\n\t\t\treturn this.each(function () {\n\t\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\t\t\t\ttry {\n\t\t\t\t\tthis[name] = undefined;\n\t\t\t\t\tdelete this[name];\n\t\t\t\t} catch (e) {}\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t},\n\n\t\tprop: function prop(elem, name, value) {\n\t\t\tvar ret,\n\t\t\t    hooks,\n\t\t\t    notxml,\n\t\t\t    nType = elem.nodeType;\n\n\t\t\t// don't get/set properties on text, comment and attribute nodes\n\t\t\tif (!elem || nType === 3 || nType === 8 || nType === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc(elem);\n\n\t\t\tif (notxml) {\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[name] || name;\n\t\t\t\thooks = jQuery.propHooks[name];\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;\n\t\t\t} else {\n\t\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];\n\t\t\t}\n\t\t},\n\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\t\tvar tabindex = jQuery.find.attr(elem, \"tabindex\");\n\n\t\t\t\t\treturn tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Some attributes require a special call on IE\n\t// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\tif (!support.hrefNormalized) {\n\t\t// href/src property should get the full normalized URL (#10299/#12915)\n\t\tjQuery.each([\"href\", \"src\"], function (i, name) {\n\t\t\tjQuery.propHooks[name] = {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\treturn elem.getAttribute(name, 4);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t// Support: Safari, IE9+\n\t// mis-reports the default selected property of an option\n\t// Accessing the parent's selectedIndex property fixes it\n\tif (!support.optSelected) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function get(elem) {\n\t\t\t\tvar parent = elem.parentNode;\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\t\tif (parent.parentNode) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\n\tjQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n\t\tjQuery.propFix[this.toLowerCase()] = this;\n\t});\n\n\t// IE6/7 call enctype encoding\n\tif (!support.enctype) {\n\t\tjQuery.propFix.enctype = \"encoding\";\n\t}\n\n\tvar rclass = /[\\t\\r\\n\\f]/g;\n\n\tjQuery.fn.extend({\n\t\taddClass: function addClass(value) {\n\t\t\tvar classes,\n\t\t\t    elem,\n\t\t\t    cur,\n\t\t\t    clazz,\n\t\t\t    j,\n\t\t\t    finalValue,\n\t\t\t    i = 0,\n\t\t\t    len = this.length,\n\t\t\t    proceed = typeof value === \"string\" && value;\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (j) {\n\t\t\t\t\tjQuery(this).addClass(value.call(this, j, this.className));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (proceed) {\n\t\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\t\tclasses = (value || \"\").match(rnotwhite) || [];\n\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\telem = this[i];\n\t\t\t\t\tcur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \" \");\n\n\t\t\t\t\tif (cur) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (clazz = classes[j++]) {\n\t\t\t\t\t\t\tif (cur.indexOf(\" \" + clazz + \" \") < 0) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = jQuery.trim(cur);\n\t\t\t\t\t\tif (elem.className !== finalValue) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveClass: function removeClass(value) {\n\t\t\tvar classes,\n\t\t\t    elem,\n\t\t\t    cur,\n\t\t\t    clazz,\n\t\t\t    j,\n\t\t\t    finalValue,\n\t\t\t    i = 0,\n\t\t\t    len = this.length,\n\t\t\t    proceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (j) {\n\t\t\t\t\tjQuery(this).removeClass(value.call(this, j, this.className));\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (proceed) {\n\t\t\t\tclasses = (value || \"\").match(rnotwhite) || [];\n\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\telem = this[i];\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \"\");\n\n\t\t\t\t\tif (cur) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (clazz = classes[j++]) {\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile (cur.indexOf(\" \" + clazz + \" \") >= 0) {\n\t\t\t\t\t\t\t\tcur = cur.replace(\" \" + clazz + \" \", \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = value ? jQuery.trim(cur) : \"\";\n\t\t\t\t\t\tif (elem.className !== finalValue) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\ttoggleClass: function toggleClass(value, stateVal) {\n\t\t\tvar type = typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\n\n\t\t\tif (typeof stateVal === \"boolean\" && type === \"string\") {\n\t\t\t\treturn stateVal ? this.addClass(value) : this.removeClass(value);\n\t\t\t}\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tif (type === \"string\") {\n\t\t\t\t\t// toggle individual class names\n\t\t\t\t\tvar className,\n\t\t\t\t\t    i = 0,\n\t\t\t\t\t    self = jQuery(this),\n\t\t\t\t\t    classNames = value.match(rnotwhite) || [];\n\n\t\t\t\t\twhile (className = classNames[i++]) {\n\t\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\t\tif (self.hasClass(className)) {\n\t\t\t\t\t\t\tself.removeClass(className);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass(className);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if (type === strundefined || type === \"boolean\") {\n\t\t\t\t\tif (this.className) {\n\t\t\t\t\t\t// store className if set\n\t\t\t\t\t\tjQuery._data(this, \"__className__\", this.className);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data(this, \"__className__\") || \"\";\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thasClass: function hasClass(selector) {\n\t\t\tvar className = \" \" + selector + \" \",\n\t\t\t    i = 0,\n\t\t\t    l = this.length;\n\t\t\tfor (; i < l; i++) {\n\t\t\t\tif (this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf(className) >= 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t});\n\n\t// Return jQuery for attributes-only inclusion\n\n\n\tjQuery.each((\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function (i, name) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[name] = function (data, fn) {\n\t\t\treturn arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\t\thover: function hover(fnOver, fnOut) {\n\t\t\treturn this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n\t\t},\n\n\t\tbind: function bind(types, data, fn) {\n\t\t\treturn this.on(types, null, data, fn);\n\t\t},\n\t\tunbind: function unbind(types, fn) {\n\t\t\treturn this.off(types, null, fn);\n\t\t},\n\n\t\tdelegate: function delegate(selector, types, data, fn) {\n\t\t\treturn this.on(types, selector, data, fn);\n\t\t},\n\t\tundelegate: function undelegate(selector, types, fn) {\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n\t\t}\n\t});\n\n\tvar nonce = jQuery.now();\n\n\tvar rquery = /\\?/;\n\n\tvar rvalidtokens = /(,)|(\\[|{)|(}|])|\"(?:[^\"\\\\\\r\\n]|\\\\[\"\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*\"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;\n\n\tjQuery.parseJSON = function (data) {\n\t\t// Attempt to parse using the native JSON parser first\n\t\tif (window.JSON && window.JSON.parse) {\n\t\t\t// Support: Android 2.3\n\t\t\t// Workaround failure to string-cast null input\n\t\t\treturn window.JSON.parse(data + \"\");\n\t\t}\n\n\t\tvar requireNonComma,\n\t\t    depth = null,\n\t\t    str = jQuery.trim(data + \"\");\n\n\t\t// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains\n\t\t// after removing valid tokens\n\t\treturn str && !jQuery.trim(str.replace(rvalidtokens, function (token, comma, open, close) {\n\n\t\t\t// Force termination if we see a misplaced comma\n\t\t\tif (requireNonComma && comma) {\n\t\t\t\tdepth = 0;\n\t\t\t}\n\n\t\t\t// Perform no more replacements after returning to outermost depth\n\t\t\tif (depth === 0) {\n\t\t\t\treturn token;\n\t\t\t}\n\n\t\t\t// Commas must not follow \"[\", \"{\", or \",\"\n\t\t\trequireNonComma = open || comma;\n\n\t\t\t// Determine new depth\n\t\t\t// array/object open (\"[\" or \"{\"): depth += true - false (increment)\n\t\t\t// array/object close (\"]\" or \"}\"): depth += false - true (decrement)\n\t\t\t// other cases (\",\" or primitive): depth += true - true (numeric cast)\n\t\t\tdepth += !close - !open;\n\n\t\t\t// Remove this token\n\t\t\treturn \"\";\n\t\t})) ? Function(\"return \" + str)() : jQuery.error(\"Invalid JSON: \" + data);\n\t};\n\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function (data) {\n\t\tvar xml, tmp;\n\t\tif (!data || typeof data !== \"string\") {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tif (window.DOMParser) {\n\t\t\t\t// Standard\n\t\t\t\ttmp = new DOMParser();\n\t\t\t\txml = tmp.parseFromString(data, \"text/xml\");\n\t\t\t} else {\n\t\t\t\t// IE\n\t\t\t\txml = new ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\t\txml.async = \"false\";\n\t\t\t\txml.loadXML(data);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\txml = undefined;\n\t\t}\n\t\tif (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length) {\n\t\t\tjQuery.error(\"Invalid XML: \" + data);\n\t\t}\n\t\treturn xml;\n\t};\n\n\tvar\n\t// Document location\n\tajaxLocParts,\n\t    ajaxLocation,\n\t    rhash = /#.*$/,\n\t    rts = /([?&])_=[^&]*/,\n\t    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,\n\t    // IE leaves an \\r character at EOL\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t    rnoContent = /^(?:GET|HEAD)$/,\n\t    rprotocol = /^\\/\\//,\n\t    rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\n\t/* Prefilters\n  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n  * 2) These are called:\n  *    - BEFORE asking for a transport\n  *    - AFTER param serialization (s.data is a string if s.processData is true)\n  * 3) key is the dataType\n  * 4) the catchall symbol \"*\" can be used\n  * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n  */\n\tprefilters = {},\n\n\n\t/* Transports bindings\n  * 1) key is the dataType\n  * 2) the catchall symbol \"*\" can be used\n  * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n  */\n\ttransports = {},\n\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n\t// #8138, IE may throw an exception when accessing\n\t// a field from window.location if document.domain has been set\n\ttry {\n\t\tajaxLocation = location.href;\n\t} catch (e) {\n\t\t// Use the href attribute of an A element\n\t\t// since IE will modify it given document.location\n\t\tajaxLocation = document.createElement(\"a\");\n\t\tajaxLocation.href = \"\";\n\t\tajaxLocation = ajaxLocation.href;\n\t}\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];\n\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports(structure) {\n\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function (dataTypeExpression, func) {\n\n\t\t\tif (typeof dataTypeExpression !== \"string\") {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\n\t\t\tvar dataType,\n\t\t\t    i = 0,\n\t\t\t    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];\n\n\t\t\tif (jQuery.isFunction(func)) {\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile (dataType = dataTypes[i++]) {\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif (dataType.charAt(0) === \"+\") {\n\t\t\t\t\t\tdataType = dataType.slice(1) || \"*\";\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).unshift(func);\n\n\t\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).push(func);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n\n\t\tvar inspected = {},\n\t\t    seekingTransport = structure === transports;\n\n\t\tfunction inspect(dataType) {\n\t\t\tvar selected;\n\t\t\tinspected[dataType] = true;\n\t\t\tjQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\t\t\t\tif (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n\t\t\t\t\toptions.dataTypes.unshift(dataTypeOrTransport);\n\t\t\t\t\tinspect(dataTypeOrTransport);\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (seekingTransport) {\n\t\t\t\t\treturn !(selected = dataTypeOrTransport);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selected;\n\t\t}\n\n\t\treturn inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n\t}\n\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend(target, src) {\n\t\tvar deep,\n\t\t    key,\n\t\t    flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\t\tfor (key in src) {\n\t\t\tif (src[key] !== undefined) {\n\t\t\t\t(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n\t\t\t}\n\t\t}\n\t\tif (deep) {\n\t\t\tjQuery.extend(true, target, deep);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/* Handles responses to an ajax request:\n  * - finds the right dataType (mediates between content-type and expected dataType)\n  * - returns the corresponding response\n  */\n\tfunction ajaxHandleResponses(s, jqXHR, responses) {\n\t\tvar firstDataType,\n\t\t    ct,\n\t\t    finalDataType,\n\t\t    type,\n\t\t    contents = s.contents,\n\t\t    dataTypes = s.dataTypes;\n\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile (dataTypes[0] === \"*\") {\n\t\t\tdataTypes.shift();\n\t\t\tif (ct === undefined) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t\t}\n\t\t}\n\n\t\t// Check if we're dealing with a known content-type\n\t\tif (ct) {\n\t\t\tfor (type in contents) {\n\t\t\t\tif (contents[type] && contents[type].test(ct)) {\n\t\t\t\t\tdataTypes.unshift(type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif (dataTypes[0] in responses) {\n\t\t\tfinalDataType = dataTypes[0];\n\t\t} else {\n\t\t\t// Try convertible dataTypes\n\t\t\tfor (type in responses) {\n\t\t\t\tif (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!firstDataType) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif (finalDataType) {\n\t\t\tif (finalDataType !== dataTypes[0]) {\n\t\t\t\tdataTypes.unshift(finalDataType);\n\t\t\t}\n\t\t\treturn responses[finalDataType];\n\t\t}\n\t}\n\n\t/* Chain conversions given the request and the original response\n  * Also sets the responseXXX fields on the jqXHR instance\n  */\n\tfunction ajaxConvert(s, response, jqXHR, isSuccess) {\n\t\tvar conv2,\n\t\t    current,\n\t\t    conv,\n\t\t    tmp,\n\t\t    prev,\n\t\t    converters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t\t// Create converters map with lowercased keys\n\t\tif (dataTypes[1]) {\n\t\t\tfor (conv in s.converters) {\n\t\t\t\tconverters[conv.toLowerCase()] = s.converters[conv];\n\t\t\t}\n\t\t}\n\n\t\tcurrent = dataTypes.shift();\n\n\t\t// Convert to each sequential dataType\n\t\twhile (current) {\n\n\t\t\tif (s.responseFields[current]) {\n\t\t\t\tjqXHR[s.responseFields[current]] = response;\n\t\t\t}\n\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif (!prev && isSuccess && s.dataFilter) {\n\t\t\t\tresponse = s.dataFilter(response, s.dataType);\n\t\t\t}\n\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\n\t\t\tif (current) {\n\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif (current === \"*\") {\n\n\t\t\t\t\tcurrent = prev;\n\n\t\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if (prev !== \"*\" && prev !== current) {\n\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[prev + \" \" + current] || converters[\"* \" + current];\n\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif (!conv) {\n\t\t\t\t\t\tfor (conv2 in converters) {\n\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split(\" \");\n\t\t\t\t\t\t\tif (tmp[1] === current) {\n\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\t\t\t\t\t\t\t\tif (conv) {\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif (conv === true) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[conv2];\n\n\t\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if (converters[conv2] !== true) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[0];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift(tmp[1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif (conv !== true) {\n\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif (conv && s[\"throws\"]) {\n\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { state: \"success\", data: response };\n\t}\n\n\tjQuery.extend({\n\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\n\t\tajaxSettings: {\n\t\t\turl: ajaxLocation,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test(ajaxLocParts[1]),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t\t/*\n   timeout: 0,\n   data: null,\n   dataType: null,\n   username: null,\n   password: null,\n   cache: null,\n   throws: false,\n   traditional: false,\n   headers: {},\n   */\n\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\n\t\t\tcontents: {\n\t\t\t\txml: /xml/,\n\t\t\t\thtml: /html/,\n\t\t\t\tjson: /json/\n\t\t\t},\n\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function ajaxSetup(target, settings) {\n\t\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend(jQuery.ajaxSettings, target);\n\t\t},\n\n\t\tajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n\t\tajaxTransport: addToPrefiltersOrTransports(transports),\n\n\t\t// Main method\n\t\tajax: function ajax(url, options) {\n\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ((typeof url === \"undefined\" ? \"undefined\" : _typeof(url)) === \"object\") {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\n\t\t\tvar // Cross-domain detection vars\n\t\t\tparts,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers as string\n\t\t\tresponseHeadersString,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t    transport,\n\n\t\t\t// Response headers\n\t\t\tresponseHeaders,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup({}, options),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t    completeDeferred = jQuery.Callbacks(\"once memory\"),\n\n\t\t\t// Status-dependent callbacks\n\t\t\t_statusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\t    requestHeadersNames = {},\n\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function getResponseHeader(key) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif (state === 2) {\n\t\t\t\t\t\tif (!responseHeaders) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile (match = rheaders.exec(responseHeadersString)) {\n\t\t\t\t\t\t\t\tresponseHeaders[match[1].toLowerCase()] = match[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[key.toLowerCase()];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function getAllResponseHeaders() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function setRequestHeader(name, value) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif (!state) {\n\t\t\t\t\t\tname = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\n\t\t\t\t\t\trequestHeaders[name] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function overrideMimeType(type) {\n\t\t\t\t\tif (!state) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function statusCode(map) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif (map) {\n\t\t\t\t\t\tif (state < 2) {\n\t\t\t\t\t\t\tfor (code in map) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\t_statusCode[code] = [_statusCode[code], map[code]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always(map[jqXHR.status]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function abort(statusText) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif (transport) {\n\t\t\t\t\t\ttransport.abort(finalText);\n\t\t\t\t\t}\n\t\t\t\t\tdone(0, finalText);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise(jqXHR).complete = completeDeferred.add;\n\t\t\tjqXHR.success = jqXHR.done;\n\t\t\tjqXHR.error = jqXHR.fail;\n\n\t\t\t// Remove hash character (#7531: and string promotion)\n\t\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ((url || s.url || ajaxLocation) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\");\n\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().match(rnotwhite) || [\"\"];\n\n\t\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\t\tif (s.crossDomain == null) {\n\t\t\t\tparts = rurl.exec(s.url.toLowerCase());\n\t\t\t\ts.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? \"80\" : \"443\")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? \"80\" : \"443\"))));\n\t\t\t}\n\n\t\t\t// Convert data if not already a string\n\t\t\tif (s.data && s.processData && typeof s.data !== \"string\") {\n\t\t\t\ts.data = jQuery.param(s.data, s.traditional);\n\t\t\t}\n\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif (state === 2) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// We can fire global events as of now if asked to\n\t\t\tfireGlobals = s.global;\n\n\t\t\t// Watch for a new set of requests\n\t\t\tif (fireGlobals && jQuery.active++ === 0) {\n\t\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t\t}\n\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test(s.type);\n\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\tcacheURL = s.url;\n\n\t\t\t// More options handling for requests with no content\n\t\t\tif (!s.hasContent) {\n\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif (s.data) {\n\t\t\t\t\tcacheURL = s.url += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\n\t\t\t\t// Add anti-cache in url if needed\n\t\t\t\tif (s.cache === false) {\n\t\t\t\t\ts.url = rts.test(cacheURL) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace(rts, \"$1_=\" + nonce++) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif (s.ifModified) {\n\t\t\t\tif (jQuery.lastModified[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n\t\t\t\t}\n\t\t\t\tif (jQuery.etag[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n\t\t\t\tjqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n\t\t\t}\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]);\n\n\t\t\t// Check for headers option\n\t\t\tfor (i in s.headers) {\n\t\t\t\tjqXHR.setRequestHeader(i, s.headers[i]);\n\t\t\t}\n\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\n\t\t\t// aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\n\t\t\t// Install callbacks on deferreds\n\t\t\tfor (i in { success: 1, error: 1, complete: 1 }) {\n\t\t\t\tjqXHR[i](s[i]);\n\t\t\t}\n\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n\n\t\t\t// If no transport, we auto-abort\n\t\t\tif (!transport) {\n\t\t\t\tdone(-1, \"No Transport\");\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\n\t\t\t\t// Send global event\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n\t\t\t\t}\n\t\t\t\t// Timeout\n\t\t\t\tif (s.async && s.timeout > 0) {\n\t\t\t\t\ttimeoutTimer = setTimeout(function () {\n\t\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t\t}, s.timeout);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\ttransport.send(requestHeaders, done);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Propagate exception as error if not done\n\t\t\t\t\tif (state < 2) {\n\t\t\t\t\t\tdone(-1, e);\n\t\t\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done(status, nativeStatusText, responses, headers) {\n\t\t\t\tvar isSuccess,\n\t\t\t\t    success,\n\t\t\t\t    error,\n\t\t\t\t    response,\n\t\t\t\t    modified,\n\t\t\t\t    statusText = nativeStatusText;\n\n\t\t\t\t// Called once\n\t\t\t\tif (state === 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// State is \"done\" now\n\t\t\t\tstate = 2;\n\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif (timeoutTimer) {\n\t\t\t\t\tclearTimeout(timeoutTimer);\n\t\t\t\t}\n\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t\t// Get response data\n\t\t\t\tif (responses) {\n\t\t\t\t\tresponse = ajaxHandleResponses(s, jqXHR, responses);\n\t\t\t\t}\n\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert(s, response, jqXHR, isSuccess);\n\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif (isSuccess) {\n\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif (s.ifModified) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.lastModified[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.etag[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if no content\n\t\t\t\t\tif (status === 204 || s.type === \"HEAD\") {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if (status === 304) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// We extract error from statusText\n\t\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif (status || !statusText) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif (status < 0) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = (nativeStatusText || statusText) + \"\";\n\n\t\t\t\t// Success/Error\n\t\t\t\tif (isSuccess) {\n\t\t\t\t\tdeferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n\t\t\t\t}\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode(_statusCode);\n\t\t\t\t_statusCode = undefined;\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n\t\t\t\t}\n\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]);\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif (! --jQuery.active) {\n\t\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jqXHR;\n\t\t},\n\n\t\tgetJSON: function getJSON(url, data, callback) {\n\t\t\treturn jQuery.get(url, data, callback, \"json\");\n\t\t},\n\n\t\tgetScript: function getScript(url, callback) {\n\t\t\treturn jQuery.get(url, undefined, callback, \"script\");\n\t\t}\n\t});\n\n\tjQuery.each([\"get\", \"post\"], function (i, method) {\n\t\tjQuery[method] = function (url, data, callback, type) {\n\t\t\t// shift arguments if data argument was omitted\n\t\t\tif (jQuery.isFunction(data)) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\n\t\t\treturn jQuery.ajax({\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t});\n\t\t};\n\t});\n\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n\t\tjQuery.fn[type] = function (fn) {\n\t\t\treturn this.on(type, fn);\n\t\t};\n\t});\n\n\tjQuery._evalUrl = function (url) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t};\n\n\tjQuery.fn.extend({\n\t\twrapAll: function wrapAll(html) {\n\t\t\tif (jQuery.isFunction(html)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).wrapAll(html.call(this, i));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (this[0]) {\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\tvar wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n\t\t\t\tif (this[0].parentNode) {\n\t\t\t\t\twrap.insertBefore(this[0]);\n\t\t\t\t}\n\n\t\t\t\twrap.map(function () {\n\t\t\t\t\tvar elem = this;\n\n\t\t\t\t\twhile (elem.firstChild && elem.firstChild.nodeType === 1) {\n\t\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem;\n\t\t\t\t}).append(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\twrapInner: function wrapInner(html) {\n\t\t\tif (jQuery.isFunction(html)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).wrapInner(html.call(this, i));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar self = jQuery(this),\n\t\t\t\t    contents = self.contents();\n\n\t\t\t\tif (contents.length) {\n\t\t\t\t\tcontents.wrapAll(html);\n\t\t\t\t} else {\n\t\t\t\t\tself.append(html);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\twrap: function wrap(html) {\n\t\t\tvar isFunction = jQuery.isFunction(html);\n\n\t\t\treturn this.each(function (i) {\n\t\t\t\tjQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n\t\t\t});\n\t\t},\n\n\t\tunwrap: function unwrap() {\n\t\t\treturn this.parent().each(function () {\n\t\t\t\tif (!jQuery.nodeName(this, \"body\")) {\n\t\t\t\t\tjQuery(this).replaceWith(this.childNodes);\n\t\t\t\t}\n\t\t\t}).end();\n\t\t}\n\t});\n\n\tjQuery.expr.filters.hidden = function (elem) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && (elem.style && elem.style.display || jQuery.css(elem, \"display\")) === \"none\";\n\t};\n\n\tjQuery.expr.filters.visible = function (elem) {\n\t\treturn !jQuery.expr.filters.hidden(elem);\n\t};\n\n\tvar r20 = /%20/g,\n\t    rbracket = /\\[\\]$/,\n\t    rCRLF = /\\r?\\n/g,\n\t    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t    rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n\tfunction buildParams(prefix, obj, traditional, add) {\n\t\tvar name;\n\n\t\tif (jQuery.isArray(obj)) {\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each(obj, function (i, v) {\n\t\t\t\tif (traditional || rbracket.test(prefix)) {\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd(prefix, v);\n\t\t\t\t} else {\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams(prefix + \"[\" + ((typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" ? i : \"\") + \"]\", v, traditional, add);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!traditional && jQuery.type(obj) === \"object\") {\n\t\t\t// Serialize object item.\n\t\t\tfor (name in obj) {\n\t\t\t\tbuildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n\t\t\t}\n\t\t} else {\n\t\t\t// Serialize scalar item.\n\t\t\tadd(prefix, obj);\n\t\t}\n\t}\n\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function (a, traditional) {\n\t\tvar prefix,\n\t\t    s = [],\n\t\t    add = function add(key, value) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction(value) ? value() : value == null ? \"\" : value;\n\t\t\ts[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n\t\t};\n\n\t\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\t\tif (traditional === undefined) {\n\t\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t\t}\n\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each(a, function () {\n\t\t\t\tadd(this.name, this.value);\n\t\t\t});\n\t\t} else {\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor (prefix in a) {\n\t\t\t\tbuildParams(prefix, a[prefix], traditional, add);\n\t\t\t}\n\t\t}\n\n\t\t// Return the resulting serialization\n\t\treturn s.join(\"&\").replace(r20, \"+\");\n\t};\n\n\tjQuery.fn.extend({\n\t\tserialize: function serialize() {\n\t\t\treturn jQuery.param(this.serializeArray());\n\t\t},\n\t\tserializeArray: function serializeArray() {\n\t\t\treturn this.map(function () {\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop(this, \"elements\");\n\t\t\t\treturn elements ? jQuery.makeArray(elements) : this;\n\t\t\t}).filter(function () {\n\t\t\t\tvar type = this.type;\n\t\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n\t\t\t}).map(function (i, elem) {\n\t\t\t\tvar val = jQuery(this).val();\n\n\t\t\t\treturn val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\n\t\t\t\t}) : { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\n\t\t\t}).get();\n\t\t}\n\t});\n\n\t// Create the request object\n\t// (This is still attached to ajaxSettings for backward compatibility)\n\tjQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?\n\t// Support: IE6+\n\tfunction () {\n\n\t\t// XHR cannot access local files, always use ActiveX for that case\n\t\treturn !this.isLocal &&\n\n\t\t// Support: IE7-8\n\t\t// oldIE XHR does not support non-RFC2616 methods (#13240)\n\t\t// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx\n\t\t// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9\n\t\t// Although this check for six methods instead of eight\n\t\t// since IE also does not support \"trace\" and \"connect\"\n\t\t/^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();\n\t} :\n\t// For all other browsers, use the standard XMLHttpRequest object\n\tcreateStandardXHR;\n\n\tvar xhrId = 0,\n\t    xhrCallbacks = {},\n\t    xhrSupported = jQuery.ajaxSettings.xhr();\n\n\t// Support: IE<10\n\t// Open requests must be manually aborted on unload (#5280)\n\tif (window.ActiveXObject) {\n\t\tjQuery(window).on(\"unload\", function () {\n\t\t\tfor (var key in xhrCallbacks) {\n\t\t\t\txhrCallbacks[key](undefined, true);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Determine support properties\n\tsupport.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n\txhrSupported = support.ajax = !!xhrSupported;\n\n\t// Create transport if the browser can provide an xhr\n\tif (xhrSupported) {\n\n\t\tjQuery.ajaxTransport(function (options) {\n\t\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\t\tif (!options.crossDomain || support.cors) {\n\n\t\t\t\tvar _callback;\n\n\t\t\t\treturn {\n\t\t\t\t\tsend: function send(headers, complete) {\n\t\t\t\t\t\tvar i,\n\t\t\t\t\t\t    xhr = options.xhr(),\n\t\t\t\t\t\t    id = ++xhrId;\n\n\t\t\t\t\t\t// Open the socket\n\t\t\t\t\t\txhr.open(options.type, options.url, options.async, options.username, options.password);\n\n\t\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\t\tif (options.xhrFields) {\n\t\t\t\t\t\t\tfor (i in options.xhrFields) {\n\t\t\t\t\t\t\t\txhr[i] = options.xhrFields[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\t\tif (options.mimeType && xhr.overrideMimeType) {\n\t\t\t\t\t\t\txhr.overrideMimeType(options.mimeType);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\t\tif (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n\t\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Set headers\n\t\t\t\t\t\tfor (i in headers) {\n\t\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t\t// IE's ActiveXObject throws a 'Type Mismatch' exception when setting\n\t\t\t\t\t\t\t// request header to a null-value.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// To keep consistent with other XHR implementations, cast the value\n\t\t\t\t\t\t\t// to string and ignore `undefined`.\n\t\t\t\t\t\t\tif (headers[i] !== undefined) {\n\t\t\t\t\t\t\t\txhr.setRequestHeader(i, headers[i] + \"\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do send the request\n\t\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\t\txhr.send(options.hasContent && options.data || null);\n\n\t\t\t\t\t\t// Listener\n\t\t\t\t\t\t_callback = function callback(_, isAbort) {\n\t\t\t\t\t\t\tvar status, statusText, responses;\n\n\t\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\t\tif (_callback && (isAbort || xhr.readyState === 4)) {\n\t\t\t\t\t\t\t\t// Clean up\n\t\t\t\t\t\t\t\tdelete xhrCallbacks[id];\n\t\t\t\t\t\t\t\t_callback = undefined;\n\t\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\n\t\t\t\t\t\t\t\t// Abort manually if needed\n\t\t\t\t\t\t\t\tif (isAbort) {\n\t\t\t\t\t\t\t\t\tif (xhr.readyState !== 4) {\n\t\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\t\tstatus = xhr.status;\n\n\t\t\t\t\t\t\t\t\t// Support: IE<10\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\tif (typeof xhr.responseText === \"string\") {\n\t\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\t\tif (!status && options.isLocal && !options.crossDomain) {\n\t\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\t\t\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t\t} else if (status === 1223) {\n\t\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\t\tif (responses) {\n\t\t\t\t\t\t\t\tcomplete(status, statusText, responses, xhr.getAllResponseHeaders());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!options.async) {\n\t\t\t\t\t\t\t// if we're in sync mode we fire the callback\n\t\t\t\t\t\t\t_callback();\n\t\t\t\t\t\t} else if (xhr.readyState === 4) {\n\t\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\t\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\t\t\t\t\t\t\tsetTimeout(_callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Add to the list of active xhr callbacks\n\t\t\t\t\t\t\txhr.onreadystatechange = xhrCallbacks[id] = _callback;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tabort: function abort() {\n\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\t_callback(undefined, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n\n\t// Functions to create xhrs\n\tfunction createStandardXHR() {\n\t\ttry {\n\t\t\treturn new window.XMLHttpRequest();\n\t\t} catch (e) {}\n\t}\n\n\tfunction createActiveXHR() {\n\t\ttry {\n\t\t\treturn new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\t} catch (e) {}\n\t}\n\n\t// Install script dataType\n\tjQuery.ajaxSetup({\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /(?:java|ecma)script/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function textScript(text) {\n\t\t\t\tjQuery.globalEval(text);\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Handle cache's special case and global\n\tjQuery.ajaxPrefilter(\"script\", function (s) {\n\t\tif (s.cache === undefined) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif (s.crossDomain) {\n\t\t\ts.type = \"GET\";\n\t\t\ts.global = false;\n\t\t}\n\t});\n\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport(\"script\", function (s) {\n\n\t\t// This transport only deals with cross domain requests\n\t\tif (s.crossDomain) {\n\n\t\t\tvar script,\n\t\t\t    head = document.head || jQuery(\"head\")[0] || document.documentElement;\n\n\t\t\treturn {\n\n\t\t\t\tsend: function send(_, callback) {\n\n\t\t\t\t\tscript = document.createElement(\"script\");\n\n\t\t\t\t\tscript.async = true;\n\n\t\t\t\t\tif (s.scriptCharset) {\n\t\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t\t}\n\n\t\t\t\t\tscript.src = s.url;\n\n\t\t\t\t\t// Attach handlers for all browsers\n\t\t\t\t\tscript.onload = script.onreadystatechange = function (_, isAbort) {\n\n\t\t\t\t\t\tif (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {\n\n\t\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\t\tif (script.parentNode) {\n\t\t\t\t\t\t\t\tscript.parentNode.removeChild(script);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\t\tscript = null;\n\n\t\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\t\tif (!isAbort) {\n\t\t\t\t\t\t\t\tcallback(200, \"success\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n\t\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\t\thead.insertBefore(script, head.firstChild);\n\t\t\t\t},\n\n\t\t\t\tabort: function abort() {\n\t\t\t\t\tif (script) {\n\t\t\t\t\t\tscript.onload(undefined, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\tvar oldCallbacks = [],\n\t    rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n\t// Default jsonp settings\n\tjQuery.ajaxSetup({\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function jsonpCallback() {\n\t\t\tvar callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\n\t\t\tthis[callback] = true;\n\t\t\treturn callback;\n\t\t}\n\t});\n\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n\n\t\tvar callbackName,\n\t\t    overwritten,\n\t\t    responseContainer,\n\t\t    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && !(s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test(s.data) && \"data\");\n\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif (jsonProp || s.dataTypes[0] === \"jsonp\") {\n\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\n\n\t\t\t// Insert callback into url or form data\n\t\t\tif (jsonProp) {\n\t\t\t\ts[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n\t\t\t} else if (s.jsonp !== false) {\n\t\t\t\ts.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[\"script json\"] = function () {\n\t\t\t\tif (!responseContainer) {\n\t\t\t\t\tjQuery.error(callbackName + \" was not called\");\n\t\t\t\t}\n\t\t\t\treturn responseContainer[0];\n\t\t\t};\n\n\t\t\t// force json dataType\n\t\t\ts.dataTypes[0] = \"json\";\n\n\t\t\t// Install callback\n\t\t\toverwritten = window[callbackName];\n\t\t\twindow[callbackName] = function () {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always(function () {\n\t\t\t\t// Restore preexisting value\n\t\t\t\twindow[callbackName] = overwritten;\n\n\t\t\t\t// Save back as free\n\t\t\t\tif (s[callbackName]) {\n\t\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t\t// save the callback name for future use\n\t\t\t\t\toldCallbacks.push(callbackName);\n\t\t\t\t}\n\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif (responseContainer && jQuery.isFunction(overwritten)) {\n\t\t\t\t\toverwritten(responseContainer[0]);\n\t\t\t\t}\n\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t});\n\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t});\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function (data, context, keepScripts) {\n\t\tif (!data || typeof data !== \"string\") {\n\t\t\treturn null;\n\t\t}\n\t\tif (typeof context === \"boolean\") {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec(data),\n\t\t    scripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif (parsed) {\n\t\t\treturn [context.createElement(parsed[1])];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment([data], context, scripts);\n\n\t\tif (scripts && scripts.length) {\n\t\t\tjQuery(scripts).remove();\n\t\t}\n\n\t\treturn jQuery.merge([], parsed.childNodes);\n\t};\n\n\t// Keep a copy of the old load method\n\tvar _load = jQuery.fn.load;\n\n\t/**\n  * Load a url into a page\n  */\n\tjQuery.fn.load = function (url, params, callback) {\n\t\tif (typeof url !== \"string\" && _load) {\n\t\t\treturn _load.apply(this, arguments);\n\t\t}\n\n\t\tvar selector,\n\t\t    response,\n\t\t    type,\n\t\t    self = this,\n\t\t    off = url.indexOf(\" \");\n\n\t\tif (off >= 0) {\n\t\t\tselector = url.slice(off, url.length);\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\t// If it's a function\n\t\tif (jQuery.isFunction(params)) {\n\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\n\t\t\t// Otherwise, build a param string\n\t\t} else if (params && (typeof params === \"undefined\" ? \"undefined\" : _typeof(params)) === \"object\") {\n\t\t\ttype = \"POST\";\n\t\t}\n\n\t\t// If we have elements to modify, make the request\n\t\tif (self.length > 0) {\n\t\t\tjQuery.ajax({\n\t\t\t\turl: url,\n\n\t\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\t\ttype: type,\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t}).done(function (responseText) {\n\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\n\t\t\t\tself.html(selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText);\n\t\t\t}).complete(callback && function (jqXHR, status) {\n\t\t\t\tself.each(callback, response || [jqXHR.responseText, status, jqXHR]);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tjQuery.expr.filters.animated = function (elem) {\n\t\treturn jQuery.grep(jQuery.timers, function (fn) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n\n\tvar docElem = window.document.documentElement;\n\n\t/**\n  * Gets a window from an element\n  */\n\tfunction getWindow(elem) {\n\t\treturn jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;\n\t}\n\n\tjQuery.offset = {\n\t\tsetOffset: function setOffset(elem, options, i) {\n\t\t\tvar curPosition,\n\t\t\t    curLeft,\n\t\t\t    curCSSTop,\n\t\t\t    curTop,\n\t\t\t    curOffset,\n\t\t\t    curCSSLeft,\n\t\t\t    calculatePosition,\n\t\t\t    position = jQuery.css(elem, \"position\"),\n\t\t\t    curElem = jQuery(elem),\n\t\t\t    props = {};\n\n\t\t\t// set position first, in-case top/left are set even on static elem\n\t\t\tif (position === \"static\") {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css(elem, \"top\");\n\t\t\tcurCSSLeft = jQuery.css(elem, \"left\");\n\t\t\tcalculatePosition = (position === \"absolute\" || position === \"fixed\") && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1;\n\n\t\t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\t\tif (calculatePosition) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat(curCSSTop) || 0;\n\t\t\t\tcurLeft = parseFloat(curCSSLeft) || 0;\n\t\t\t}\n\n\t\t\tif (jQuery.isFunction(options)) {\n\t\t\t\toptions = options.call(elem, i, curOffset);\n\t\t\t}\n\n\t\t\tif (options.top != null) {\n\t\t\t\tprops.top = options.top - curOffset.top + curTop;\n\t\t\t}\n\t\t\tif (options.left != null) {\n\t\t\t\tprops.left = options.left - curOffset.left + curLeft;\n\t\t\t}\n\n\t\t\tif (\"using\" in options) {\n\t\t\t\toptions.using.call(elem, props);\n\t\t\t} else {\n\t\t\t\tcurElem.css(props);\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.fn.extend({\n\t\toffset: function offset(options) {\n\t\t\tif (arguments.length) {\n\t\t\t\treturn options === undefined ? this : this.each(function (i) {\n\t\t\t\t\tjQuery.offset.setOffset(this, options, i);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar docElem,\n\t\t\t    win,\n\t\t\t    box = { top: 0, left: 0 },\n\t\t\t    elem = this[0],\n\t\t\t    doc = elem && elem.ownerDocument;\n\n\t\t\tif (!doc) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\t// Make sure it's not a disconnected DOM node\n\t\t\tif (!jQuery.contains(docElem, elem)) {\n\t\t\t\treturn box;\n\t\t\t}\n\n\t\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t\t// BlackBerry 5, iOS 3 (original iPhone)\n\t\t\tif (_typeof(elem.getBoundingClientRect) !== strundefined) {\n\t\t\t\tbox = elem.getBoundingClientRect();\n\t\t\t}\n\t\t\twin = getWindow(doc);\n\t\t\treturn {\n\t\t\t\ttop: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n\t\t\t\tleft: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n\t\t\t};\n\t\t},\n\n\t\tposition: function position() {\n\t\t\tif (!this[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar offsetParent,\n\t\t\t    offset,\n\t\t\t    parentOffset = { top: 0, left: 0 },\n\t\t\t    elem = this[0];\n\n\t\t\t// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\t\tif (jQuery.css(elem, \"position\") === \"fixed\") {\n\t\t\t\t// we assume that getBoundingClientRect is available when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\t\t} else {\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif (!jQuery.nodeName(offsetParent[0], \"html\")) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset.top += jQuery.css(offsetParent[0], \"borderTopWidth\", true);\n\t\t\t\tparentOffset.left += jQuery.css(offsetParent[0], \"borderLeftWidth\", true);\n\t\t\t}\n\n\t\t\t// Subtract parent offsets and element margins\n\t\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n\t\t\t};\n\t\t},\n\n\t\toffsetParent: function offsetParent() {\n\t\t\treturn this.map(function () {\n\t\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\t\twhile (offsetParent && !jQuery.nodeName(offsetParent, \"html\") && jQuery.css(offsetParent, \"position\") === \"static\") {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\t\t\t\treturn offsetParent || docElem;\n\t\t\t});\n\t\t}\n\t});\n\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (method, prop) {\n\t\tvar top = /Y/.test(prop);\n\n\t\tjQuery.fn[method] = function (val) {\n\t\t\treturn access(this, function (elem, method, val) {\n\t\t\t\tvar win = getWindow(elem);\n\n\t\t\t\tif (val === undefined) {\n\t\t\t\t\treturn win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];\n\t\t\t\t}\n\n\t\t\t\tif (win) {\n\t\t\t\t\twin.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());\n\t\t\t\t} else {\n\t\t\t\t\telem[method] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length, null);\n\t\t};\n\t});\n\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\t// rather than make the css module depend on the offset module, we just check for it here\n\tjQuery.each([\"top\", \"left\"], function (i, prop) {\n\t\tjQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n\t\t\tif (computed) {\n\t\t\t\tcomputed = curCSS(elem, prop);\n\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n\t\t\t}\n\t\t});\n\t});\n\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each({ Height: \"height\", Width: \"width\" }, function (name, type) {\n\t\tjQuery.each({ padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function (defaultExtra, funcName) {\n\t\t\t// margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[funcName] = function (margin, value) {\n\t\t\t\tvar chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n\t\t\t\t    extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n\n\t\t\t\treturn access(this, function (elem, type, value) {\n\t\t\t\t\tvar doc;\n\n\t\t\t\t\tif (jQuery.isWindow(elem)) {\n\t\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\t\treturn elem.document.documentElement[\"client\" + name];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif (elem.nodeType === 9) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n\t\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\t\t\t\t\t\treturn Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css(elem, type, extra) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style(elem, type, value, extra);\n\t\t\t\t}, type, chainable ? margin : undefined, chainable, null);\n\t\t\t};\n\t\t});\n\t});\n\n\t// The number of elements contained in the matched element set\n\tjQuery.fn.size = function () {\n\t\treturn this.length;\n\t};\n\n\tjQuery.fn.andSelf = jQuery.fn.addBack;\n\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn jQuery;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\n\tvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\n\tjQuery.noConflict = function (deep) {\n\t\tif (window.$ === jQuery) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif (deep && window.jQuery === jQuery) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t};\n\n\t// Expose jQuery and $ identifiers, even in\n\t// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ((typeof noGlobal === \"undefined\" ? \"undefined\" : _typeof(noGlobal)) === strundefined) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\n\treturn jQuery;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(55)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvanF1ZXJ5LzEuMTEuMC5qcz85YTMzIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZG9jdW1lbnQiLCJ3IiwiRXJyb3IiLCJ3aW5kb3ciLCJub0dsb2JhbCIsImRlbGV0ZWRJZHMiLCJzbGljZSIsImNvbmNhdCIsInB1c2giLCJpbmRleE9mIiwiY2xhc3MydHlwZSIsInRvU3RyaW5nIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJ0cmltIiwic3VwcG9ydCIsInZlcnNpb24iLCJqUXVlcnkiLCJzZWxlY3RvciIsImNvbnRleHQiLCJmbiIsImluaXQiLCJydHJpbSIsInJtc1ByZWZpeCIsInJkYXNoQWxwaGEiLCJmY2FtZWxDYXNlIiwiYWxsIiwibGV0dGVyIiwidG9VcHBlckNhc2UiLCJwcm90b3R5cGUiLCJqcXVlcnkiLCJjb25zdHJ1Y3RvciIsImxlbmd0aCIsInRvQXJyYXkiLCJjYWxsIiwiZ2V0IiwibnVtIiwicHVzaFN0YWNrIiwiZWxlbXMiLCJyZXQiLCJtZXJnZSIsInByZXZPYmplY3QiLCJlYWNoIiwiY2FsbGJhY2siLCJhcmdzIiwibWFwIiwiZWxlbSIsImkiLCJhcHBseSIsImFyZ3VtZW50cyIsImZpcnN0IiwiZXEiLCJsYXN0IiwibGVuIiwiaiIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJzcmMiLCJjb3B5SXNBcnJheSIsImNvcHkiLCJuYW1lIiwib3B0aW9ucyIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzRnVuY3Rpb24iLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJvYmoiLCJ0eXBlIiwiQXJyYXkiLCJpc1dpbmRvdyIsImlzTnVtZXJpYyIsInBhcnNlRmxvYXQiLCJpc0VtcHR5T2JqZWN0Iiwia2V5Iiwibm9kZVR5cGUiLCJlIiwib3duTGFzdCIsImdsb2JhbEV2YWwiLCJkYXRhIiwiZXhlY1NjcmlwdCIsImNhbWVsQ2FzZSIsInN0cmluZyIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJ2YWx1ZSIsImlzQXJyYXlsaWtlIiwidGV4dCIsIm1ha2VBcnJheSIsImFyciIsInJlc3VsdHMiLCJPYmplY3QiLCJpbkFycmF5IiwibWF4Iiwic2Vjb25kIiwiZ3JlcCIsImludmVydCIsImNhbGxiYWNrSW52ZXJzZSIsIm1hdGNoZXMiLCJjYWxsYmFja0V4cGVjdCIsImFyZyIsImd1aWQiLCJwcm94eSIsInRtcCIsIm5vdyIsIkRhdGUiLCJzcGxpdCIsIlNpenpsZSIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJjb21waWxlIiwib3V0ZXJtb3N0Q29udGV4dCIsInNvcnRJbnB1dCIsImhhc0R1cGxpY2F0ZSIsInNldERvY3VtZW50IiwiZG9jRWxlbSIsImRvY3VtZW50SXNIVE1MIiwicmJ1Z2d5UVNBIiwicmJ1Z2d5TWF0Y2hlcyIsImNvbnRhaW5zIiwicHJlZmVycmVkRG9jIiwiZGlycnVucyIsImRvbmUiLCJjbGFzc0NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJ0b2tlbkNhY2hlIiwiY29tcGlsZXJDYWNoZSIsInNvcnRPcmRlciIsImEiLCJiIiwic3RydW5kZWZpbmVkIiwiTUFYX05FR0FUSVZFIiwicG9wIiwicHVzaF9uYXRpdmUiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJjaGFyYWN0ZXJFbmNvZGluZyIsImlkZW50aWZpZXIiLCJhdHRyaWJ1dGVzIiwicHNldWRvcyIsIlJlZ0V4cCIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJhdHRyaWJ1dGVRdW90ZXMiLCJycHNldWRvIiwicmlkZW50aWZpZXIiLCJtYXRjaEV4cHIiLCJyaW5wdXRzIiwicmhlYWRlciIsInJuYXRpdmUiLCJycXVpY2tFeHByIiwicnNpYmxpbmciLCJyZXNjYXBlIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiXyIsImVzY2FwZWQiLCJlc2NhcGVkV2hpdGVzcGFjZSIsImhpZ2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGlsZE5vZGVzIiwiZWxzIiwic2VlZCIsIm1hdGNoIiwibSIsImdyb3VwcyIsIm9sZCIsIm5pZCIsIm5ld0NvbnRleHQiLCJuZXdTZWxlY3RvciIsIm93bmVyRG9jdW1lbnQiLCJleGVjIiwiZ2V0RWxlbWVudEJ5SWQiLCJwYXJlbnROb2RlIiwiaWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJxc2EiLCJ0ZXN0IiwidG9rZW5pemUiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJ0b1NlbGVjdG9yIiwidGVzdENvbnRleHQiLCJqb2luIiwicXVlcnlTZWxlY3RvckFsbCIsInFzYUVycm9yIiwicmVtb3ZlQXR0cmlidXRlIiwic2VsZWN0Iiwia2V5cyIsImNhY2hlIiwiY2FjaGVMZW5ndGgiLCJzaGlmdCIsIm1hcmtGdW5jdGlvbiIsImFzc2VydCIsImRpdiIsImNyZWF0ZUVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsImFkZEhhbmRsZSIsImF0dHJzIiwiaGFuZGxlciIsImF0dHJIYW5kbGUiLCJzaWJsaW5nQ2hlY2siLCJjdXIiLCJkaWZmIiwic291cmNlSW5kZXgiLCJuZXh0U2libGluZyIsImNyZWF0ZUlucHV0UHNldWRvIiwiY3JlYXRlQnV0dG9uUHNldWRvIiwiY3JlYXRlUG9zaXRpb25hbFBzZXVkbyIsImFyZ3VtZW50IiwibWF0Y2hJbmRleGVzIiwiZG9jdW1lbnRFbGVtZW50Iiwibm9kZSIsImhhc0NvbXBhcmUiLCJkb2MiLCJwYXJlbnQiLCJkZWZhdWx0VmlldyIsInRvcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwiY3JlYXRlQ29tbWVudCIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJnZXRCeUlkIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJmaW5kIiwiZmlsdGVyIiwiYXR0cklkIiwiZ2V0QXR0cmlidXRlTm9kZSIsInRhZyIsImlucHV0IiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiZGlzY29ubmVjdGVkTWF0Y2giLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImFkb3duIiwiYnVwIiwiY29tcGFyZSIsInNvcnREZXRhY2hlZCIsImF1cCIsImFwIiwiYnAiLCJ1bnNoaWZ0IiwiZXhwciIsImVsZW1lbnRzIiwiYXR0ciIsInZhbCIsInNwZWNpZmllZCIsInVuaXF1ZVNvcnQiLCJkdXBsaWNhdGVzIiwiZGV0ZWN0RHVwbGljYXRlcyIsInNvcnRTdGFibGUiLCJ0ZXh0Q29udGVudCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwiZGlyIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsInhtbCIsIm91dGVyQ2FjaGUiLCJub2RlSW5kZXgiLCJzdGFydCIsInVzZUNhY2hlIiwibGFzdENoaWxkIiwicHNldWRvIiwic2V0RmlsdGVycyIsImlkeCIsIm1hdGNoZWQiLCJtYXRjaGVyIiwidW5tYXRjaGVkIiwiaW5uZXJUZXh0IiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImxvY2F0aW9uIiwiYWN0aXZlRWxlbWVudCIsImhhc0ZvY3VzIiwiaHJlZiIsInRhYkluZGV4IiwiZGlzYWJsZWQiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwicmFkaW8iLCJjaGVja2JveCIsImZpbGUiLCJwYXNzd29yZCIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5IiwidG9rZW5zIiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiYWRkQ29tYmluYXRvciIsImNvbWJpbmF0b3IiLCJiYXNlIiwiY2hlY2tOb25FbGVtZW50cyIsImRvbmVOYW1lIiwib2xkQ2FjaGUiLCJuZXdDYWNoZSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtdWx0aXBsZUNvbnRleHRzIiwibWF0Y2hlckluIiwibWF0Y2hlck91dCIsIm1hdGNoZXJGcm9tVG9rZW5zIiwiY2hlY2tDb250ZXh0IiwibGVhZGluZ1JlbGF0aXZlIiwiaW1wbGljaXRSZWxhdGl2ZSIsIm1hdGNoQ29udGV4dCIsIm1hdGNoQW55Q29udGV4dCIsIm1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyIsImVsZW1lbnRNYXRjaGVycyIsInNldE1hdGNoZXJzIiwiYnlTZXQiLCJieUVsZW1lbnQiLCJzdXBlck1hdGNoZXIiLCJvdXRlcm1vc3QiLCJtYXRjaGVkQ291bnQiLCJzZXRNYXRjaGVkIiwiY29udGV4dEJhY2t1cCIsImRpcnJ1bnNVbmlxdWUiLCJncm91cCIsImNvbnRleHRzIiwidG9rZW4iLCJkaXYxIiwiZGVmYXVsdFZhbHVlIiwidW5pcXVlIiwiaXNYTUxEb2MiLCJybmVlZHNDb250ZXh0IiwibmVlZHNDb250ZXh0IiwicnNpbmdsZVRhZyIsInJpc1NpbXBsZSIsIndpbm5vdyIsInF1YWxpZmllciIsIm5vdCIsInNlbGYiLCJpcyIsInJvb3RqUXVlcnkiLCJjaGFyQXQiLCJwYXJzZUhUTUwiLCJyZWFkeSIsInJwYXJlbnRzcHJldiIsImd1YXJhbnRlZWRVbmlxdWUiLCJjaGlsZHJlbiIsImNvbnRlbnRzIiwibmV4dCIsInByZXYiLCJ1bnRpbCIsInNpYmxpbmciLCJuIiwiciIsImhhcyIsInRhcmdldHMiLCJjbG9zZXN0IiwibCIsInBvcyIsImluZGV4IiwicHJldkFsbCIsImFkZCIsImFkZEJhY2siLCJwYXJlbnRzIiwicGFyZW50c1VudGlsIiwibmV4dEFsbCIsIm5leHRVbnRpbCIsInByZXZVbnRpbCIsInNpYmxpbmdzIiwiY29udGVudERvY3VtZW50IiwiY29udGVudFdpbmRvdyIsInJldmVyc2UiLCJybm90d2hpdGUiLCJvcHRpb25zQ2FjaGUiLCJjcmVhdGVPcHRpb25zIiwib2JqZWN0IiwiZmxhZyIsIkNhbGxiYWNrcyIsImZpcmluZyIsIm1lbW9yeSIsImZpcmVkIiwiZmlyaW5nTGVuZ3RoIiwiZmlyaW5nSW5kZXgiLCJmaXJpbmdTdGFydCIsImxpc3QiLCJzdGFjayIsIm9uY2UiLCJmaXJlIiwic3RvcE9uRmFsc2UiLCJkaXNhYmxlIiwicmVtb3ZlIiwiZW1wdHkiLCJsb2NrIiwibG9ja2VkIiwiZmlyZVdpdGgiLCJEZWZlcnJlZCIsImZ1bmMiLCJ0dXBsZXMiLCJzdGF0ZSIsInByb21pc2UiLCJhbHdheXMiLCJkZWZlcnJlZCIsImZhaWwiLCJ0aGVuIiwiZm5zIiwibmV3RGVmZXIiLCJ0dXBsZSIsInJldHVybmVkIiwicmVzb2x2ZSIsInJlamVjdCIsInByb2dyZXNzIiwibm90aWZ5IiwicGlwZSIsInN0YXRlU3RyaW5nIiwid2hlbiIsInN1Ym9yZGluYXRlIiwicmVzb2x2ZVZhbHVlcyIsInJlbWFpbmluZyIsInVwZGF0ZUZ1bmMiLCJ2YWx1ZXMiLCJwcm9ncmVzc1ZhbHVlcyIsIm5vdGlmeVdpdGgiLCJyZXNvbHZlV2l0aCIsInByb2dyZXNzQ29udGV4dHMiLCJyZXNvbHZlQ29udGV4dHMiLCJyZWFkeUxpc3QiLCJyZWFkeVdhaXQiLCJob2xkUmVhZHkiLCJob2xkIiwid2FpdCIsImJvZHkiLCJzZXRUaW1lb3V0IiwidHJpZ2dlciIsIm9mZiIsImRldGFjaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb21wbGV0ZWQiLCJkZXRhY2hFdmVudCIsImV2ZW50IiwicmVhZHlTdGF0ZSIsImZyYW1lRWxlbWVudCIsImRvU2Nyb2xsIiwiZG9TY3JvbGxDaGVjayIsImlubGluZUJsb2NrTmVlZHNMYXlvdXQiLCJjb250YWluZXIiLCJzdHlsZSIsImNzc1RleHQiLCJ6b29tIiwib2Zmc2V0V2lkdGgiLCJkZWxldGVFeHBhbmRvIiwiYWNjZXB0RGF0YSIsIm5vRGF0YSIsInJicmFjZSIsInJtdWx0aURhc2giLCJkYXRhQXR0ciIsInBhcnNlSlNPTiIsImlzRW1wdHlEYXRhT2JqZWN0IiwiaW50ZXJuYWxEYXRhIiwicHZ0IiwidGhpc0NhY2hlIiwiaW50ZXJuYWxLZXkiLCJpc05vZGUiLCJ0b0pTT04iLCJpbnRlcm5hbFJlbW92ZURhdGEiLCJjbGVhbkRhdGEiLCJoYXNEYXRhIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJxdWV1ZSIsImRlcXVldWUiLCJzdGFydExlbmd0aCIsImhvb2tzIiwiX3F1ZXVlSG9va3MiLCJzdG9wIiwic2V0dGVyIiwiY2xlYXJRdWV1ZSIsImNvdW50IiwiZGVmZXIiLCJwbnVtIiwic291cmNlIiwiY3NzRXhwYW5kIiwiaXNIaWRkZW4iLCJlbCIsImNzcyIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsInJjaGVja2FibGVUeXBlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwibGVhZGluZ1doaXRlc3BhY2UiLCJ0Ym9keSIsImh0bWxTZXJpYWxpemUiLCJodG1sNUNsb25lIiwiY2xvbmVOb2RlIiwib3V0ZXJIVE1MIiwiYXBwZW5kQ2hlY2tlZCIsIm5vQ2xvbmVDaGVja2VkIiwiY2hlY2tDbG9uZSIsIm5vQ2xvbmVFdmVudCIsImNsaWNrIiwiZXZlbnROYW1lIiwiY2hhbmdlIiwiZm9jdXNpbiIsInJmb3JtRWxlbXMiLCJya2V5RXZlbnQiLCJybW91c2VFdmVudCIsInJmb2N1c01vcnBoIiwicnR5cGVuYW1lc3BhY2UiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJzYWZlQWN0aXZlRWxlbWVudCIsImVyciIsInR5cGVzIiwiZXZlbnRzIiwidCIsImhhbmRsZU9iakluIiwic3BlY2lhbCIsImV2ZW50SGFuZGxlIiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJuYW1lc3BhY2UiLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJvbmx5SGFuZGxlcnMiLCJvbnR5cGUiLCJidWJibGVUeXBlIiwiZXZlbnRQYXRoIiwiRXZlbnQiLCJpc1RyaWdnZXIiLCJuYW1lc3BhY2VfcmUiLCJub0J1YmJsZSIsInBhcmVudFdpbmRvdyIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicHJldmVudERlZmF1bHQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJfZGVmYXVsdCIsImZpeCIsImhhbmRsZXJRdWV1ZSIsImRlbGVnYXRlVGFyZ2V0IiwicHJlRGlzcGF0Y2giLCJjdXJyZW50VGFyZ2V0IiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJzdG9wUHJvcGFnYXRpb24iLCJwb3N0RGlzcGF0Y2giLCJzZWwiLCJidXR0b24iLCJwcm9wIiwib3JpZ2luYWxFdmVudCIsImZpeEhvb2siLCJmaXhIb29rcyIsIm1vdXNlSG9va3MiLCJrZXlIb29rcyIsInByb3BzIiwic3JjRWxlbWVudCIsIm1ldGFLZXkiLCJvcmlnaW5hbCIsIndoaWNoIiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiZXZlbnREb2MiLCJmcm9tRWxlbWVudCIsInBhZ2VYIiwiY2xpZW50WCIsInNjcm9sbExlZnQiLCJjbGllbnRMZWZ0IiwicGFnZVkiLCJjbGllbnRZIiwic2Nyb2xsVG9wIiwiY2xpZW50VG9wIiwicmVsYXRlZFRhcmdldCIsInRvRWxlbWVudCIsImxvYWQiLCJmb2N1cyIsImJsdXIiLCJiZWZvcmV1bmxvYWQiLCJyZXR1cm5WYWx1ZSIsInNpbXVsYXRlIiwiYnViYmxlIiwiaXNTaW11bGF0ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwiZ2V0UHJldmVudERlZmF1bHQiLCJ0aW1lU3RhbXAiLCJjYW5jZWxCdWJibGUiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIm9yaWciLCJyZWxhdGVkIiwic3VibWl0QnViYmxlcyIsImZvcm0iLCJfc3VibWl0X2J1YmJsZSIsImNoYW5nZUJ1YmJsZXMiLCJwcm9wZXJ0eU5hbWUiLCJfanVzdF9jaGFuZ2VkIiwiZm9jdXNpbkJ1YmJsZXMiLCJhdHRhY2hlcyIsIm9uIiwib25lIiwib3JpZ0ZuIiwidHJpZ2dlckhhbmRsZXIiLCJjcmVhdGVTYWZlRnJhZ21lbnQiLCJub2RlTmFtZXMiLCJzYWZlRnJhZyIsInJpbmxpbmVqUXVlcnkiLCJybm9zaGltY2FjaGUiLCJybGVhZGluZ1doaXRlc3BhY2UiLCJyeGh0bWxUYWciLCJydGFnTmFtZSIsInJ0Ym9keSIsInJodG1sIiwicm5vSW5uZXJodG1sIiwicmNoZWNrZWQiLCJyc2NyaXB0VHlwZSIsInJzY3JpcHRUeXBlTWFza2VkIiwicmNsZWFuU2NyaXB0Iiwid3JhcE1hcCIsIm9wdGlvbiIsImxlZ2VuZCIsImFyZWEiLCJwYXJhbSIsInRoZWFkIiwidHIiLCJjb2wiLCJ0ZCIsInNhZmVGcmFnbWVudCIsImZyYWdtZW50RGl2Iiwib3B0Z3JvdXAiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwiZ2V0QWxsIiwiZm91bmQiLCJmaXhEZWZhdWx0Q2hlY2tlZCIsImRlZmF1bHRDaGVja2VkIiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiY29udGVudCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0Iiwic2V0R2xvYmFsRXZhbCIsInJlZkVsZW1lbnRzIiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0Iiwib2xkRGF0YSIsImN1ckRhdGEiLCJmaXhDbG9uZU5vZGVJc3N1ZXMiLCJkZWZhdWx0U2VsZWN0ZWQiLCJkYXRhQW5kRXZlbnRzIiwiZGVlcERhdGFBbmRFdmVudHMiLCJkZXN0RWxlbWVudHMiLCJzcmNFbGVtZW50cyIsImluUGFnZSIsImJ1aWxkRnJhZ21lbnQiLCJzY3JpcHRzIiwic2VsZWN0aW9uIiwid3JhcCIsInNhZmUiLCJub2RlcyIsImNyZWF0ZVRleHROb2RlIiwiYXBwZW5kIiwiZG9tTWFuaXAiLCJwcmVwZW5kIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJrZWVwRGF0YSIsImh0bWwiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImhhc1NjcmlwdHMiLCJzZXQiLCJpTm9DbG9uZSIsIl9ldmFsVXJsIiwiYXBwZW5kVG8iLCJwcmVwZW5kVG8iLCJpbnNlcnRBZnRlciIsInJlcGxhY2VBbGwiLCJpbnNlcnQiLCJpZnJhbWUiLCJlbGVtZGlzcGxheSIsImFjdHVhbERpc3BsYXkiLCJkaXNwbGF5IiwiZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUiLCJkZWZhdWx0RGlzcGxheSIsIndyaXRlIiwiY2xvc2UiLCJzaHJpbmtXcmFwQmxvY2tzVmFsIiwiZGl2UmVzZXQiLCJvcGFjaXR5IiwiY3NzRmxvYXQiLCJiYWNrZ3JvdW5kQ2xpcCIsImNsZWFyQ2xvbmVTdHlsZSIsInNocmlua1dyYXBCbG9ja3MiLCJjb250YWluZXJTdHlsZXMiLCJ3aWR0aCIsInJtYXJnaW4iLCJybnVtbm9ucHgiLCJnZXRTdHlsZXMiLCJjdXJDU1MiLCJycG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwiY29tcHV0ZWQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImN1cnJlbnRTdHlsZSIsImxlZnQiLCJycyIsInJzTGVmdCIsInJ1bnRpbWVTdHlsZSIsInBpeGVsTGVmdCIsImFkZEdldEhvb2tJZiIsImNvbmRpdGlvbkZuIiwiaG9va0ZuIiwiY29uZGl0aW9uIiwicmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsIiwiYm94U2l6aW5nVmFsIiwiYm94U2l6aW5nUmVsaWFibGVWYWwiLCJwaXhlbFBvc2l0aW9uVmFsIiwicmVsaWFibGVNYXJnaW5SaWdodFZhbCIsInJlbGlhYmxlSGlkZGVuT2Zmc2V0cyIsInRkcyIsImlzU3VwcG9ydGVkIiwib2Zmc2V0SGVpZ2h0IiwiYm94U2l6aW5nIiwiY29tcHV0ZVN0eWxlVGVzdHMiLCJib3hTaXppbmdSZWxpYWJsZSIsInBpeGVsUG9zaXRpb24iLCJyZWxpYWJsZU1hcmdpblJpZ2h0IiwibWFyZ2luRGl2IiwibWFyZ2luUmlnaHQiLCJzd2FwIiwicmFscGhhIiwicm9wYWNpdHkiLCJyZGlzcGxheXN3YXAiLCJybnVtc3BsaXQiLCJycmVsTnVtIiwiY3NzU2hvdyIsInBvc2l0aW9uIiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJmb250V2VpZ2h0IiwiY3NzUHJlZml4ZXMiLCJ2ZW5kb3JQcm9wTmFtZSIsImNhcE5hbWUiLCJvcmlnTmFtZSIsInNob3dIaWRlIiwic2hvdyIsImhpZGRlbiIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJhdWdtZW50V2lkdGhPckhlaWdodCIsImV4dHJhIiwiaXNCb3JkZXJCb3giLCJzdHlsZXMiLCJnZXRXaWR0aE9ySGVpZ2h0IiwidmFsdWVJc0JvcmRlckJveCIsImNzc0hvb2tzIiwiY3NzTnVtYmVyIiwiY3NzUHJvcHMiLCIkMSIsIm1hcmdpbiIsInBhZGRpbmciLCJib3JkZXIiLCJwcmVmaXgiLCJzdWZmaXgiLCJleHBhbmQiLCJleHBhbmRlZCIsInBhcnRzIiwiaGlkZSIsInRvZ2dsZSIsIlR3ZWVuIiwiZWFzaW5nIiwidW5pdCIsInByb3BIb29rcyIsInJ1biIsInBlcmNlbnQiLCJlYXNlZCIsImR1cmF0aW9uIiwic3RlcCIsInR3ZWVuIiwiZngiLCJsaW5lYXIiLCJwIiwic3dpbmciLCJjb3MiLCJQSSIsImZ4Tm93IiwidGltZXJJZCIsInJmeHR5cGVzIiwicmZ4bnVtIiwicnJ1biIsImFuaW1hdGlvblByZWZpbHRlcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwidHdlZW5lcnMiLCJjcmVhdGVUd2VlbiIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImNyZWF0ZUZ4Tm93IiwiZ2VuRngiLCJpbmNsdWRlV2lkdGgiLCJoZWlnaHQiLCJhbmltYXRpb24iLCJjb2xsZWN0aW9uIiwib3B0cyIsIm9sZGZpcmUiLCJkRGlzcGxheSIsImFuaW0iLCJkYXRhU2hvdyIsInVucXVldWVkIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJwcm9wRmlsdGVyIiwic3BlY2lhbEVhc2luZyIsIkFuaW1hdGlvbiIsInByb3BlcnRpZXMiLCJzdG9wcGVkIiwidGljayIsImN1cnJlbnRUaW1lIiwic3RhcnRUaW1lIiwidHdlZW5zIiwib3JpZ2luYWxQcm9wZXJ0aWVzIiwib3JpZ2luYWxPcHRpb25zIiwiZ290b0VuZCIsInJlamVjdFdpdGgiLCJ0aW1lciIsImNvbXBsZXRlIiwidHdlZW5lciIsInByZWZpbHRlciIsInNwZWVkIiwib3B0Iiwic3BlZWRzIiwiZmFkZVRvIiwidG8iLCJhbmltYXRlIiwib3B0YWxsIiwiZG9BbmltYXRpb24iLCJmaW5pc2giLCJzdG9wUXVldWUiLCJ0aW1lcnMiLCJjc3NGbiIsInNsaWRlRG93biIsInNsaWRlVXAiLCJzbGlkZVRvZ2dsZSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG9nZ2xlIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJzbG93IiwiZmFzdCIsImRlbGF5IiwidGltZSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJnZXRTZXRBdHRyaWJ1dGUiLCJocmVmTm9ybWFsaXplZCIsImNoZWNrT24iLCJvcHRTZWxlY3RlZCIsImVuY3R5cGUiLCJvcHREaXNhYmxlZCIsInJhZGlvVmFsdWUiLCJycmV0dXJuIiwidmFsSG9va3MiLCJvcHRpb25TZXQiLCJzY3JvbGxIZWlnaHQiLCJub2RlSG9vayIsImJvb2xIb29rIiwicnVzZURlZmF1bHQiLCJnZXRTZXRJbnB1dCIsInJlbW92ZUF0dHIiLCJuVHlwZSIsImF0dHJIb29rcyIsImJvb2wiLCJwcm9wTmFtZSIsImF0dHJOYW1lcyIsInByb3BGaXgiLCJnZXR0ZXIiLCJzZXRBdHRyaWJ1dGVOb2RlIiwiY3JlYXRlQXR0cmlidXRlIiwiY29vcmRzIiwiY29udGVudGVkaXRhYmxlIiwicmZvY3VzYWJsZSIsInJjbGlja2FibGUiLCJyZW1vdmVQcm9wIiwibm90eG1sIiwidGFiaW5kZXgiLCJwYXJzZUludCIsInJjbGFzcyIsImFkZENsYXNzIiwiY2xhc3NlcyIsImNsYXp6IiwiZmluYWxWYWx1ZSIsInByb2NlZWQiLCJyZW1vdmVDbGFzcyIsInRvZ2dsZUNsYXNzIiwic3RhdGVWYWwiLCJjbGFzc05hbWVzIiwiaGFzQ2xhc3MiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwiYmluZCIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsIm5vbmNlIiwicnF1ZXJ5IiwicnZhbGlkdG9rZW5zIiwiSlNPTiIsInBhcnNlIiwicmVxdWlyZU5vbkNvbW1hIiwiZGVwdGgiLCJzdHIiLCJjb21tYSIsIm9wZW4iLCJGdW5jdGlvbiIsInBhcnNlWE1MIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiQWN0aXZlWE9iamVjdCIsImFzeW5jIiwibG9hZFhNTCIsImFqYXhMb2NQYXJ0cyIsImFqYXhMb2NhdGlvbiIsInJoYXNoIiwicnRzIiwicmhlYWRlcnMiLCJybG9jYWxQcm90b2NvbCIsInJub0NvbnRlbnQiLCJycHJvdG9jb2wiLCJydXJsIiwicHJlZmlsdGVycyIsInRyYW5zcG9ydHMiLCJhbGxUeXBlcyIsImFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsInN0cnVjdHVyZSIsImRhdGFUeXBlRXhwcmVzc2lvbiIsImRhdGFUeXBlIiwiZGF0YVR5cGVzIiwiaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJqcVhIUiIsImluc3BlY3RlZCIsInNlZWtpbmdUcmFuc3BvcnQiLCJpbnNwZWN0IiwicHJlZmlsdGVyT3JGYWN0b3J5IiwiZGF0YVR5cGVPclRyYW5zcG9ydCIsImFqYXhFeHRlbmQiLCJmbGF0T3B0aW9ucyIsImFqYXhTZXR0aW5ncyIsImFqYXhIYW5kbGVSZXNwb25zZXMiLCJzIiwicmVzcG9uc2VzIiwiZmlyc3REYXRhVHlwZSIsImN0IiwiZmluYWxEYXRhVHlwZSIsIm1pbWVUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJjb252ZXJ0ZXJzIiwiYWpheENvbnZlcnQiLCJyZXNwb25zZSIsImlzU3VjY2VzcyIsImNvbnYyIiwiY3VycmVudCIsImNvbnYiLCJyZXNwb25zZUZpZWxkcyIsImRhdGFGaWx0ZXIiLCJhY3RpdmUiLCJsYXN0TW9kaWZpZWQiLCJldGFnIiwidXJsIiwiaXNMb2NhbCIsInByb2Nlc3NEYXRhIiwiY29udGVudFR5cGUiLCJhY2NlcHRzIiwianNvbiIsImFqYXhTZXR1cCIsInNldHRpbmdzIiwiYWpheFByZWZpbHRlciIsImFqYXhUcmFuc3BvcnQiLCJhamF4IiwiY2FjaGVVUkwiLCJyZXNwb25zZUhlYWRlcnNTdHJpbmciLCJ0aW1lb3V0VGltZXIiLCJmaXJlR2xvYmFscyIsInRyYW5zcG9ydCIsInJlc3BvbnNlSGVhZGVycyIsImNhbGxiYWNrQ29udGV4dCIsImdsb2JhbEV2ZW50Q29udGV4dCIsImNvbXBsZXRlRGVmZXJyZWQiLCJzdGF0dXNDb2RlIiwicmVxdWVzdEhlYWRlcnMiLCJyZXF1ZXN0SGVhZGVyc05hbWVzIiwic3RyQWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZXRSZXF1ZXN0SGVhZGVyIiwibG5hbWUiLCJvdmVycmlkZU1pbWVUeXBlIiwiY29kZSIsInN0YXR1cyIsImFib3J0Iiwic3RhdHVzVGV4dCIsImZpbmFsVGV4dCIsInN1Y2Nlc3MiLCJtZXRob2QiLCJjcm9zc0RvbWFpbiIsInRyYWRpdGlvbmFsIiwiaGFzQ29udGVudCIsImlmTW9kaWZpZWQiLCJoZWFkZXJzIiwiYmVmb3JlU2VuZCIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwibW9kaWZpZWQiLCJnZXRKU09OIiwiZ2V0U2NyaXB0Iiwid3JhcEFsbCIsIndyYXBJbm5lciIsInVud3JhcCIsInZpc2libGUiLCJyMjAiLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwiYnVpbGRQYXJhbXMiLCJ2IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJ4aHIiLCJjcmVhdGVTdGFuZGFyZFhIUiIsImNyZWF0ZUFjdGl2ZVhIUiIsInhocklkIiwieGhyQ2FsbGJhY2tzIiwieGhyU3VwcG9ydGVkIiwiY29ycyIsInVzZXJuYW1lIiwieGhyRmllbGRzIiwiaXNBYm9ydCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVGV4dCIsIlhNTEh0dHBSZXF1ZXN0Iiwic2NyaXB0IiwiaGVhZCIsInNjcmlwdENoYXJzZXQiLCJjaGFyc2V0Iiwib25sb2FkIiwib2xkQ2FsbGJhY2tzIiwicmpzb25wIiwianNvbnAiLCJqc29ucENhbGxiYWNrIiwib3JpZ2luYWxTZXR0aW5ncyIsImNhbGxiYWNrTmFtZSIsIm92ZXJ3cml0dGVuIiwicmVzcG9uc2VDb250YWluZXIiLCJqc29uUHJvcCIsImtlZXBTY3JpcHRzIiwicGFyc2VkIiwiX2xvYWQiLCJwYXJhbXMiLCJhbmltYXRlZCIsImdldFdpbmRvdyIsIm9mZnNldCIsInNldE9mZnNldCIsImN1clBvc2l0aW9uIiwiY3VyTGVmdCIsImN1ckNTU1RvcCIsImN1clRvcCIsImN1ck9mZnNldCIsImN1ckNTU0xlZnQiLCJjYWxjdWxhdGVQb3NpdGlvbiIsImN1ckVsZW0iLCJ1c2luZyIsIndpbiIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJvZmZzZXRQYXJlbnQiLCJwYXJlbnRPZmZzZXQiLCJzY3JvbGxUbyIsIkhlaWdodCIsIldpZHRoIiwiZGVmYXVsdEV4dHJhIiwiZnVuY05hbWUiLCJzaXplIiwiYW5kU2VsZiIsImRlZmluZSIsIl9qUXVlcnkiLCJfJCIsIiQiLCJub0NvbmZsaWN0Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FBY0MsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBNEI7O0FBRTVCLEtBQUssZ0NBQU9DLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEIsUUFBT0EsT0FBT0MsT0FBZCxNQUEwQixRQUE3RCxFQUF3RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRCxTQUFPQyxPQUFQLEdBQWlCSCxPQUFPSSxRQUFQLEdBQ2hCSCxRQUFTRCxNQUFULEVBQWlCLElBQWpCLENBRGdCLEdBRWhCLFVBQVVLLENBQVYsRUFBYztBQUNiLE9BQUssQ0FBQ0EsRUFBRUQsUUFBUixFQUFtQjtBQUNsQixVQUFNLElBQUlFLEtBQUosQ0FBVywwQ0FBWCxDQUFOO0FBQ0E7QUFDRCxVQUFPTCxRQUFTSSxDQUFULENBQVA7QUFDQSxHQVBGO0FBUUEsRUFoQkQsTUFnQk87QUFDTkosVUFBU0QsTUFBVDtBQUNBOztBQUVGO0FBQ0MsQ0F2QkEsRUF1QkMsT0FBT08sTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsWUF2QkQsRUF1QmdELFVBQVVBLE1BQVYsRUFBa0JDLFFBQWxCLEVBQTZCOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUlDLGFBQWEsRUFBakI7O0FBRUEsS0FBSUMsU0FBUUQsV0FBV0MsS0FBdkI7O0FBRUEsS0FBSUMsU0FBU0YsV0FBV0UsTUFBeEI7O0FBRUEsS0FBSUMsT0FBT0gsV0FBV0csSUFBdEI7O0FBRUEsS0FBSUMsVUFBVUosV0FBV0ksT0FBekI7O0FBRUEsS0FBSUMsYUFBYSxFQUFqQjs7QUFFQSxLQUFJQyxXQUFXRCxXQUFXQyxRQUExQjs7QUFFQSxLQUFJQyxTQUFTRixXQUFXRyxjQUF4Qjs7QUFFQSxLQUFJQyxPQUFPLEdBQUdBLElBQWQ7O0FBRUEsS0FBSUMsVUFBVSxFQUFkOztBQUlBLEtBQ0NDLFVBQVUsUUFEWDs7O0FBR0M7QUFDQUMsVUFBUyxTQUFUQSxNQUFTLENBQVVDLFFBQVYsRUFBb0JDLE9BQXBCLEVBQThCO0FBQ3RDO0FBQ0E7QUFDQSxTQUFPLElBQUlGLE9BQU9HLEVBQVAsQ0FBVUMsSUFBZCxDQUFvQkgsUUFBcEIsRUFBOEJDLE9BQTlCLENBQVA7QUFDQSxFQVJGOzs7QUFVQztBQUNBRyxTQUFRLG9DQVhUOzs7QUFhQztBQUNBQyxhQUFZLE9BZGI7QUFBQSxLQWVDQyxhQUFhLGNBZmQ7OztBQWlCQztBQUNBQyxjQUFhLFNBQWJBLFVBQWEsQ0FBVUMsR0FBVixFQUFlQyxNQUFmLEVBQXdCO0FBQ3BDLFNBQU9BLE9BQU9DLFdBQVAsRUFBUDtBQUNBLEVBcEJGOztBQXNCQVgsUUFBT0csRUFBUCxHQUFZSCxPQUFPWSxTQUFQLEdBQW1CO0FBQzlCO0FBQ0FDLFVBQVFkLE9BRnNCOztBQUk5QmUsZUFBYWQsTUFKaUI7O0FBTTlCO0FBQ0FDLFlBQVUsRUFQb0I7O0FBUzlCO0FBQ0FjLFVBQVEsQ0FWc0I7O0FBWTlCQyxXQUFTLG1CQUFXO0FBQ25CLFVBQU8zQixPQUFNNEIsSUFBTixDQUFZLElBQVosQ0FBUDtBQUNBLEdBZDZCOztBQWdCOUI7QUFDQTtBQUNBQyxPQUFLLGFBQVVDLEdBQVYsRUFBZ0I7QUFDcEIsVUFBT0EsT0FBTyxJQUFQOztBQUVOO0FBQ0VBLFNBQU0sQ0FBTixHQUFVLEtBQU1BLE1BQU0sS0FBS0osTUFBakIsQ0FBVixHQUFzQyxLQUFNSSxHQUFOLENBSGxDOztBQUtOO0FBQ0E5QixVQUFNNEIsSUFBTixDQUFZLElBQVosQ0FORDtBQU9BLEdBMUI2Qjs7QUE0QjlCO0FBQ0E7QUFDQUcsYUFBVyxtQkFBVUMsS0FBVixFQUFrQjs7QUFFNUI7QUFDQSxPQUFJQyxNQUFNdEIsT0FBT3VCLEtBQVAsQ0FBYyxLQUFLVCxXQUFMLEVBQWQsRUFBa0NPLEtBQWxDLENBQVY7O0FBRUE7QUFDQUMsT0FBSUUsVUFBSixHQUFpQixJQUFqQjtBQUNBRixPQUFJcEIsT0FBSixHQUFjLEtBQUtBLE9BQW5COztBQUVBO0FBQ0EsVUFBT29CLEdBQVA7QUFDQSxHQXpDNkI7O0FBMkM5QjtBQUNBO0FBQ0E7QUFDQUcsUUFBTSxjQUFVQyxRQUFWLEVBQW9CQyxJQUFwQixFQUEyQjtBQUNoQyxVQUFPM0IsT0FBT3lCLElBQVAsQ0FBYSxJQUFiLEVBQW1CQyxRQUFuQixFQUE2QkMsSUFBN0IsQ0FBUDtBQUNBLEdBaEQ2Qjs7QUFrRDlCQyxPQUFLLGFBQVVGLFFBQVYsRUFBcUI7QUFDekIsVUFBTyxLQUFLTixTQUFMLENBQWdCcEIsT0FBTzRCLEdBQVAsQ0FBVyxJQUFYLEVBQWlCLFVBQVVDLElBQVYsRUFBZ0JDLENBQWhCLEVBQW9CO0FBQzNELFdBQU9KLFNBQVNULElBQVQsQ0FBZVksSUFBZixFQUFxQkMsQ0FBckIsRUFBd0JELElBQXhCLENBQVA7QUFDQSxJQUZzQixDQUFoQixDQUFQO0FBR0EsR0F0RDZCOztBQXdEOUJ4QyxTQUFPLGlCQUFXO0FBQ2pCLFVBQU8sS0FBSytCLFNBQUwsQ0FBZ0IvQixPQUFNMEMsS0FBTixDQUFhLElBQWIsRUFBbUJDLFNBQW5CLENBQWhCLENBQVA7QUFDQSxHQTFENkI7O0FBNEQ5QkMsU0FBTyxpQkFBVztBQUNqQixVQUFPLEtBQUtDLEVBQUwsQ0FBUyxDQUFULENBQVA7QUFDQSxHQTlENkI7O0FBZ0U5QkMsUUFBTSxnQkFBVztBQUNoQixVQUFPLEtBQUtELEVBQUwsQ0FBUyxDQUFDLENBQVYsQ0FBUDtBQUNBLEdBbEU2Qjs7QUFvRTlCQSxNQUFJLFlBQVVKLENBQVYsRUFBYztBQUNqQixPQUFJTSxNQUFNLEtBQUtyQixNQUFmO0FBQUEsT0FDQ3NCLElBQUksQ0FBQ1AsQ0FBRCxJQUFPQSxJQUFJLENBQUosR0FBUU0sR0FBUixHQUFjLENBQXJCLENBREw7QUFFQSxVQUFPLEtBQUtoQixTQUFMLENBQWdCaUIsS0FBSyxDQUFMLElBQVVBLElBQUlELEdBQWQsR0FBb0IsQ0FBRSxLQUFLQyxDQUFMLENBQUYsQ0FBcEIsR0FBa0MsRUFBbEQsQ0FBUDtBQUNBLEdBeEU2Qjs7QUEwRTlCQyxPQUFLLGVBQVc7QUFDZixVQUFPLEtBQUtkLFVBQUwsSUFBbUIsS0FBS1YsV0FBTCxDQUFpQixJQUFqQixDQUExQjtBQUNBLEdBNUU2Qjs7QUE4RTlCO0FBQ0E7QUFDQXZCLFFBQU1BLElBaEZ3QjtBQWlGOUJnRCxRQUFNbkQsV0FBV21ELElBakZhO0FBa0Y5QkMsVUFBUXBELFdBQVdvRDtBQWxGVyxFQUEvQjs7QUFxRkF4QyxRQUFPeUMsTUFBUCxHQUFnQnpDLE9BQU9HLEVBQVAsQ0FBVXNDLE1BQVYsR0FBbUIsWUFBVztBQUM3QyxNQUFJQyxHQUFKO0FBQUEsTUFBU0MsV0FBVDtBQUFBLE1BQXNCQyxJQUF0QjtBQUFBLE1BQTRCQyxJQUE1QjtBQUFBLE1BQWtDQyxPQUFsQztBQUFBLE1BQTJDQyxLQUEzQztBQUFBLE1BQ0NDLFNBQVNoQixVQUFVLENBQVYsS0FBZ0IsRUFEMUI7QUFBQSxNQUVDRixJQUFJLENBRkw7QUFBQSxNQUdDZixTQUFTaUIsVUFBVWpCLE1BSHBCO0FBQUEsTUFJQ2tDLE9BQU8sS0FKUjs7QUFNQTtBQUNBLE1BQUssT0FBT0QsTUFBUCxLQUFrQixTQUF2QixFQUFtQztBQUNsQ0MsVUFBT0QsTUFBUDs7QUFFQTtBQUNBQSxZQUFTaEIsVUFBV0YsQ0FBWCxLQUFrQixFQUEzQjtBQUNBQTtBQUNBOztBQUVEO0FBQ0EsTUFBSyxRQUFPa0IsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QixDQUFDaEQsT0FBT2tELFVBQVAsQ0FBa0JGLE1BQWxCLENBQXBDLEVBQWdFO0FBQy9EQSxZQUFTLEVBQVQ7QUFDQTs7QUFFRDtBQUNBLE1BQUtsQixNQUFNZixNQUFYLEVBQW9CO0FBQ25CaUMsWUFBUyxJQUFUO0FBQ0FsQjtBQUNBOztBQUVELFNBQVFBLElBQUlmLE1BQVosRUFBb0JlLEdBQXBCLEVBQTBCO0FBQ3pCO0FBQ0EsT0FBSyxDQUFDZ0IsVUFBVWQsVUFBV0YsQ0FBWCxDQUFYLEtBQThCLElBQW5DLEVBQTBDO0FBQ3pDO0FBQ0EsU0FBTWUsSUFBTixJQUFjQyxPQUFkLEVBQXdCO0FBQ3ZCSixXQUFNTSxPQUFRSCxJQUFSLENBQU47QUFDQUQsWUFBT0UsUUFBU0QsSUFBVCxDQUFQOztBQUVBO0FBQ0EsU0FBS0csV0FBV0osSUFBaEIsRUFBdUI7QUFDdEI7QUFDQTs7QUFFRDtBQUNBLFNBQUtLLFFBQVFMLElBQVIsS0FBa0I1QyxPQUFPbUQsYUFBUCxDQUFxQlAsSUFBckIsTUFBK0JELGNBQWMzQyxPQUFPb0QsT0FBUCxDQUFlUixJQUFmLENBQTdDLENBQWxCLENBQUwsRUFBOEY7QUFDN0YsVUFBS0QsV0FBTCxFQUFtQjtBQUNsQkEscUJBQWMsS0FBZDtBQUNBSSxlQUFRTCxPQUFPMUMsT0FBT29ELE9BQVAsQ0FBZVYsR0FBZixDQUFQLEdBQTZCQSxHQUE3QixHQUFtQyxFQUEzQztBQUVBLE9BSkQsTUFJTztBQUNOSyxlQUFRTCxPQUFPMUMsT0FBT21ELGFBQVAsQ0FBcUJULEdBQXJCLENBQVAsR0FBbUNBLEdBQW5DLEdBQXlDLEVBQWpEO0FBQ0E7O0FBRUQ7QUFDQU0sYUFBUUgsSUFBUixJQUFpQjdDLE9BQU95QyxNQUFQLENBQWVRLElBQWYsRUFBcUJGLEtBQXJCLEVBQTRCSCxJQUE1QixDQUFqQjs7QUFFRDtBQUNDLE1BYkQsTUFhTyxJQUFLQSxTQUFTUyxTQUFkLEVBQTBCO0FBQ2hDTCxhQUFRSCxJQUFSLElBQWlCRCxJQUFqQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0EsU0FBT0ksTUFBUDtBQUNBLEVBL0REOztBQWlFQWhELFFBQU95QyxNQUFQLENBQWM7QUFDYjtBQUNBYSxXQUFTLFdBQVcsQ0FBRXZELFVBQVV3RCxLQUFLQyxNQUFMLEVBQVosRUFBNEJDLE9BQTVCLENBQXFDLEtBQXJDLEVBQTRDLEVBQTVDLENBRlA7O0FBSWI7QUFDQUMsV0FBUyxJQUxJOztBQU9iQyxTQUFPLGVBQVVDLEdBQVYsRUFBZ0I7QUFDdEIsU0FBTSxJQUFJM0UsS0FBSixDQUFXMkUsR0FBWCxDQUFOO0FBQ0EsR0FUWTs7QUFXYkMsUUFBTSxnQkFBVyxDQUFFLENBWE47O0FBYWI7QUFDQTtBQUNBO0FBQ0FYLGNBQVksb0JBQVVZLEdBQVYsRUFBZ0I7QUFDM0IsVUFBTzlELE9BQU8rRCxJQUFQLENBQVlELEdBQVosTUFBcUIsVUFBNUI7QUFDQSxHQWxCWTs7QUFvQmJWLFdBQVNZLE1BQU1aLE9BQU4sSUFBaUIsVUFBVVUsR0FBVixFQUFnQjtBQUN6QyxVQUFPOUQsT0FBTytELElBQVAsQ0FBWUQsR0FBWixNQUFxQixPQUE1QjtBQUNBLEdBdEJZOztBQXdCYkcsWUFBVSxrQkFBVUgsR0FBVixFQUFnQjtBQUN6QjtBQUNBLFVBQU9BLE9BQU8sSUFBUCxJQUFlQSxPQUFPQSxJQUFJNUUsTUFBakM7QUFDQSxHQTNCWTs7QUE2QmJnRixhQUFXLG1CQUFVSixHQUFWLEVBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQU9BLE1BQU1LLFdBQVlMLEdBQVosQ0FBTixJQUEyQixDQUFsQztBQUNBLEdBbENZOztBQW9DYk0saUJBQWUsdUJBQVVOLEdBQVYsRUFBZ0I7QUFDOUIsT0FBSWpCLElBQUo7QUFDQSxRQUFNQSxJQUFOLElBQWNpQixHQUFkLEVBQW9CO0FBQ25CLFdBQU8sS0FBUDtBQUNBO0FBQ0QsVUFBTyxJQUFQO0FBQ0EsR0ExQ1k7O0FBNENiWCxpQkFBZSx1QkFBVVcsR0FBVixFQUFnQjtBQUM5QixPQUFJTyxHQUFKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQUssQ0FBQ1AsR0FBRCxJQUFROUQsT0FBTytELElBQVAsQ0FBWUQsR0FBWixNQUFxQixRQUE3QixJQUF5Q0EsSUFBSVEsUUFBN0MsSUFBeUR0RSxPQUFPaUUsUUFBUCxDQUFpQkgsR0FBakIsQ0FBOUQsRUFBdUY7QUFDdEYsV0FBTyxLQUFQO0FBQ0E7O0FBRUQsT0FBSTtBQUNIO0FBQ0EsUUFBS0EsSUFBSWhELFdBQUosSUFDSixDQUFDbkIsT0FBT3NCLElBQVAsQ0FBWTZDLEdBQVosRUFBaUIsYUFBakIsQ0FERyxJQUVKLENBQUNuRSxPQUFPc0IsSUFBUCxDQUFZNkMsSUFBSWhELFdBQUosQ0FBZ0JGLFNBQTVCLEVBQXVDLGVBQXZDLENBRkYsRUFFNEQ7QUFDM0QsWUFBTyxLQUFQO0FBQ0E7QUFDRCxJQVBELENBT0UsT0FBUTJELENBQVIsRUFBWTtBQUNiO0FBQ0EsV0FBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLE9BQUt6RSxRQUFRMEUsT0FBYixFQUF1QjtBQUN0QixTQUFNSCxHQUFOLElBQWFQLEdBQWIsRUFBbUI7QUFDbEIsWUFBT25FLE9BQU9zQixJQUFQLENBQWE2QyxHQUFiLEVBQWtCTyxHQUFsQixDQUFQO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsUUFBTUEsR0FBTixJQUFhUCxHQUFiLEVBQW1CLENBQUU7O0FBRXJCLFVBQU9PLFFBQVFoQixTQUFSLElBQXFCMUQsT0FBT3NCLElBQVAsQ0FBYTZDLEdBQWIsRUFBa0JPLEdBQWxCLENBQTVCO0FBQ0EsR0EvRVk7O0FBaUZiTixRQUFNLGNBQVVELEdBQVYsRUFBZ0I7QUFDckIsT0FBS0EsT0FBTyxJQUFaLEVBQW1CO0FBQ2xCLFdBQU9BLE1BQU0sRUFBYjtBQUNBO0FBQ0QsVUFBTyxRQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBZixJQUEyQixPQUFPQSxHQUFQLEtBQWUsVUFBMUMsR0FDTnJFLFdBQVlDLFNBQVN1QixJQUFULENBQWM2QyxHQUFkLENBQVosS0FBb0MsUUFEOUIsVUFFQ0EsR0FGRCx5Q0FFQ0EsR0FGRCxDQUFQO0FBR0EsR0F4Rlk7O0FBMEZiO0FBQ0E7QUFDQTtBQUNBVyxjQUFZLG9CQUFVQyxJQUFWLEVBQWlCO0FBQzVCLE9BQUtBLFFBQVExRSxPQUFPSCxJQUFQLENBQWE2RSxJQUFiLENBQWIsRUFBbUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsS0FBRXhGLE9BQU95RixVQUFQLElBQXFCLFVBQVVELElBQVYsRUFBaUI7QUFDdkN4RixZQUFRLE1BQVIsRUFBaUIrQixJQUFqQixDQUF1Qi9CLE1BQXZCLEVBQStCd0YsSUFBL0I7QUFDQSxLQUZELEVBRUtBLElBRkw7QUFHQTtBQUNELEdBdEdZOztBQXdHYjtBQUNBO0FBQ0FFLGFBQVcsbUJBQVVDLE1BQVYsRUFBbUI7QUFDN0IsVUFBT0EsT0FBT3BCLE9BQVAsQ0FBZ0JuRCxTQUFoQixFQUEyQixLQUEzQixFQUFtQ21ELE9BQW5DLENBQTRDbEQsVUFBNUMsRUFBd0RDLFVBQXhELENBQVA7QUFDQSxHQTVHWTs7QUE4R2JzRSxZQUFVLGtCQUFVakQsSUFBVixFQUFnQmdCLElBQWhCLEVBQXVCO0FBQ2hDLFVBQU9oQixLQUFLaUQsUUFBTCxJQUFpQmpELEtBQUtpRCxRQUFMLENBQWNDLFdBQWQsT0FBZ0NsQyxLQUFLa0MsV0FBTCxFQUF4RDtBQUNBLEdBaEhZOztBQWtIYjtBQUNBdEQsUUFBTSxjQUFVcUMsR0FBVixFQUFlcEMsUUFBZixFQUF5QkMsSUFBekIsRUFBZ0M7QUFDckMsT0FBSXFELEtBQUo7QUFBQSxPQUNDbEQsSUFBSSxDQURMO0FBQUEsT0FFQ2YsU0FBUytDLElBQUkvQyxNQUZkO0FBQUEsT0FHQ3FDLFVBQVU2QixZQUFhbkIsR0FBYixDQUhYOztBQUtBLE9BQUtuQyxJQUFMLEVBQVk7QUFDWCxRQUFLeUIsT0FBTCxFQUFlO0FBQ2QsWUFBUXRCLElBQUlmLE1BQVosRUFBb0JlLEdBQXBCLEVBQTBCO0FBQ3pCa0QsY0FBUXRELFNBQVNLLEtBQVQsQ0FBZ0IrQixJQUFLaEMsQ0FBTCxDQUFoQixFQUEwQkgsSUFBMUIsQ0FBUjs7QUFFQSxVQUFLcUQsVUFBVSxLQUFmLEVBQXVCO0FBQ3RCO0FBQ0E7QUFDRDtBQUNELEtBUkQsTUFRTztBQUNOLFVBQU1sRCxDQUFOLElBQVdnQyxHQUFYLEVBQWlCO0FBQ2hCa0IsY0FBUXRELFNBQVNLLEtBQVQsQ0FBZ0IrQixJQUFLaEMsQ0FBTCxDQUFoQixFQUEwQkgsSUFBMUIsQ0FBUjs7QUFFQSxVQUFLcUQsVUFBVSxLQUFmLEVBQXVCO0FBQ3RCO0FBQ0E7QUFDRDtBQUNEOztBQUVGO0FBQ0MsSUFwQkQsTUFvQk87QUFDTixRQUFLNUIsT0FBTCxFQUFlO0FBQ2QsWUFBUXRCLElBQUlmLE1BQVosRUFBb0JlLEdBQXBCLEVBQTBCO0FBQ3pCa0QsY0FBUXRELFNBQVNULElBQVQsQ0FBZTZDLElBQUtoQyxDQUFMLENBQWYsRUFBeUJBLENBQXpCLEVBQTRCZ0MsSUFBS2hDLENBQUwsQ0FBNUIsQ0FBUjs7QUFFQSxVQUFLa0QsVUFBVSxLQUFmLEVBQXVCO0FBQ3RCO0FBQ0E7QUFDRDtBQUNELEtBUkQsTUFRTztBQUNOLFVBQU1sRCxDQUFOLElBQVdnQyxHQUFYLEVBQWlCO0FBQ2hCa0IsY0FBUXRELFNBQVNULElBQVQsQ0FBZTZDLElBQUtoQyxDQUFMLENBQWYsRUFBeUJBLENBQXpCLEVBQTRCZ0MsSUFBS2hDLENBQUwsQ0FBNUIsQ0FBUjs7QUFFQSxVQUFLa0QsVUFBVSxLQUFmLEVBQXVCO0FBQ3RCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsVUFBT2xCLEdBQVA7QUFDQSxHQWxLWTs7QUFvS2I7QUFDQWpFLFFBQU1BLFFBQVEsQ0FBQ0EsS0FBS29CLElBQUwsQ0FBVSxZQUFWLENBQVQsR0FDTCxVQUFVaUUsSUFBVixFQUFpQjtBQUNoQixVQUFPQSxRQUFRLElBQVIsR0FDTixFQURNLEdBRU5yRixLQUFLb0IsSUFBTCxDQUFXaUUsSUFBWCxDQUZEO0FBR0EsR0FMSTs7QUFPTDtBQUNBLFlBQVVBLElBQVYsRUFBaUI7QUFDaEIsVUFBT0EsUUFBUSxJQUFSLEdBQ04sRUFETSxHQUVOLENBQUVBLE9BQU8sRUFBVCxFQUFjekIsT0FBZCxDQUF1QnBELEtBQXZCLEVBQThCLEVBQTlCLENBRkQ7QUFHQSxHQWpMVzs7QUFtTGI7QUFDQThFLGFBQVcsbUJBQVVDLEdBQVYsRUFBZUMsT0FBZixFQUF5QjtBQUNuQyxPQUFJL0QsTUFBTStELFdBQVcsRUFBckI7O0FBRUEsT0FBS0QsT0FBTyxJQUFaLEVBQW1CO0FBQ2xCLFFBQUtILFlBQWFLLE9BQU9GLEdBQVAsQ0FBYixDQUFMLEVBQWtDO0FBQ2pDcEYsWUFBT3VCLEtBQVAsQ0FBY0QsR0FBZCxFQUNDLE9BQU84RCxHQUFQLEtBQWUsUUFBZixHQUNBLENBQUVBLEdBQUYsQ0FEQSxHQUNVQSxHQUZYO0FBSUEsS0FMRCxNQUtPO0FBQ043RixVQUFLMEIsSUFBTCxDQUFXSyxHQUFYLEVBQWdCOEQsR0FBaEI7QUFDQTtBQUNEOztBQUVELFVBQU85RCxHQUFQO0FBQ0EsR0FuTVk7O0FBcU1iaUUsV0FBUyxpQkFBVTFELElBQVYsRUFBZ0J1RCxHQUFoQixFQUFxQnRELENBQXJCLEVBQXlCO0FBQ2pDLE9BQUlNLEdBQUo7O0FBRUEsT0FBS2dELEdBQUwsRUFBVztBQUNWLFFBQUs1RixPQUFMLEVBQWU7QUFDZCxZQUFPQSxRQUFReUIsSUFBUixDQUFjbUUsR0FBZCxFQUFtQnZELElBQW5CLEVBQXlCQyxDQUF6QixDQUFQO0FBQ0E7O0FBRURNLFVBQU1nRCxJQUFJckUsTUFBVjtBQUNBZSxRQUFJQSxJQUFJQSxJQUFJLENBQUosR0FBUXlCLEtBQUtpQyxHQUFMLENBQVUsQ0FBVixFQUFhcEQsTUFBTU4sQ0FBbkIsQ0FBUixHQUFpQ0EsQ0FBckMsR0FBeUMsQ0FBN0M7O0FBRUEsV0FBUUEsSUFBSU0sR0FBWixFQUFpQk4sR0FBakIsRUFBdUI7QUFDdEI7QUFDQSxTQUFLQSxLQUFLc0QsR0FBTCxJQUFZQSxJQUFLdEQsQ0FBTCxNQUFhRCxJQUE5QixFQUFxQztBQUNwQyxhQUFPQyxDQUFQO0FBQ0E7QUFDRDtBQUNEOztBQUVELFVBQU8sQ0FBQyxDQUFSO0FBQ0EsR0F6Tlk7O0FBMk5iUCxTQUFPLGVBQVVVLEtBQVYsRUFBaUJ3RCxNQUFqQixFQUEwQjtBQUNoQyxPQUFJckQsTUFBTSxDQUFDcUQsT0FBTzFFLE1BQWxCO0FBQUEsT0FDQ3NCLElBQUksQ0FETDtBQUFBLE9BRUNQLElBQUlHLE1BQU1sQixNQUZYOztBQUlBLFVBQVFzQixJQUFJRCxHQUFaLEVBQWtCO0FBQ2pCSCxVQUFPSCxHQUFQLElBQWUyRCxPQUFRcEQsR0FBUixDQUFmO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLE9BQUtELFFBQVFBLEdBQWIsRUFBbUI7QUFDbEIsV0FBUXFELE9BQU9wRCxDQUFQLE1BQWNnQixTQUF0QixFQUFrQztBQUNqQ3BCLFdBQU9ILEdBQVAsSUFBZTJELE9BQVFwRCxHQUFSLENBQWY7QUFDQTtBQUNEOztBQUVESixTQUFNbEIsTUFBTixHQUFlZSxDQUFmOztBQUVBLFVBQU9HLEtBQVA7QUFDQSxHQS9PWTs7QUFpUGJ5RCxRQUFNLGNBQVVyRSxLQUFWLEVBQWlCSyxRQUFqQixFQUEyQmlFLE1BQTNCLEVBQW9DO0FBQ3pDLE9BQUlDLGVBQUo7QUFBQSxPQUNDQyxVQUFVLEVBRFg7QUFBQSxPQUVDL0QsSUFBSSxDQUZMO0FBQUEsT0FHQ2YsU0FBU00sTUFBTU4sTUFIaEI7QUFBQSxPQUlDK0UsaUJBQWlCLENBQUNILE1BSm5COztBQU1BO0FBQ0E7QUFDQSxVQUFRN0QsSUFBSWYsTUFBWixFQUFvQmUsR0FBcEIsRUFBMEI7QUFDekI4RCxzQkFBa0IsQ0FBQ2xFLFNBQVVMLE1BQU9TLENBQVAsQ0FBVixFQUFzQkEsQ0FBdEIsQ0FBbkI7QUFDQSxRQUFLOEQsb0JBQW9CRSxjQUF6QixFQUEwQztBQUN6Q0QsYUFBUXRHLElBQVIsQ0FBYzhCLE1BQU9TLENBQVAsQ0FBZDtBQUNBO0FBQ0Q7O0FBRUQsVUFBTytELE9BQVA7QUFDQSxHQWxRWTs7QUFvUWI7QUFDQWpFLE9BQUssYUFBVVAsS0FBVixFQUFpQkssUUFBakIsRUFBMkJxRSxHQUEzQixFQUFpQztBQUNyQyxPQUFJZixLQUFKO0FBQUEsT0FDQ2xELElBQUksQ0FETDtBQUFBLE9BRUNmLFNBQVNNLE1BQU1OLE1BRmhCO0FBQUEsT0FHQ3FDLFVBQVU2QixZQUFhNUQsS0FBYixDQUhYO0FBQUEsT0FJQ0MsTUFBTSxFQUpQOztBQU1BO0FBQ0EsT0FBSzhCLE9BQUwsRUFBZTtBQUNkLFdBQVF0QixJQUFJZixNQUFaLEVBQW9CZSxHQUFwQixFQUEwQjtBQUN6QmtELGFBQVF0RCxTQUFVTCxNQUFPUyxDQUFQLENBQVYsRUFBc0JBLENBQXRCLEVBQXlCaUUsR0FBekIsQ0FBUjs7QUFFQSxTQUFLZixTQUFTLElBQWQsRUFBcUI7QUFDcEIxRCxVQUFJL0IsSUFBSixDQUFVeUYsS0FBVjtBQUNBO0FBQ0Q7O0FBRUY7QUFDQyxJQVZELE1BVU87QUFDTixTQUFNbEQsQ0FBTixJQUFXVCxLQUFYLEVBQW1CO0FBQ2xCMkQsYUFBUXRELFNBQVVMLE1BQU9TLENBQVAsQ0FBVixFQUFzQkEsQ0FBdEIsRUFBeUJpRSxHQUF6QixDQUFSOztBQUVBLFNBQUtmLFNBQVMsSUFBZCxFQUFxQjtBQUNwQjFELFVBQUkvQixJQUFKLENBQVV5RixLQUFWO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0EsVUFBTzFGLE9BQU95QyxLQUFQLENBQWMsRUFBZCxFQUFrQlQsR0FBbEIsQ0FBUDtBQUNBLEdBblNZOztBQXFTYjtBQUNBMEUsUUFBTSxDQXRTTzs7QUF3U2I7QUFDQTtBQUNBQyxTQUFPLGVBQVU5RixFQUFWLEVBQWNELE9BQWQsRUFBd0I7QUFDOUIsT0FBSXlCLElBQUosRUFBVXNFLEtBQVYsRUFBaUJDLEdBQWpCOztBQUVBLE9BQUssT0FBT2hHLE9BQVAsS0FBbUIsUUFBeEIsRUFBbUM7QUFDbENnRyxVQUFNL0YsR0FBSUQsT0FBSixDQUFOO0FBQ0FBLGNBQVVDLEVBQVY7QUFDQUEsU0FBSytGLEdBQUw7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsT0FBSyxDQUFDbEcsT0FBT2tELFVBQVAsQ0FBbUIvQyxFQUFuQixDQUFOLEVBQWdDO0FBQy9CLFdBQU9rRCxTQUFQO0FBQ0E7O0FBRUQ7QUFDQTFCLFVBQU90QyxPQUFNNEIsSUFBTixDQUFZZSxTQUFaLEVBQXVCLENBQXZCLENBQVA7QUFDQWlFLFdBQVEsaUJBQVc7QUFDbEIsV0FBTzlGLEdBQUc0QixLQUFILENBQVU3QixXQUFXLElBQXJCLEVBQTJCeUIsS0FBS3JDLE1BQUwsQ0FBYUQsT0FBTTRCLElBQU4sQ0FBWWUsU0FBWixDQUFiLENBQTNCLENBQVA7QUFDQSxJQUZEOztBQUlBO0FBQ0FpRSxTQUFNRCxJQUFOLEdBQWE3RixHQUFHNkYsSUFBSCxHQUFVN0YsR0FBRzZGLElBQUgsSUFBV2hHLE9BQU9nRyxJQUFQLEVBQWxDOztBQUVBLFVBQU9DLEtBQVA7QUFDQSxHQW5VWTs7QUFxVWJFLE9BQUssZUFBVztBQUNmLFVBQU8sQ0FBRyxJQUFJQyxJQUFKLEVBQVY7QUFDQSxHQXZVWTs7QUF5VWI7QUFDQTtBQUNBdEcsV0FBU0E7QUEzVUksRUFBZDs7QUE4VUE7QUFDQUUsUUFBT3lCLElBQVAsQ0FBWSxnRUFBZ0U0RSxLQUFoRSxDQUFzRSxHQUF0RSxDQUFaLEVBQXdGLFVBQVN2RSxDQUFULEVBQVllLElBQVosRUFBa0I7QUFDekdwRCxhQUFZLGFBQWFvRCxJQUFiLEdBQW9CLEdBQWhDLElBQXdDQSxLQUFLa0MsV0FBTCxFQUF4QztBQUNBLEVBRkQ7O0FBSUEsVUFBU0UsV0FBVCxDQUFzQm5CLEdBQXRCLEVBQTRCO0FBQzNCLE1BQUkvQyxTQUFTK0MsSUFBSS9DLE1BQWpCO0FBQUEsTUFDQ2dELE9BQU8vRCxPQUFPK0QsSUFBUCxDQUFhRCxHQUFiLENBRFI7O0FBR0EsTUFBS0MsU0FBUyxVQUFULElBQXVCL0QsT0FBT2lFLFFBQVAsQ0FBaUJILEdBQWpCLENBQTVCLEVBQXFEO0FBQ3BELFVBQU8sS0FBUDtBQUNBOztBQUVELE1BQUtBLElBQUlRLFFBQUosS0FBaUIsQ0FBakIsSUFBc0J2RCxNQUEzQixFQUFvQztBQUNuQyxVQUFPLElBQVA7QUFDQTs7QUFFRCxTQUFPZ0QsU0FBUyxPQUFULElBQW9CaEQsV0FBVyxDQUEvQixJQUNOLE9BQU9BLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEJBLFNBQVMsQ0FBdkMsSUFBOENBLFNBQVMsQ0FBWCxJQUFrQitDLEdBRC9EO0FBRUE7QUFDRCxLQUFJd0M7QUFDSjs7Ozs7Ozs7OztBQVVDLFdBQVVwSCxNQUFWLEVBQW1COztBQUVwQixNQUFJNEMsQ0FBSjtBQUFBLE1BQ0NoQyxPQUREO0FBQUEsTUFFQ3lHLElBRkQ7QUFBQSxNQUdDQyxPQUhEO0FBQUEsTUFJQ0MsS0FKRDtBQUFBLE1BS0NDLE9BTEQ7QUFBQSxNQU1DQyxnQkFORDtBQUFBLE1BT0NDLFNBUEQ7QUFBQSxNQVFDQyxZQVJEOzs7QUFVQztBQUNBQyxhQVhEO0FBQUEsTUFZQy9ILFFBWkQ7QUFBQSxNQWFDZ0ksT0FiRDtBQUFBLE1BY0NDLGNBZEQ7QUFBQSxNQWVDQyxTQWZEO0FBQUEsTUFnQkNDLGFBaEJEO0FBQUEsTUFpQkNyQixPQWpCRDtBQUFBLE1Ba0JDc0IsUUFsQkQ7OztBQW9CQztBQUNBN0QsWUFBVSxXQUFXLENBQUUsSUFBSThDLElBQUosRUFyQnhCO0FBQUEsTUFzQkNnQixlQUFlbEksT0FBT0gsUUF0QnZCO0FBQUEsTUF1QkNzSSxVQUFVLENBdkJYO0FBQUEsTUF3QkNDLE9BQU8sQ0F4QlI7QUFBQSxNQXlCQ0MsYUFBYUMsYUF6QmQ7QUFBQSxNQTBCQ0MsYUFBYUQsYUExQmQ7QUFBQSxNQTJCQ0UsZ0JBQWdCRixhQTNCakI7QUFBQSxNQTRCQ0csWUFBWSxtQkFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWlCO0FBQzVCLE9BQUtELE1BQU1DLENBQVgsRUFBZTtBQUNkaEIsbUJBQWUsSUFBZjtBQUNBO0FBQ0QsVUFBTyxDQUFQO0FBQ0EsR0FqQ0Y7OztBQW1DQztBQUNBaUIsaUJBQUEsOEJBQXNCekUsU0FBdEIsQ0FwQ0Q7QUFBQSxNQXFDQzBFLGVBQWUsS0FBSyxFQXJDckI7OztBQXVDQztBQUNBcEksV0FBVSxFQUFELENBQUtDLGNBeENmO0FBQUEsTUF5Q0N3RixNQUFNLEVBekNQO0FBQUEsTUEwQ0M0QyxNQUFNNUMsSUFBSTRDLEdBMUNYO0FBQUEsTUEyQ0NDLGNBQWM3QyxJQUFJN0YsSUEzQ25CO0FBQUEsTUE0Q0NBLE9BQU82RixJQUFJN0YsSUE1Q1o7QUFBQSxNQTZDQ0YsUUFBUStGLElBQUkvRixLQTdDYjs7QUE4Q0M7QUFDQUcsWUFBVTRGLElBQUk1RixPQUFKLElBQWUsVUFBVXFDLElBQVYsRUFBaUI7QUFDekMsT0FBSUMsSUFBSSxDQUFSO0FBQUEsT0FDQ00sTUFBTSxLQUFLckIsTUFEWjtBQUVBLFVBQVFlLElBQUlNLEdBQVosRUFBaUJOLEdBQWpCLEVBQXVCO0FBQ3RCLFFBQUssS0FBS0EsQ0FBTCxNQUFZRCxJQUFqQixFQUF3QjtBQUN2QixZQUFPQyxDQUFQO0FBQ0E7QUFDRDtBQUNELFVBQU8sQ0FBQyxDQUFSO0FBQ0EsR0F4REY7QUFBQSxNQTBEQ29HLFdBQVcsNEhBMURaOzs7QUE0REM7O0FBRUE7QUFDQUMsZUFBYSxxQkEvRGQ7O0FBZ0VDO0FBQ0FDLHNCQUFvQixrQ0FqRXJCOzs7QUFtRUM7QUFDQTtBQUNBO0FBQ0FDLGVBQWFELGtCQUFrQjNFLE9BQWxCLENBQTJCLEdBQTNCLEVBQWdDLElBQWhDLENBdEVkOzs7QUF3RUM7QUFDQTZFLGVBQWEsUUFBUUgsVUFBUixHQUFxQixJQUFyQixHQUE0QkMsaUJBQTVCLEdBQWdELEdBQWhELEdBQXNERCxVQUF0RCxHQUNaLGtCQURZLEdBQ1NBLFVBRFQsR0FDc0IsdUNBRHRCLEdBQ2dFRSxVQURoRSxHQUM2RSxPQUQ3RSxHQUN1RkYsVUFEdkYsR0FDb0csTUExRWxIOzs7QUE0RUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FJLFlBQVUsT0FBT0gsaUJBQVAsR0FBMkIsa0VBQTNCLEdBQWdHRSxXQUFXN0UsT0FBWCxDQUFvQixDQUFwQixFQUF1QixDQUF2QixDQUFoRyxHQUE2SCxjQWxGeEk7OztBQW9GQztBQUNBcEQsVUFBUSxJQUFJbUksTUFBSixDQUFZLE1BQU1MLFVBQU4sR0FBbUIsNkJBQW5CLEdBQW1EQSxVQUFuRCxHQUFnRSxJQUE1RSxFQUFrRixHQUFsRixDQXJGVDtBQUFBLE1BdUZDTSxTQUFTLElBQUlELE1BQUosQ0FBWSxNQUFNTCxVQUFOLEdBQW1CLElBQW5CLEdBQTBCQSxVQUExQixHQUF1QyxHQUFuRCxDQXZGVjtBQUFBLE1Bd0ZDTyxlQUFlLElBQUlGLE1BQUosQ0FBWSxNQUFNTCxVQUFOLEdBQW1CLFVBQW5CLEdBQWdDQSxVQUFoQyxHQUE2QyxHQUE3QyxHQUFtREEsVUFBbkQsR0FBZ0UsR0FBNUUsQ0F4RmhCO0FBQUEsTUEwRkNRLG1CQUFtQixJQUFJSCxNQUFKLENBQVksTUFBTUwsVUFBTixHQUFtQixnQkFBbkIsR0FBc0NBLFVBQXRDLEdBQW1ELE1BQS9ELEVBQXVFLEdBQXZFLENBMUZwQjtBQUFBLE1BNEZDUyxVQUFVLElBQUlKLE1BQUosQ0FBWUQsT0FBWixDQTVGWDtBQUFBLE1BNkZDTSxjQUFjLElBQUlMLE1BQUosQ0FBWSxNQUFNSCxVQUFOLEdBQW1CLEdBQS9CLENBN0ZmO0FBQUEsTUErRkNTLFlBQVk7QUFDWCxTQUFNLElBQUlOLE1BQUosQ0FBWSxRQUFRSixpQkFBUixHQUE0QixHQUF4QyxDQURLO0FBRVgsWUFBUyxJQUFJSSxNQUFKLENBQVksVUFBVUosaUJBQVYsR0FBOEIsR0FBMUMsQ0FGRTtBQUdYLFVBQU8sSUFBSUksTUFBSixDQUFZLE9BQU9KLGtCQUFrQjNFLE9BQWxCLENBQTJCLEdBQTNCLEVBQWdDLElBQWhDLENBQVAsR0FBZ0QsR0FBNUQsQ0FISTtBQUlYLFdBQVEsSUFBSStFLE1BQUosQ0FBWSxNQUFNRixVQUFsQixDQUpHO0FBS1gsYUFBVSxJQUFJRSxNQUFKLENBQVksTUFBTUQsT0FBbEIsQ0FMQztBQU1YLFlBQVMsSUFBSUMsTUFBSixDQUFZLDJEQUEyREwsVUFBM0QsR0FDcEIsOEJBRG9CLEdBQ2FBLFVBRGIsR0FDMEIsYUFEMUIsR0FDMENBLFVBRDFDLEdBRXBCLFlBRm9CLEdBRUxBLFVBRkssR0FFUSxRQUZwQixFQUU4QixHQUY5QixDQU5FO0FBU1gsV0FBUSxJQUFJSyxNQUFKLENBQVksU0FBU04sUUFBVCxHQUFvQixJQUFoQyxFQUFzQyxHQUF0QyxDQVRHO0FBVVg7QUFDQTtBQUNBLG1CQUFnQixJQUFJTSxNQUFKLENBQVksTUFBTUwsVUFBTixHQUFtQixrREFBbkIsR0FDM0JBLFVBRDJCLEdBQ2Qsa0JBRGMsR0FDT0EsVUFEUCxHQUNvQixrQkFEaEMsRUFDb0QsR0FEcEQ7QUFaTCxHQS9GYjtBQUFBLE1BK0dDWSxVQUFVLHFDQS9HWDtBQUFBLE1BZ0hDQyxVQUFVLFFBaEhYO0FBQUEsTUFrSENDLFVBQVUsd0JBbEhYOzs7QUFvSEM7QUFDQUMsZUFBYSxrQ0FySGQ7QUFBQSxNQXVIQ0MsV0FBVyxNQXZIWjtBQUFBLE1Bd0hDQyxVQUFVLE9BeEhYOzs7QUEwSEM7QUFDQUMsY0FBWSxJQUFJYixNQUFKLENBQVksdUJBQXVCTCxVQUF2QixHQUFvQyxLQUFwQyxHQUE0Q0EsVUFBNUMsR0FBeUQsTUFBckUsRUFBNkUsSUFBN0UsQ0EzSGI7QUFBQSxNQTRIQ21CLFlBQVksU0FBWkEsU0FBWSxDQUFVQyxDQUFWLEVBQWFDLE9BQWIsRUFBc0JDLGlCQUF0QixFQUEwQztBQUNyRCxPQUFJQyxPQUFPLE9BQU9GLE9BQVAsR0FBaUIsT0FBNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFPRSxTQUFTQSxJQUFULElBQWlCRCxpQkFBakIsR0FDTkQsT0FETSxHQUVORSxPQUFPLENBQVA7QUFDQztBQUNBQyxVQUFPQyxZQUFQLENBQXFCRixPQUFPLE9BQTVCLENBRkQ7QUFHQztBQUNBQyxVQUFPQyxZQUFQLENBQXFCRixRQUFRLEVBQVIsR0FBYSxNQUFsQyxFQUEwQ0EsT0FBTyxLQUFQLEdBQWUsTUFBekQsQ0FORjtBQU9BLEdBeElGOztBQTBJQTtBQUNBLE1BQUk7QUFDSG5LLFFBQUt3QyxLQUFMLENBQ0VxRCxNQUFNL0YsTUFBTTRCLElBQU4sQ0FBWW1HLGFBQWF5QyxVQUF6QixDQURSLEVBRUN6QyxhQUFheUMsVUFGZDtBQUlBO0FBQ0E7QUFDQXpFLE9BQUtnQyxhQUFheUMsVUFBYixDQUF3QjlJLE1BQTdCLEVBQXNDdUQsUUFBdEM7QUFDQSxHQVJELENBUUUsT0FBUUMsQ0FBUixFQUFZO0FBQ2JoRixVQUFPLEVBQUV3QyxPQUFPcUQsSUFBSXJFLE1BQUo7O0FBRWY7QUFDQSxjQUFVaUMsTUFBVixFQUFrQjhHLEdBQWxCLEVBQXdCO0FBQ3ZCN0IsaUJBQVlsRyxLQUFaLENBQW1CaUIsTUFBbkIsRUFBMkIzRCxNQUFNNEIsSUFBTixDQUFXNkksR0FBWCxDQUEzQjtBQUNBLEtBTGM7O0FBT2Y7QUFDQTtBQUNBLGNBQVU5RyxNQUFWLEVBQWtCOEcsR0FBbEIsRUFBd0I7QUFDdkIsU0FBSXpILElBQUlXLE9BQU9qQyxNQUFmO0FBQUEsU0FDQ2UsSUFBSSxDQURMO0FBRUE7QUFDQSxZQUFTa0IsT0FBT1gsR0FBUCxJQUFjeUgsSUFBSWhJLEdBQUosQ0FBdkIsRUFBbUMsQ0FBRTtBQUNyQ2tCLFlBQU9qQyxNQUFQLEdBQWdCc0IsSUFBSSxDQUFwQjtBQUNBO0FBZkssSUFBUDtBQWlCQTs7QUFFRCxXQUFTaUUsTUFBVCxDQUFpQnJHLFFBQWpCLEVBQTJCQyxPQUEzQixFQUFvQ21GLE9BQXBDLEVBQTZDMEUsSUFBN0MsRUFBb0Q7QUFDbkQsT0FBSUMsS0FBSixFQUFXbkksSUFBWCxFQUFpQm9JLENBQWpCLEVBQW9CM0YsUUFBcEI7QUFDQztBQUNBeEMsSUFGRCxFQUVJb0ksTUFGSixFQUVZQyxHQUZaLEVBRWlCQyxHQUZqQixFQUVzQkMsVUFGdEIsRUFFa0NDLFdBRmxDOztBQUlBLE9BQUssQ0FBRXBLLFVBQVVBLFFBQVFxSyxhQUFSLElBQXlCckssT0FBbkMsR0FBNkNrSCxZQUEvQyxNQUFrRXJJLFFBQXZFLEVBQWtGO0FBQ2pGK0gsZ0JBQWE1RyxPQUFiO0FBQ0E7O0FBRURBLGFBQVVBLFdBQVduQixRQUFyQjtBQUNBc0csYUFBVUEsV0FBVyxFQUFyQjs7QUFFQSxPQUFLLENBQUNwRixRQUFELElBQWEsT0FBT0EsUUFBUCxLQUFvQixRQUF0QyxFQUFpRDtBQUNoRCxXQUFPb0YsT0FBUDtBQUNBOztBQUVELE9BQUssQ0FBQ2YsV0FBV3BFLFFBQVFvRSxRQUFwQixNQUFrQyxDQUFsQyxJQUF1Q0EsYUFBYSxDQUF6RCxFQUE2RDtBQUM1RCxXQUFPLEVBQVA7QUFDQTs7QUFFRCxPQUFLMEMsa0JBQWtCLENBQUMrQyxJQUF4QixFQUErQjs7QUFFOUI7QUFDQSxRQUFNQyxRQUFRZCxXQUFXc0IsSUFBWCxDQUFpQnZLLFFBQWpCLENBQWQsRUFBNkM7QUFDNUM7QUFDQSxTQUFNZ0ssSUFBSUQsTUFBTSxDQUFOLENBQVYsRUFBc0I7QUFDckIsVUFBSzFGLGFBQWEsQ0FBbEIsRUFBc0I7QUFDckJ6QyxjQUFPM0IsUUFBUXVLLGNBQVIsQ0FBd0JSLENBQXhCLENBQVA7QUFDQTtBQUNBO0FBQ0EsV0FBS3BJLFFBQVFBLEtBQUs2SSxVQUFsQixFQUErQjtBQUM5QjtBQUNBO0FBQ0EsWUFBSzdJLEtBQUs4SSxFQUFMLEtBQVlWLENBQWpCLEVBQXFCO0FBQ3BCNUUsaUJBQVE5RixJQUFSLENBQWNzQyxJQUFkO0FBQ0EsZ0JBQU93RCxPQUFQO0FBQ0E7QUFDRCxRQVBELE1BT087QUFDTixlQUFPQSxPQUFQO0FBQ0E7QUFDRCxPQWRELE1BY087QUFDTjtBQUNBLFdBQUtuRixRQUFRcUssYUFBUixLQUEwQjFJLE9BQU8zQixRQUFRcUssYUFBUixDQUFzQkUsY0FBdEIsQ0FBc0NSLENBQXRDLENBQWpDLEtBQ0o5QyxTQUFVakgsT0FBVixFQUFtQjJCLElBQW5CLENBREksSUFDeUJBLEtBQUs4SSxFQUFMLEtBQVlWLENBRDFDLEVBQzhDO0FBQzdDNUUsZ0JBQVE5RixJQUFSLENBQWNzQyxJQUFkO0FBQ0EsZUFBT3dELE9BQVA7QUFDQTtBQUNEOztBQUVGO0FBQ0MsTUF6QkQsTUF5Qk8sSUFBSzJFLE1BQU0sQ0FBTixDQUFMLEVBQWdCO0FBQ3RCekssV0FBS3dDLEtBQUwsQ0FBWXNELE9BQVosRUFBcUJuRixRQUFRMEssb0JBQVIsQ0FBOEIzSyxRQUE5QixDQUFyQjtBQUNBLGFBQU9vRixPQUFQOztBQUVEO0FBQ0MsTUFMTSxNQUtBLElBQUssQ0FBQzRFLElBQUlELE1BQU0sQ0FBTixDQUFMLEtBQWtCbEssUUFBUStLLHNCQUExQixJQUFvRDNLLFFBQVEySyxzQkFBakUsRUFBMEY7QUFDaEd0TCxXQUFLd0MsS0FBTCxDQUFZc0QsT0FBWixFQUFxQm5GLFFBQVEySyxzQkFBUixDQUFnQ1osQ0FBaEMsQ0FBckI7QUFDQSxhQUFPNUUsT0FBUDtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFLdkYsUUFBUWdMLEdBQVIsS0FBZ0IsQ0FBQzdELFNBQUQsSUFBYyxDQUFDQSxVQUFVOEQsSUFBVixDQUFnQjlLLFFBQWhCLENBQS9CLENBQUwsRUFBa0U7QUFDakVtSyxXQUFNRCxNQUFNN0csT0FBWjtBQUNBK0csa0JBQWFuSyxPQUFiO0FBQ0FvSyxtQkFBY2hHLGFBQWEsQ0FBYixJQUFrQnJFLFFBQWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBS3FFLGFBQWEsQ0FBYixJQUFrQnBFLFFBQVE0RSxRQUFSLENBQWlCQyxXQUFqQixPQUFtQyxRQUExRCxFQUFxRTtBQUNwRW1GLGVBQVNjLFNBQVUvSyxRQUFWLENBQVQ7O0FBRUEsVUFBTWtLLE1BQU1qSyxRQUFRK0ssWUFBUixDQUFxQixJQUFyQixDQUFaLEVBQTBDO0FBQ3pDYixhQUFNRCxJQUFJMUcsT0FBSixDQUFhMkYsT0FBYixFQUFzQixNQUF0QixDQUFOO0FBQ0EsT0FGRCxNQUVPO0FBQ05sSixlQUFRZ0wsWUFBUixDQUFzQixJQUF0QixFQUE0QmQsR0FBNUI7QUFDQTtBQUNEQSxZQUFNLFVBQVVBLEdBQVYsR0FBZ0IsS0FBdEI7O0FBRUF0SSxVQUFJb0ksT0FBT25KLE1BQVg7QUFDQSxhQUFRZSxHQUFSLEVBQWM7QUFDYm9JLGNBQU9wSSxDQUFQLElBQVlzSSxNQUFNZSxXQUFZakIsT0FBT3BJLENBQVAsQ0FBWixDQUFsQjtBQUNBO0FBQ0R1SSxtQkFBYWxCLFNBQVM0QixJQUFULENBQWU5SyxRQUFmLEtBQTZCbUwsWUFBYWxMLFFBQVF3SyxVQUFyQixDQUE3QixJQUFrRXhLLE9BQS9FO0FBQ0FvSyxvQkFBY0osT0FBT21CLElBQVAsQ0FBWSxHQUFaLENBQWQ7QUFDQTs7QUFFRCxTQUFLZixXQUFMLEVBQW1CO0FBQ2xCLFVBQUk7QUFDSC9LLFlBQUt3QyxLQUFMLENBQVlzRCxPQUFaLEVBQ0NnRixXQUFXaUIsZ0JBQVgsQ0FBNkJoQixXQUE3QixDQUREO0FBR0EsY0FBT2pGLE9BQVA7QUFDQSxPQUxELENBS0UsT0FBTWtHLFFBQU4sRUFBZ0IsQ0FDakIsQ0FORCxTQU1VO0FBQ1QsV0FBSyxDQUFDcEIsR0FBTixFQUFZO0FBQ1hqSyxnQkFBUXNMLGVBQVIsQ0FBd0IsSUFBeEI7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0EsVUFBT0MsT0FBUXhMLFNBQVN3RCxPQUFULENBQWtCcEQsS0FBbEIsRUFBeUIsSUFBekIsQ0FBUixFQUF5Q0gsT0FBekMsRUFBa0RtRixPQUFsRCxFQUEyRDBFLElBQTNELENBQVA7QUFDQTs7QUFFRDs7Ozs7O0FBTUEsV0FBU3ZDLFdBQVQsR0FBdUI7QUFDdEIsT0FBSWtFLE9BQU8sRUFBWDs7QUFFQSxZQUFTQyxLQUFULENBQWdCdEgsR0FBaEIsRUFBcUJXLEtBQXJCLEVBQTZCO0FBQzVCO0FBQ0EsUUFBSzBHLEtBQUtuTSxJQUFMLENBQVc4RSxNQUFNLEdBQWpCLElBQXlCa0MsS0FBS3FGLFdBQW5DLEVBQWlEO0FBQ2hEO0FBQ0EsWUFBT0QsTUFBT0QsS0FBS0csS0FBTCxFQUFQLENBQVA7QUFDQTtBQUNELFdBQVFGLE1BQU90SCxNQUFNLEdBQWIsSUFBcUJXLEtBQTdCO0FBQ0E7QUFDRCxVQUFPMkcsS0FBUDtBQUNBOztBQUVEOzs7O0FBSUEsV0FBU0csWUFBVCxDQUF1QjNMLEVBQXZCLEVBQTRCO0FBQzNCQSxNQUFJbUQsT0FBSixJQUFnQixJQUFoQjtBQUNBLFVBQU9uRCxFQUFQO0FBQ0E7O0FBRUQ7Ozs7QUFJQSxXQUFTNEwsTUFBVCxDQUFpQjVMLEVBQWpCLEVBQXNCO0FBQ3JCLE9BQUk2TCxNQUFNak4sU0FBU2tOLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjs7QUFFQSxPQUFJO0FBQ0gsV0FBTyxDQUFDLENBQUM5TCxHQUFJNkwsR0FBSixDQUFUO0FBQ0EsSUFGRCxDQUVFLE9BQU96SCxDQUFQLEVBQVU7QUFDWCxXQUFPLEtBQVA7QUFDQSxJQUpELFNBSVU7QUFDVDtBQUNBLFFBQUt5SCxJQUFJdEIsVUFBVCxFQUFzQjtBQUNyQnNCLFNBQUl0QixVQUFKLENBQWV3QixXQUFmLENBQTRCRixHQUE1QjtBQUNBO0FBQ0Q7QUFDQUEsVUFBTSxJQUFOO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7QUFLQSxXQUFTRyxTQUFULENBQW9CQyxLQUFwQixFQUEyQkMsT0FBM0IsRUFBcUM7QUFDcEMsT0FBSWpILE1BQU1nSCxNQUFNL0YsS0FBTixDQUFZLEdBQVosQ0FBVjtBQUFBLE9BQ0N2RSxJQUFJc0ssTUFBTXJMLE1BRFg7O0FBR0EsVUFBUWUsR0FBUixFQUFjO0FBQ2J5RSxTQUFLK0YsVUFBTCxDQUFpQmxILElBQUl0RCxDQUFKLENBQWpCLElBQTRCdUssT0FBNUI7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQSxXQUFTRSxZQUFULENBQXVCM0UsQ0FBdkIsRUFBMEJDLENBQTFCLEVBQThCO0FBQzdCLE9BQUkyRSxNQUFNM0UsS0FBS0QsQ0FBZjtBQUFBLE9BQ0M2RSxPQUFPRCxPQUFPNUUsRUFBRXRELFFBQUYsS0FBZSxDQUF0QixJQUEyQnVELEVBQUV2RCxRQUFGLEtBQWUsQ0FBMUMsSUFDTixDQUFFLENBQUN1RCxFQUFFNkUsV0FBSCxJQUFrQjNFLFlBQXBCLEtBQ0UsQ0FBQ0gsRUFBRThFLFdBQUgsSUFBa0IzRSxZQURwQixDQUZGOztBQUtBO0FBQ0EsT0FBSzBFLElBQUwsRUFBWTtBQUNYLFdBQU9BLElBQVA7QUFDQTs7QUFFRDtBQUNBLE9BQUtELEdBQUwsRUFBVztBQUNWLFdBQVNBLE1BQU1BLElBQUlHLFdBQW5CLEVBQWtDO0FBQ2pDLFNBQUtILFFBQVEzRSxDQUFiLEVBQWlCO0FBQ2hCLGFBQU8sQ0FBQyxDQUFSO0FBQ0E7QUFDRDtBQUNEOztBQUVELFVBQU9ELElBQUksQ0FBSixHQUFRLENBQUMsQ0FBaEI7QUFDQTs7QUFFRDs7OztBQUlBLFdBQVNnRixpQkFBVCxDQUE0QjdJLElBQTVCLEVBQW1DO0FBQ2xDLFVBQU8sVUFBVWxDLElBQVYsRUFBaUI7QUFDdkIsUUFBSWdCLE9BQU9oQixLQUFLaUQsUUFBTCxDQUFjQyxXQUFkLEVBQVg7QUFDQSxXQUFPbEMsU0FBUyxPQUFULElBQW9CaEIsS0FBS2tDLElBQUwsS0FBY0EsSUFBekM7QUFDQSxJQUhEO0FBSUE7O0FBRUQ7Ozs7QUFJQSxXQUFTOEksa0JBQVQsQ0FBNkI5SSxJQUE3QixFQUFvQztBQUNuQyxVQUFPLFVBQVVsQyxJQUFWLEVBQWlCO0FBQ3ZCLFFBQUlnQixPQUFPaEIsS0FBS2lELFFBQUwsQ0FBY0MsV0FBZCxFQUFYO0FBQ0EsV0FBTyxDQUFDbEMsU0FBUyxPQUFULElBQW9CQSxTQUFTLFFBQTlCLEtBQTJDaEIsS0FBS2tDLElBQUwsS0FBY0EsSUFBaEU7QUFDQSxJQUhEO0FBSUE7O0FBRUQ7Ozs7QUFJQSxXQUFTK0ksc0JBQVQsQ0FBaUMzTSxFQUFqQyxFQUFzQztBQUNyQyxVQUFPMkwsYUFBYSxVQUFVaUIsUUFBVixFQUFxQjtBQUN4Q0EsZUFBVyxDQUFDQSxRQUFaO0FBQ0EsV0FBT2pCLGFBQWEsVUFBVS9CLElBQVYsRUFBZ0JsRSxPQUFoQixFQUEwQjtBQUM3QyxTQUFJeEQsQ0FBSjtBQUFBLFNBQ0MySyxlQUFlN00sR0FBSSxFQUFKLEVBQVE0SixLQUFLaEosTUFBYixFQUFxQmdNLFFBQXJCLENBRGhCO0FBQUEsU0FFQ2pMLElBQUlrTCxhQUFhak0sTUFGbEI7O0FBSUE7QUFDQSxZQUFRZSxHQUFSLEVBQWM7QUFDYixVQUFLaUksS0FBTzFILElBQUkySyxhQUFhbEwsQ0FBYixDQUFYLENBQUwsRUFBcUM7QUFDcENpSSxZQUFLMUgsQ0FBTCxJQUFVLEVBQUV3RCxRQUFReEQsQ0FBUixJQUFhMEgsS0FBSzFILENBQUwsQ0FBZixDQUFWO0FBQ0E7QUFDRDtBQUNELEtBWE0sQ0FBUDtBQVlBLElBZE0sQ0FBUDtBQWVBOztBQUVEOzs7OztBQUtBLFdBQVMrSSxXQUFULENBQXNCbEwsT0FBdEIsRUFBZ0M7QUFDL0IsVUFBT0EsV0FBVyxRQUFPQSxRQUFRMEssb0JBQWYsTUFBd0M5QyxZQUFuRCxJQUFtRTVILE9BQTFFO0FBQ0E7O0FBRUQ7QUFDQUosWUFBVXdHLE9BQU94RyxPQUFQLEdBQWlCLEVBQTNCOztBQUVBOzs7OztBQUtBMkcsVUFBUUgsT0FBT0csS0FBUCxHQUFlLFVBQVU1RSxJQUFWLEVBQWlCO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFJb0wsa0JBQWtCcEwsUUFBUSxDQUFDQSxLQUFLMEksYUFBTCxJQUFzQjFJLElBQXZCLEVBQTZCb0wsZUFBM0Q7QUFDQSxVQUFPQSxrQkFBa0JBLGdCQUFnQm5JLFFBQWhCLEtBQTZCLE1BQS9DLEdBQXdELEtBQS9EO0FBQ0EsR0FMRDs7QUFPQTs7Ozs7QUFLQWdDLGdCQUFjUixPQUFPUSxXQUFQLEdBQXFCLFVBQVVvRyxJQUFWLEVBQWlCO0FBQ25ELE9BQUlDLFVBQUo7QUFBQSxPQUNDQyxNQUFNRixPQUFPQSxLQUFLM0MsYUFBTCxJQUFzQjJDLElBQTdCLEdBQW9DOUYsWUFEM0M7QUFBQSxPQUVDaUcsU0FBU0QsSUFBSUUsV0FGZDs7QUFJQTtBQUNBLE9BQUtGLFFBQVFyTyxRQUFSLElBQW9CcU8sSUFBSTlJLFFBQUosS0FBaUIsQ0FBckMsSUFBMEMsQ0FBQzhJLElBQUlILGVBQXBELEVBQXNFO0FBQ3JFLFdBQU9sTyxRQUFQO0FBQ0E7O0FBRUQ7QUFDQUEsY0FBV3FPLEdBQVg7QUFDQXJHLGFBQVVxRyxJQUFJSCxlQUFkOztBQUVBO0FBQ0FqRyxvQkFBaUIsQ0FBQ1AsTUFBTzJHLEdBQVAsQ0FBbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFLQyxVQUFVQSxXQUFXQSxPQUFPRSxHQUFqQyxFQUF1QztBQUN0QztBQUNBLFFBQUtGLE9BQU9HLGdCQUFaLEVBQStCO0FBQzlCSCxZQUFPRyxnQkFBUCxDQUF5QixRQUF6QixFQUFtQyxZQUFXO0FBQzdDMUc7QUFDQSxNQUZELEVBRUcsS0FGSDtBQUdBLEtBSkQsTUFJTyxJQUFLdUcsT0FBT0ksV0FBWixFQUEwQjtBQUNoQ0osWUFBT0ksV0FBUCxDQUFvQixVQUFwQixFQUFnQyxZQUFXO0FBQzFDM0c7QUFDQSxNQUZEO0FBR0E7QUFDRDs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBaEgsV0FBUXdJLFVBQVIsR0FBcUJ5RCxPQUFPLFVBQVVDLEdBQVYsRUFBZ0I7QUFDM0NBLFFBQUkwQixTQUFKLEdBQWdCLEdBQWhCO0FBQ0EsV0FBTyxDQUFDMUIsSUFBSWYsWUFBSixDQUFpQixXQUFqQixDQUFSO0FBQ0EsSUFIb0IsQ0FBckI7O0FBS0E7OztBQUdBO0FBQ0FuTCxXQUFROEssb0JBQVIsR0FBK0JtQixPQUFPLFVBQVVDLEdBQVYsRUFBZ0I7QUFDckRBLFFBQUkyQixXQUFKLENBQWlCUCxJQUFJUSxhQUFKLENBQWtCLEVBQWxCLENBQWpCO0FBQ0EsV0FBTyxDQUFDNUIsSUFBSXBCLG9CQUFKLENBQXlCLEdBQXpCLEVBQThCN0osTUFBdEM7QUFDQSxJQUg4QixDQUEvQjs7QUFLQTtBQUNBakIsV0FBUStLLHNCQUFSLEdBQWlDNUIsUUFBUThCLElBQVIsQ0FBY3FDLElBQUl2QyxzQkFBbEIsS0FBOENrQixPQUFPLFVBQVVDLEdBQVYsRUFBZ0I7QUFDckdBLFFBQUk2QixTQUFKLEdBQWdCLDhDQUFoQjs7QUFFQTtBQUNBO0FBQ0E3QixRQUFJOEIsVUFBSixDQUFlSixTQUFmLEdBQTJCLEdBQTNCO0FBQ0E7QUFDQTtBQUNBLFdBQU8xQixJQUFJbkIsc0JBQUosQ0FBMkIsR0FBM0IsRUFBZ0M5SixNQUFoQyxLQUEyQyxDQUFsRDtBQUNBLElBVDhFLENBQS9FOztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FqQixXQUFRaU8sT0FBUixHQUFrQmhDLE9BQU8sVUFBVUMsR0FBVixFQUFnQjtBQUN4Q2pGLFlBQVE0RyxXQUFSLENBQXFCM0IsR0FBckIsRUFBMkJyQixFQUEzQixHQUFnQ3JILE9BQWhDO0FBQ0EsV0FBTyxDQUFDOEosSUFBSVksaUJBQUwsSUFBMEIsQ0FBQ1osSUFBSVksaUJBQUosQ0FBdUIxSyxPQUF2QixFQUFpQ3ZDLE1BQW5FO0FBQ0EsSUFIaUIsQ0FBbEI7O0FBS0E7QUFDQSxPQUFLakIsUUFBUWlPLE9BQWIsRUFBdUI7QUFDdEJ4SCxTQUFLMEgsSUFBTCxDQUFVLElBQVYsSUFBa0IsVUFBVXRELEVBQVYsRUFBY3pLLE9BQWQsRUFBd0I7QUFDekMsU0FBSyxRQUFPQSxRQUFRdUssY0FBZixNQUFrQzNDLFlBQWxDLElBQWtEZCxjQUF2RCxFQUF3RTtBQUN2RSxVQUFJaUQsSUFBSS9KLFFBQVF1SyxjQUFSLENBQXdCRSxFQUF4QixDQUFSO0FBQ0E7QUFDQTtBQUNBLGFBQU9WLEtBQUtBLEVBQUVTLFVBQVAsR0FBb0IsQ0FBQ1QsQ0FBRCxDQUFwQixHQUEwQixFQUFqQztBQUNBO0FBQ0QsS0FQRDtBQVFBMUQsU0FBSzJILE1BQUwsQ0FBWSxJQUFaLElBQW9CLFVBQVV2RCxFQUFWLEVBQWU7QUFDbEMsU0FBSXdELFNBQVN4RCxHQUFHbEgsT0FBSCxDQUFZNEYsU0FBWixFQUF1QkMsU0FBdkIsQ0FBYjtBQUNBLFlBQU8sVUFBVXpILElBQVYsRUFBaUI7QUFDdkIsYUFBT0EsS0FBS29KLFlBQUwsQ0FBa0IsSUFBbEIsTUFBNEJrRCxNQUFuQztBQUNBLE1BRkQ7QUFHQSxLQUxEO0FBTUEsSUFmRCxNQWVPO0FBQ047QUFDQTtBQUNBLFdBQU81SCxLQUFLMEgsSUFBTCxDQUFVLElBQVYsQ0FBUDs7QUFFQTFILFNBQUsySCxNQUFMLENBQVksSUFBWixJQUFxQixVQUFVdkQsRUFBVixFQUFlO0FBQ25DLFNBQUl3RCxTQUFTeEQsR0FBR2xILE9BQUgsQ0FBWTRGLFNBQVosRUFBdUJDLFNBQXZCLENBQWI7QUFDQSxZQUFPLFVBQVV6SCxJQUFWLEVBQWlCO0FBQ3ZCLFVBQUlxTCxPQUFPLFFBQU9yTCxLQUFLdU0sZ0JBQVosTUFBaUN0RyxZQUFqQyxJQUFpRGpHLEtBQUt1TSxnQkFBTCxDQUFzQixJQUF0QixDQUE1RDtBQUNBLGFBQU9sQixRQUFRQSxLQUFLbEksS0FBTCxLQUFlbUosTUFBOUI7QUFDQSxNQUhEO0FBSUEsS0FORDtBQU9BOztBQUVEO0FBQ0E1SCxRQUFLMEgsSUFBTCxDQUFVLEtBQVYsSUFBbUJuTyxRQUFROEssb0JBQVIsR0FDbEIsVUFBVXlELEdBQVYsRUFBZW5PLE9BQWYsRUFBeUI7QUFDeEIsUUFBSyxRQUFPQSxRQUFRMEssb0JBQWYsTUFBd0M5QyxZQUE3QyxFQUE0RDtBQUMzRCxZQUFPNUgsUUFBUTBLLG9CQUFSLENBQThCeUQsR0FBOUIsQ0FBUDtBQUNBO0FBQ0QsSUFMaUIsR0FNbEIsVUFBVUEsR0FBVixFQUFlbk8sT0FBZixFQUF5QjtBQUN4QixRQUFJMkIsSUFBSjtBQUFBLFFBQ0NxRSxNQUFNLEVBRFA7QUFBQSxRQUVDcEUsSUFBSSxDQUZMO0FBQUEsUUFHQ3VELFVBQVVuRixRQUFRMEssb0JBQVIsQ0FBOEJ5RCxHQUE5QixDQUhYOztBQUtBO0FBQ0EsUUFBS0EsUUFBUSxHQUFiLEVBQW1CO0FBQ2xCLFlBQVN4TSxPQUFPd0QsUUFBUXZELEdBQVIsQ0FBaEIsRUFBZ0M7QUFDL0IsVUFBS0QsS0FBS3lDLFFBQUwsS0FBa0IsQ0FBdkIsRUFBMkI7QUFDMUI0QixXQUFJM0csSUFBSixDQUFVc0MsSUFBVjtBQUNBO0FBQ0Q7O0FBRUQsWUFBT3FFLEdBQVA7QUFDQTtBQUNELFdBQU9iLE9BQVA7QUFDQSxJQXZCRjs7QUF5QkE7QUFDQWtCLFFBQUswSCxJQUFMLENBQVUsT0FBVixJQUFxQm5PLFFBQVErSyxzQkFBUixJQUFrQyxVQUFVNkMsU0FBVixFQUFxQnhOLE9BQXJCLEVBQStCO0FBQ3JGLFFBQUssUUFBT0EsUUFBUTJLLHNCQUFmLE1BQTBDL0MsWUFBMUMsSUFBMERkLGNBQS9ELEVBQWdGO0FBQy9FLFlBQU85RyxRQUFRMkssc0JBQVIsQ0FBZ0M2QyxTQUFoQyxDQUFQO0FBQ0E7QUFDRCxJQUpEOztBQU1BOzs7QUFHQTs7QUFFQTtBQUNBeEcsbUJBQWdCLEVBQWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUQsZUFBWSxFQUFaOztBQUVBLE9BQU1uSCxRQUFRZ0wsR0FBUixHQUFjN0IsUUFBUThCLElBQVIsQ0FBY3FDLElBQUk5QixnQkFBbEIsQ0FBcEIsRUFBNEQ7QUFDM0Q7QUFDQTtBQUNBUyxXQUFPLFVBQVVDLEdBQVYsRUFBZ0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxTQUFJNkIsU0FBSixHQUFnQixxREFBaEI7O0FBRUE7QUFDQTtBQUNBLFNBQUs3QixJQUFJVixnQkFBSixDQUFxQixTQUFyQixFQUFnQ3ZLLE1BQXJDLEVBQThDO0FBQzdDa0csZ0JBQVUxSCxJQUFWLENBQWdCLFdBQVc0SSxVQUFYLEdBQXdCLGNBQXhDO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLFNBQUssQ0FBQzZELElBQUlWLGdCQUFKLENBQXFCLFlBQXJCLEVBQW1DdkssTUFBekMsRUFBa0Q7QUFDakRrRyxnQkFBVTFILElBQVYsQ0FBZ0IsUUFBUTRJLFVBQVIsR0FBcUIsWUFBckIsR0FBb0NELFFBQXBDLEdBQStDLEdBQS9EO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsU0FBSyxDQUFDOEQsSUFBSVYsZ0JBQUosQ0FBcUIsVUFBckIsRUFBaUN2SyxNQUF2QyxFQUFnRDtBQUMvQ2tHLGdCQUFVMUgsSUFBVixDQUFlLFVBQWY7QUFDQTtBQUNELEtBMUJEOztBQTRCQXdNLFdBQU8sVUFBVUMsR0FBVixFQUFnQjtBQUN0QjtBQUNBO0FBQ0EsU0FBSXNDLFFBQVFsQixJQUFJbkIsYUFBSixDQUFrQixPQUFsQixDQUFaO0FBQ0FxQyxXQUFNcEQsWUFBTixDQUFvQixNQUFwQixFQUE0QixRQUE1QjtBQUNBYyxTQUFJMkIsV0FBSixDQUFpQlcsS0FBakIsRUFBeUJwRCxZQUF6QixDQUF1QyxNQUF2QyxFQUErQyxHQUEvQzs7QUFFQTtBQUNBO0FBQ0EsU0FBS2MsSUFBSVYsZ0JBQUosQ0FBcUIsVUFBckIsRUFBaUN2SyxNQUF0QyxFQUErQztBQUM5Q2tHLGdCQUFVMUgsSUFBVixDQUFnQixTQUFTNEksVUFBVCxHQUFzQixhQUF0QztBQUNBOztBQUVEO0FBQ0E7QUFDQSxTQUFLLENBQUM2RCxJQUFJVixnQkFBSixDQUFxQixVQUFyQixFQUFpQ3ZLLE1BQXZDLEVBQWdEO0FBQy9Da0csZ0JBQVUxSCxJQUFWLENBQWdCLFVBQWhCLEVBQTRCLFdBQTVCO0FBQ0E7O0FBRUQ7QUFDQXlNLFNBQUlWLGdCQUFKLENBQXFCLE1BQXJCO0FBQ0FyRSxlQUFVMUgsSUFBVixDQUFlLE1BQWY7QUFDQSxLQXRCRDtBQXVCQTs7QUFFRCxPQUFNTyxRQUFReU8sZUFBUixHQUEwQnRGLFFBQVE4QixJQUFSLENBQWVsRixVQUFVa0IsUUFBUXlILHFCQUFSLElBQ3hEekgsUUFBUTBILGtCQURnRCxJQUV4RDFILFFBQVEySCxnQkFGZ0QsSUFHeEQzSCxRQUFRNEgsaUJBSHVCLENBQWhDLEVBR2lDOztBQUVoQzVDLFdBQU8sVUFBVUMsR0FBVixFQUFnQjtBQUN0QjtBQUNBO0FBQ0FsTSxhQUFROE8saUJBQVIsR0FBNEIvSSxRQUFRNUUsSUFBUixDQUFjK0ssR0FBZCxFQUFtQixLQUFuQixDQUE1Qjs7QUFFQTtBQUNBO0FBQ0FuRyxhQUFRNUUsSUFBUixDQUFjK0ssR0FBZCxFQUFtQixXQUFuQjtBQUNBOUUsbUJBQWMzSCxJQUFkLENBQW9CLElBQXBCLEVBQTBCZ0osT0FBMUI7QUFDQSxLQVREO0FBVUE7O0FBRUR0QixlQUFZQSxVQUFVbEcsTUFBVixJQUFvQixJQUFJeUgsTUFBSixDQUFZdkIsVUFBVW9FLElBQVYsQ0FBZSxHQUFmLENBQVosQ0FBaEM7QUFDQW5FLG1CQUFnQkEsY0FBY25HLE1BQWQsSUFBd0IsSUFBSXlILE1BQUosQ0FBWXRCLGNBQWNtRSxJQUFkLENBQW1CLEdBQW5CLENBQVosQ0FBeEM7O0FBRUE7O0FBRUE4QixnQkFBYWxFLFFBQVE4QixJQUFSLENBQWNoRSxRQUFROEgsdUJBQXRCLENBQWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0ExSCxjQUFXZ0csY0FBY2xFLFFBQVE4QixJQUFSLENBQWNoRSxRQUFRSSxRQUF0QixDQUFkLEdBQ1YsVUFBVVMsQ0FBVixFQUFhQyxDQUFiLEVBQWlCO0FBQ2hCLFFBQUlpSCxRQUFRbEgsRUFBRXRELFFBQUYsS0FBZSxDQUFmLEdBQW1Cc0QsRUFBRXFGLGVBQXJCLEdBQXVDckYsQ0FBbkQ7QUFBQSxRQUNDbUgsTUFBTWxILEtBQUtBLEVBQUU2QyxVQURkO0FBRUEsV0FBTzlDLE1BQU1tSCxHQUFOLElBQWEsQ0FBQyxFQUFHQSxPQUFPQSxJQUFJekssUUFBSixLQUFpQixDQUF4QixLQUN2QndLLE1BQU0zSCxRQUFOLEdBQ0MySCxNQUFNM0gsUUFBTixDQUFnQjRILEdBQWhCLENBREQsR0FFQ25ILEVBQUVpSCx1QkFBRixJQUE2QmpILEVBQUVpSCx1QkFBRixDQUEyQkUsR0FBM0IsSUFBbUMsRUFIMUMsQ0FBSCxDQUFyQjtBQUtBLElBVFMsR0FVVixVQUFVbkgsQ0FBVixFQUFhQyxDQUFiLEVBQWlCO0FBQ2hCLFFBQUtBLENBQUwsRUFBUztBQUNSLFlBQVNBLElBQUlBLEVBQUU2QyxVQUFmLEVBQTZCO0FBQzVCLFVBQUs3QyxNQUFNRCxDQUFYLEVBQWU7QUFDZCxjQUFPLElBQVA7QUFDQTtBQUNEO0FBQ0Q7QUFDRCxXQUFPLEtBQVA7QUFDQSxJQW5CRjs7QUFxQkE7OztBQUdBO0FBQ0FELGVBQVl3RixhQUNaLFVBQVV2RixDQUFWLEVBQWFDLENBQWIsRUFBaUI7O0FBRWhCO0FBQ0EsUUFBS0QsTUFBTUMsQ0FBWCxFQUFlO0FBQ2RoQixvQkFBZSxJQUFmO0FBQ0EsWUFBTyxDQUFQO0FBQ0E7O0FBRUQ7QUFDQSxRQUFJbUksVUFBVSxDQUFDcEgsRUFBRWlILHVCQUFILEdBQTZCLENBQUNoSCxFQUFFZ0gsdUJBQTlDO0FBQ0EsUUFBS0csT0FBTCxFQUFlO0FBQ2QsWUFBT0EsT0FBUDtBQUNBOztBQUVEO0FBQ0FBLGNBQVUsQ0FBRXBILEVBQUUyQyxhQUFGLElBQW1CM0MsQ0FBckIsT0FBK0JDLEVBQUUwQyxhQUFGLElBQW1CMUMsQ0FBbEQsSUFDVEQsRUFBRWlILHVCQUFGLENBQTJCaEgsQ0FBM0IsQ0FEUzs7QUFHVDtBQUNBLEtBSkQ7O0FBTUE7QUFDQSxRQUFLbUgsVUFBVSxDQUFWLElBQ0gsQ0FBQ2xQLFFBQVFtUCxZQUFULElBQXlCcEgsRUFBRWdILHVCQUFGLENBQTJCakgsQ0FBM0IsTUFBbUNvSCxPQUQ5RCxFQUN5RTs7QUFFeEU7QUFDQSxTQUFLcEgsTUFBTXdGLEdBQU4sSUFBYXhGLEVBQUUyQyxhQUFGLEtBQW9CbkQsWUFBcEIsSUFBb0NELFNBQVNDLFlBQVQsRUFBdUJRLENBQXZCLENBQXRELEVBQWtGO0FBQ2pGLGFBQU8sQ0FBQyxDQUFSO0FBQ0E7QUFDRCxTQUFLQyxNQUFNdUYsR0FBTixJQUFhdkYsRUFBRTBDLGFBQUYsS0FBb0JuRCxZQUFwQixJQUFvQ0QsU0FBU0MsWUFBVCxFQUF1QlMsQ0FBdkIsQ0FBdEQsRUFBa0Y7QUFDakYsYUFBTyxDQUFQO0FBQ0E7O0FBRUQ7QUFDQSxZQUFPakIsWUFDSnBILFFBQVF5QixJQUFSLENBQWMyRixTQUFkLEVBQXlCZ0IsQ0FBekIsSUFBK0JwSSxRQUFReUIsSUFBUixDQUFjMkYsU0FBZCxFQUF5QmlCLENBQXpCLENBRDNCLEdBRU4sQ0FGRDtBQUdBOztBQUVELFdBQU9tSCxVQUFVLENBQVYsR0FBYyxDQUFDLENBQWYsR0FBbUIsQ0FBMUI7QUFDQSxJQXpDVyxHQTBDWixVQUFVcEgsQ0FBVixFQUFhQyxDQUFiLEVBQWlCO0FBQ2hCO0FBQ0EsUUFBS0QsTUFBTUMsQ0FBWCxFQUFlO0FBQ2RoQixvQkFBZSxJQUFmO0FBQ0EsWUFBTyxDQUFQO0FBQ0E7O0FBRUQsUUFBSTJGLEdBQUo7QUFBQSxRQUNDMUssSUFBSSxDQURMO0FBQUEsUUFFQ29OLE1BQU10SCxFQUFFOEMsVUFGVDtBQUFBLFFBR0NxRSxNQUFNbEgsRUFBRTZDLFVBSFQ7QUFBQSxRQUlDeUUsS0FBSyxDQUFFdkgsQ0FBRixDQUpOO0FBQUEsUUFLQ3dILEtBQUssQ0FBRXZILENBQUYsQ0FMTjs7QUFPQTtBQUNBLFFBQUssQ0FBQ3FILEdBQUQsSUFBUSxDQUFDSCxHQUFkLEVBQW9CO0FBQ25CLFlBQU9uSCxNQUFNd0YsR0FBTixHQUFZLENBQUMsQ0FBYixHQUNOdkYsTUFBTXVGLEdBQU4sR0FBWSxDQUFaLEdBQ0E4QixNQUFNLENBQUMsQ0FBUCxHQUNBSCxNQUFNLENBQU4sR0FDQW5JLFlBQ0VwSCxRQUFReUIsSUFBUixDQUFjMkYsU0FBZCxFQUF5QmdCLENBQXpCLElBQStCcEksUUFBUXlCLElBQVIsQ0FBYzJGLFNBQWQsRUFBeUJpQixDQUF6QixDQURqQyxHQUVBLENBTkQ7O0FBUUQ7QUFDQyxLQVZELE1BVU8sSUFBS3FILFFBQVFILEdBQWIsRUFBbUI7QUFDekIsWUFBT3hDLGFBQWMzRSxDQUFkLEVBQWlCQyxDQUFqQixDQUFQO0FBQ0E7O0FBRUQ7QUFDQTJFLFVBQU01RSxDQUFOO0FBQ0EsV0FBUzRFLE1BQU1BLElBQUk5QixVQUFuQixFQUFpQztBQUNoQ3lFLFFBQUdFLE9BQUgsQ0FBWTdDLEdBQVo7QUFDQTtBQUNEQSxVQUFNM0UsQ0FBTjtBQUNBLFdBQVMyRSxNQUFNQSxJQUFJOUIsVUFBbkIsRUFBaUM7QUFDaEMwRSxRQUFHQyxPQUFILENBQVk3QyxHQUFaO0FBQ0E7O0FBRUQ7QUFDQSxXQUFRMkMsR0FBR3JOLENBQUgsTUFBVXNOLEdBQUd0TixDQUFILENBQWxCLEVBQTBCO0FBQ3pCQTtBQUNBOztBQUVELFdBQU9BO0FBQ047QUFDQXlLLGlCQUFjNEMsR0FBR3JOLENBQUgsQ0FBZCxFQUFxQnNOLEdBQUd0TixDQUFILENBQXJCLENBRk07O0FBSU47QUFDQXFOLE9BQUdyTixDQUFILE1BQVVzRixZQUFWLEdBQXlCLENBQUMsQ0FBMUIsR0FDQWdJLEdBQUd0TixDQUFILE1BQVVzRixZQUFWLEdBQXlCLENBQXpCLEdBQ0EsQ0FQRDtBQVFBLElBOUZEOztBQWdHQSxVQUFPZ0csR0FBUDtBQUNBLEdBcldEOztBQXVXQTlHLFNBQU9ULE9BQVAsR0FBaUIsVUFBVXlKLElBQVYsRUFBZ0JDLFFBQWhCLEVBQTJCO0FBQzNDLFVBQU9qSixPQUFRZ0osSUFBUixFQUFjLElBQWQsRUFBb0IsSUFBcEIsRUFBMEJDLFFBQTFCLENBQVA7QUFDQSxHQUZEOztBQUlBakosU0FBT2lJLGVBQVAsR0FBeUIsVUFBVTFNLElBQVYsRUFBZ0J5TixJQUFoQixFQUF1QjtBQUMvQztBQUNBLE9BQUssQ0FBRXpOLEtBQUswSSxhQUFMLElBQXNCMUksSUFBeEIsTUFBbUM5QyxRQUF4QyxFQUFtRDtBQUNsRCtILGdCQUFhakYsSUFBYjtBQUNBOztBQUVEO0FBQ0F5TixVQUFPQSxLQUFLN0wsT0FBTCxDQUFja0YsZ0JBQWQsRUFBZ0MsUUFBaEMsQ0FBUDs7QUFFQSxPQUFLN0ksUUFBUXlPLGVBQVIsSUFBMkJ2SCxjQUEzQixLQUNGLENBQUNFLGFBQUQsSUFBa0IsQ0FBQ0EsY0FBYzZELElBQWQsQ0FBb0J1RSxJQUFwQixDQURqQixNQUVGLENBQUNySSxTQUFELElBQWtCLENBQUNBLFVBQVU4RCxJQUFWLENBQWdCdUUsSUFBaEIsQ0FGakIsQ0FBTCxFQUVpRDs7QUFFaEQsUUFBSTtBQUNILFNBQUloTyxNQUFNdUUsUUFBUTVFLElBQVIsQ0FBY1ksSUFBZCxFQUFvQnlOLElBQXBCLENBQVY7O0FBRUE7QUFDQSxTQUFLaE8sT0FBT3hCLFFBQVE4TyxpQkFBZjtBQUNIO0FBQ0E7QUFDQS9NLFVBQUs5QyxRQUFMLElBQWlCOEMsS0FBSzlDLFFBQUwsQ0FBY3VGLFFBQWQsS0FBMkIsRUFIOUMsRUFHbUQ7QUFDbEQsYUFBT2hELEdBQVA7QUFDQTtBQUNELEtBVkQsQ0FVRSxPQUFNaUQsQ0FBTixFQUFTLENBQUU7QUFDYjs7QUFFRCxVQUFPK0IsT0FBUWdKLElBQVIsRUFBY3ZRLFFBQWQsRUFBd0IsSUFBeEIsRUFBOEIsQ0FBQzhDLElBQUQsQ0FBOUIsRUFBdUNkLE1BQXZDLEdBQWdELENBQXZEO0FBQ0EsR0EzQkQ7O0FBNkJBdUYsU0FBT2EsUUFBUCxHQUFrQixVQUFVakgsT0FBVixFQUFtQjJCLElBQW5CLEVBQTBCO0FBQzNDO0FBQ0EsT0FBSyxDQUFFM0IsUUFBUXFLLGFBQVIsSUFBeUJySyxPQUEzQixNQUF5Q25CLFFBQTlDLEVBQXlEO0FBQ3hEK0gsZ0JBQWE1RyxPQUFiO0FBQ0E7QUFDRCxVQUFPaUgsU0FBVWpILE9BQVYsRUFBbUIyQixJQUFuQixDQUFQO0FBQ0EsR0FORDs7QUFRQXlFLFNBQU9rSixJQUFQLEdBQWMsVUFBVTNOLElBQVYsRUFBZ0JnQixJQUFoQixFQUF1QjtBQUNwQztBQUNBLE9BQUssQ0FBRWhCLEtBQUswSSxhQUFMLElBQXNCMUksSUFBeEIsTUFBbUM5QyxRQUF4QyxFQUFtRDtBQUNsRCtILGdCQUFhakYsSUFBYjtBQUNBOztBQUVELE9BQUkxQixLQUFLb0csS0FBSytGLFVBQUwsQ0FBaUJ6SixLQUFLa0MsV0FBTCxFQUFqQixDQUFUOztBQUNDO0FBQ0EwSyxTQUFNdFAsTUFBTVIsT0FBT3NCLElBQVAsQ0FBYXNGLEtBQUsrRixVQUFsQixFQUE4QnpKLEtBQUtrQyxXQUFMLEVBQTlCLENBQU4sR0FDTDVFLEdBQUkwQixJQUFKLEVBQVVnQixJQUFWLEVBQWdCLENBQUNtRSxjQUFqQixDQURLLEdBRUwzRCxTQUpGOztBQU1BLFVBQU9vTSxRQUFRcE0sU0FBUixHQUNOb00sR0FETSxHQUVOM1AsUUFBUXdJLFVBQVIsSUFBc0IsQ0FBQ3RCLGNBQXZCLEdBQ0NuRixLQUFLb0osWUFBTCxDQUFtQnBJLElBQW5CLENBREQsR0FFQyxDQUFDNE0sTUFBTTVOLEtBQUt1TSxnQkFBTCxDQUFzQnZMLElBQXRCLENBQVAsS0FBdUM0TSxJQUFJQyxTQUEzQyxHQUNDRCxJQUFJekssS0FETCxHQUVDLElBTkg7QUFPQSxHQW5CRDs7QUFxQkFzQixTQUFPM0MsS0FBUCxHQUFlLFVBQVVDLEdBQVYsRUFBZ0I7QUFDOUIsU0FBTSxJQUFJM0UsS0FBSixDQUFXLDRDQUE0QzJFLEdBQXZELENBQU47QUFDQSxHQUZEOztBQUlBOzs7O0FBSUEwQyxTQUFPcUosVUFBUCxHQUFvQixVQUFVdEssT0FBVixFQUFvQjtBQUN2QyxPQUFJeEQsSUFBSjtBQUFBLE9BQ0MrTixhQUFhLEVBRGQ7QUFBQSxPQUVDdk4sSUFBSSxDQUZMO0FBQUEsT0FHQ1AsSUFBSSxDQUhMOztBQUtBO0FBQ0ErRSxrQkFBZSxDQUFDL0csUUFBUStQLGdCQUF4QjtBQUNBakosZUFBWSxDQUFDOUcsUUFBUWdRLFVBQVQsSUFBdUJ6SyxRQUFRaEcsS0FBUixDQUFlLENBQWYsQ0FBbkM7QUFDQWdHLFdBQVE5QyxJQUFSLENBQWNvRixTQUFkOztBQUVBLE9BQUtkLFlBQUwsRUFBb0I7QUFDbkIsV0FBU2hGLE9BQU93RCxRQUFRdkQsR0FBUixDQUFoQixFQUFnQztBQUMvQixTQUFLRCxTQUFTd0QsUUFBU3ZELENBQVQsQ0FBZCxFQUE2QjtBQUM1Qk8sVUFBSXVOLFdBQVdyUSxJQUFYLENBQWlCdUMsQ0FBakIsQ0FBSjtBQUNBO0FBQ0Q7QUFDRCxXQUFRTyxHQUFSLEVBQWM7QUFDYmdELGFBQVE3QyxNQUFSLENBQWdCb04sV0FBWXZOLENBQVosQ0FBaEIsRUFBaUMsQ0FBakM7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQXVFLGVBQVksSUFBWjs7QUFFQSxVQUFPdkIsT0FBUDtBQUNBLEdBM0JEOztBQTZCQTs7OztBQUlBbUIsWUFBVUYsT0FBT0UsT0FBUCxHQUFpQixVQUFVM0UsSUFBVixFQUFpQjtBQUMzQyxPQUFJcUwsSUFBSjtBQUFBLE9BQ0M1TCxNQUFNLEVBRFA7QUFBQSxPQUVDUSxJQUFJLENBRkw7QUFBQSxPQUdDd0MsV0FBV3pDLEtBQUt5QyxRQUhqQjs7QUFLQSxPQUFLLENBQUNBLFFBQU4sRUFBaUI7QUFDaEI7QUFDQSxXQUFTNEksT0FBT3JMLEtBQUtDLEdBQUwsQ0FBaEIsRUFBNkI7QUFDNUI7QUFDQVIsWUFBT2tGLFFBQVMwRyxJQUFULENBQVA7QUFDQTtBQUNELElBTkQsTUFNTyxJQUFLNUksYUFBYSxDQUFiLElBQWtCQSxhQUFhLENBQS9CLElBQW9DQSxhQUFhLEVBQXRELEVBQTJEO0FBQ2pFO0FBQ0E7QUFDQSxRQUFLLE9BQU96QyxLQUFLa08sV0FBWixLQUE0QixRQUFqQyxFQUE0QztBQUMzQyxZQUFPbE8sS0FBS2tPLFdBQVo7QUFDQSxLQUZELE1BRU87QUFDTjtBQUNBLFVBQU1sTyxPQUFPQSxLQUFLaU0sVUFBbEIsRUFBOEJqTSxJQUE5QixFQUFvQ0EsT0FBT0EsS0FBSzhLLFdBQWhELEVBQThEO0FBQzdEckwsYUFBT2tGLFFBQVMzRSxJQUFULENBQVA7QUFDQTtBQUNEO0FBQ0QsSUFYTSxNQVdBLElBQUt5QyxhQUFhLENBQWIsSUFBa0JBLGFBQWEsQ0FBcEMsRUFBd0M7QUFDOUMsV0FBT3pDLEtBQUttTyxTQUFaO0FBQ0E7QUFDRDs7QUFFQSxVQUFPMU8sR0FBUDtBQUNBLEdBN0JEOztBQStCQWlGLFNBQU9ELE9BQU8ySixTQUFQLEdBQW1COztBQUV6QjtBQUNBckUsZ0JBQWEsRUFIWTs7QUFLekJzRSxpQkFBY3BFLFlBTFc7O0FBT3pCOUIsVUFBT2xCLFNBUGtCOztBQVN6QndELGVBQVksRUFUYTs7QUFXekIyQixTQUFNLEVBWG1COztBQWF6QmtDLGFBQVU7QUFDVCxTQUFLLEVBQUVDLEtBQUssWUFBUCxFQUFxQm5PLE9BQU8sSUFBNUIsRUFESTtBQUVULFNBQUssRUFBRW1PLEtBQUssWUFBUCxFQUZJO0FBR1QsU0FBSyxFQUFFQSxLQUFLLGlCQUFQLEVBQTBCbk8sT0FBTyxJQUFqQyxFQUhJO0FBSVQsU0FBSyxFQUFFbU8sS0FBSyxpQkFBUDtBQUpJLElBYmU7O0FBb0J6QkMsY0FBVztBQUNWLFlBQVEsY0FBVXJHLEtBQVYsRUFBa0I7QUFDekJBLFdBQU0sQ0FBTixJQUFXQSxNQUFNLENBQU4sRUFBU3ZHLE9BQVQsQ0FBa0I0RixTQUFsQixFQUE2QkMsU0FBN0IsQ0FBWDs7QUFFQTtBQUNBVSxXQUFNLENBQU4sSUFBVyxDQUFFQSxNQUFNLENBQU4sS0FBWUEsTUFBTSxDQUFOLENBQVosSUFBd0IsRUFBMUIsRUFBK0J2RyxPQUEvQixDQUF3QzRGLFNBQXhDLEVBQW1EQyxTQUFuRCxDQUFYOztBQUVBLFNBQUtVLE1BQU0sQ0FBTixNQUFhLElBQWxCLEVBQXlCO0FBQ3hCQSxZQUFNLENBQU4sSUFBVyxNQUFNQSxNQUFNLENBQU4sQ0FBTixHQUFpQixHQUE1QjtBQUNBOztBQUVELFlBQU9BLE1BQU0zSyxLQUFOLENBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFQO0FBQ0EsS0FaUzs7QUFjVixhQUFTLGVBQVUySyxLQUFWLEVBQWtCO0FBQzFCOzs7Ozs7Ozs7O0FBVUFBLFdBQU0sQ0FBTixJQUFXQSxNQUFNLENBQU4sRUFBU2pGLFdBQVQsRUFBWDs7QUFFQSxTQUFLaUYsTUFBTSxDQUFOLEVBQVMzSyxLQUFULENBQWdCLENBQWhCLEVBQW1CLENBQW5CLE1BQTJCLEtBQWhDLEVBQXdDO0FBQ3ZDO0FBQ0EsVUFBSyxDQUFDMkssTUFBTSxDQUFOLENBQU4sRUFBaUI7QUFDaEIxRCxjQUFPM0MsS0FBUCxDQUFjcUcsTUFBTSxDQUFOLENBQWQ7QUFDQTs7QUFFRDtBQUNBO0FBQ0FBLFlBQU0sQ0FBTixJQUFXLEVBQUdBLE1BQU0sQ0FBTixJQUFXQSxNQUFNLENBQU4sS0FBWUEsTUFBTSxDQUFOLEtBQVksQ0FBeEIsQ0FBWCxHQUF3QyxLQUFNQSxNQUFNLENBQU4sTUFBYSxNQUFiLElBQXVCQSxNQUFNLENBQU4sTUFBYSxLQUExQyxDQUEzQyxDQUFYO0FBQ0FBLFlBQU0sQ0FBTixJQUFXLEVBQUtBLE1BQU0sQ0FBTixJQUFXQSxNQUFNLENBQU4sQ0FBYixJQUEyQkEsTUFBTSxDQUFOLE1BQWEsS0FBM0MsQ0FBWDs7QUFFRDtBQUNDLE1BWkQsTUFZTyxJQUFLQSxNQUFNLENBQU4sQ0FBTCxFQUFnQjtBQUN0QjFELGFBQU8zQyxLQUFQLENBQWNxRyxNQUFNLENBQU4sQ0FBZDtBQUNBOztBQUVELFlBQU9BLEtBQVA7QUFDQSxLQTVDUzs7QUE4Q1YsY0FBVSxnQkFBVUEsS0FBVixFQUFrQjtBQUMzQixTQUFJc0csTUFBSjtBQUFBLFNBQ0NDLFdBQVcsQ0FBQ3ZHLE1BQU0sQ0FBTixDQUFELElBQWFBLE1BQU0sQ0FBTixDQUR6Qjs7QUFHQSxTQUFLbEIsVUFBVSxPQUFWLEVBQW1CaUMsSUFBbkIsQ0FBeUJmLE1BQU0sQ0FBTixDQUF6QixDQUFMLEVBQTJDO0FBQzFDLGFBQU8sSUFBUDtBQUNBOztBQUVEO0FBQ0EsU0FBS0EsTUFBTSxDQUFOLEtBQVlBLE1BQU0sQ0FBTixNQUFhM0csU0FBOUIsRUFBMEM7QUFDekMyRyxZQUFNLENBQU4sSUFBV0EsTUFBTSxDQUFOLENBQVg7O0FBRUQ7QUFDQyxNQUpELE1BSU8sSUFBS3VHLFlBQVkzSCxRQUFRbUMsSUFBUixDQUFjd0YsUUFBZCxDQUFaO0FBQ1g7QUFDQ0QsY0FBU3RGLFNBQVV1RixRQUFWLEVBQW9CLElBQXBCLENBRkM7QUFHWDtBQUNDRCxjQUFTQyxTQUFTL1EsT0FBVCxDQUFrQixHQUFsQixFQUF1QitRLFNBQVN4UCxNQUFULEdBQWtCdVAsTUFBekMsSUFBb0RDLFNBQVN4UCxNQUo1RCxDQUFMLEVBSTJFOztBQUVqRjtBQUNBaUosWUFBTSxDQUFOLElBQVdBLE1BQU0sQ0FBTixFQUFTM0ssS0FBVCxDQUFnQixDQUFoQixFQUFtQmlSLE1BQW5CLENBQVg7QUFDQXRHLFlBQU0sQ0FBTixJQUFXdUcsU0FBU2xSLEtBQVQsQ0FBZ0IsQ0FBaEIsRUFBbUJpUixNQUFuQixDQUFYO0FBQ0E7O0FBRUQ7QUFDQSxZQUFPdEcsTUFBTTNLLEtBQU4sQ0FBYSxDQUFiLEVBQWdCLENBQWhCLENBQVA7QUFDQTtBQXhFUyxJQXBCYzs7QUErRnpCNk8sV0FBUTs7QUFFUCxXQUFPLGFBQVVzQyxnQkFBVixFQUE2QjtBQUNuQyxTQUFJMUwsV0FBVzBMLGlCQUFpQi9NLE9BQWpCLENBQTBCNEYsU0FBMUIsRUFBcUNDLFNBQXJDLEVBQWlEdkUsV0FBakQsRUFBZjtBQUNBLFlBQU95TCxxQkFBcUIsR0FBckIsR0FDTixZQUFXO0FBQUUsYUFBTyxJQUFQO0FBQWMsTUFEckIsR0FFTixVQUFVM08sSUFBVixFQUFpQjtBQUNoQixhQUFPQSxLQUFLaUQsUUFBTCxJQUFpQmpELEtBQUtpRCxRQUFMLENBQWNDLFdBQWQsT0FBZ0NELFFBQXhEO0FBQ0EsTUFKRjtBQUtBLEtBVE07O0FBV1AsYUFBUyxlQUFVNEksU0FBVixFQUFzQjtBQUM5QixTQUFJK0MsVUFBVWxKLFdBQVltRyxZQUFZLEdBQXhCLENBQWQ7O0FBRUEsWUFBTytDLFdBQ04sQ0FBQ0EsVUFBVSxJQUFJakksTUFBSixDQUFZLFFBQVFMLFVBQVIsR0FBcUIsR0FBckIsR0FBMkJ1RixTQUEzQixHQUF1QyxHQUF2QyxHQUE2Q3ZGLFVBQTdDLEdBQTBELEtBQXRFLENBQVgsS0FDQVosV0FBWW1HLFNBQVosRUFBdUIsVUFBVTdMLElBQVYsRUFBaUI7QUFDdkMsYUFBTzRPLFFBQVExRixJQUFSLENBQWMsT0FBT2xKLEtBQUs2TCxTQUFaLEtBQTBCLFFBQTFCLElBQXNDN0wsS0FBSzZMLFNBQTNDLElBQXdELFFBQU83TCxLQUFLb0osWUFBWixNQUE2Qm5ELFlBQTdCLElBQTZDakcsS0FBS29KLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBckcsSUFBbUksRUFBakosQ0FBUDtBQUNBLE1BRkQsQ0FGRDtBQUtBLEtBbkJNOztBQXFCUCxZQUFRLGNBQVVwSSxJQUFWLEVBQWdCNk4sUUFBaEIsRUFBMEJDLEtBQTFCLEVBQWtDO0FBQ3pDLFlBQU8sVUFBVTlPLElBQVYsRUFBaUI7QUFDdkIsVUFBSStPLFNBQVN0SyxPQUFPa0osSUFBUCxDQUFhM04sSUFBYixFQUFtQmdCLElBQW5CLENBQWI7O0FBRUEsVUFBSytOLFVBQVUsSUFBZixFQUFzQjtBQUNyQixjQUFPRixhQUFhLElBQXBCO0FBQ0E7QUFDRCxVQUFLLENBQUNBLFFBQU4sRUFBaUI7QUFDaEIsY0FBTyxJQUFQO0FBQ0E7O0FBRURFLGdCQUFVLEVBQVY7O0FBRUEsYUFBT0YsYUFBYSxHQUFiLEdBQW1CRSxXQUFXRCxLQUE5QixHQUNORCxhQUFhLElBQWIsR0FBb0JFLFdBQVdELEtBQS9CLEdBQ0FELGFBQWEsSUFBYixHQUFvQkMsU0FBU0MsT0FBT3BSLE9BQVAsQ0FBZ0JtUixLQUFoQixNQUE0QixDQUF6RCxHQUNBRCxhQUFhLElBQWIsR0FBb0JDLFNBQVNDLE9BQU9wUixPQUFQLENBQWdCbVIsS0FBaEIsSUFBMEIsQ0FBQyxDQUF4RCxHQUNBRCxhQUFhLElBQWIsR0FBb0JDLFNBQVNDLE9BQU92UixLQUFQLENBQWMsQ0FBQ3NSLE1BQU01UCxNQUFyQixNQUFrQzRQLEtBQS9ELEdBQ0FELGFBQWEsSUFBYixHQUFvQixDQUFFLE1BQU1FLE1BQU4sR0FBZSxHQUFqQixFQUF1QnBSLE9BQXZCLENBQWdDbVIsS0FBaEMsSUFBMEMsQ0FBQyxDQUEvRCxHQUNBRCxhQUFhLElBQWIsR0FBb0JFLFdBQVdELEtBQVgsSUFBb0JDLE9BQU92UixLQUFQLENBQWMsQ0FBZCxFQUFpQnNSLE1BQU01UCxNQUFOLEdBQWUsQ0FBaEMsTUFBd0M0UCxRQUFRLEdBQXhGLEdBQ0EsS0FQRDtBQVFBLE1BcEJEO0FBcUJBLEtBM0NNOztBQTZDUCxhQUFTLGVBQVU1TSxJQUFWLEVBQWdCOE0sSUFBaEIsRUFBc0I5RCxRQUF0QixFQUFnQzlLLEtBQWhDLEVBQXVDRSxJQUF2QyxFQUE4QztBQUN0RCxTQUFJMk8sU0FBUy9NLEtBQUsxRSxLQUFMLENBQVksQ0FBWixFQUFlLENBQWYsTUFBdUIsS0FBcEM7QUFBQSxTQUNDMFIsVUFBVWhOLEtBQUsxRSxLQUFMLENBQVksQ0FBQyxDQUFiLE1BQXFCLE1BRGhDO0FBQUEsU0FFQzJSLFNBQVNILFNBQVMsU0FGbkI7O0FBSUEsWUFBTzVPLFVBQVUsQ0FBVixJQUFlRSxTQUFTLENBQXhCOztBQUVOO0FBQ0EsZUFBVU4sSUFBVixFQUFpQjtBQUNoQixhQUFPLENBQUMsQ0FBQ0EsS0FBSzZJLFVBQWQ7QUFDQSxNQUxLLEdBT04sVUFBVTdJLElBQVYsRUFBZ0IzQixPQUFoQixFQUF5QitRLEdBQXpCLEVBQStCO0FBQzlCLFVBQUl0RixLQUFKO0FBQUEsVUFBV3VGLFVBQVg7QUFBQSxVQUF1QmhFLElBQXZCO0FBQUEsVUFBNkJULElBQTdCO0FBQUEsVUFBbUMwRSxTQUFuQztBQUFBLFVBQThDQyxLQUE5QztBQUFBLFVBQ0NoQixNQUFNVSxXQUFXQyxPQUFYLEdBQXFCLGFBQXJCLEdBQXFDLGlCQUQ1QztBQUFBLFVBRUMxRCxTQUFTeEwsS0FBSzZJLFVBRmY7QUFBQSxVQUdDN0gsT0FBT21PLFVBQVVuUCxLQUFLaUQsUUFBTCxDQUFjQyxXQUFkLEVBSGxCO0FBQUEsVUFJQ3NNLFdBQVcsQ0FBQ0osR0FBRCxJQUFRLENBQUNELE1BSnJCOztBQU1BLFVBQUszRCxNQUFMLEVBQWM7O0FBRWI7QUFDQSxXQUFLeUQsTUFBTCxFQUFjO0FBQ2IsZUFBUVYsR0FBUixFQUFjO0FBQ2JsRCxnQkFBT3JMLElBQVA7QUFDQSxnQkFBU3FMLE9BQU9BLEtBQU1rRCxHQUFOLENBQWhCLEVBQStCO0FBQzlCLGNBQUtZLFNBQVM5RCxLQUFLcEksUUFBTCxDQUFjQyxXQUFkLE9BQWdDbEMsSUFBekMsR0FBZ0RxSyxLQUFLNUksUUFBTCxLQUFrQixDQUF2RSxFQUEyRTtBQUMxRSxrQkFBTyxLQUFQO0FBQ0E7QUFDRDtBQUNEO0FBQ0E4TSxpQkFBUWhCLE1BQU1yTSxTQUFTLE1BQVQsSUFBbUIsQ0FBQ3FOLEtBQXBCLElBQTZCLGFBQTNDO0FBQ0E7QUFDRCxlQUFPLElBQVA7QUFDQTs7QUFFREEsZUFBUSxDQUFFTCxVQUFVMUQsT0FBT1MsVUFBakIsR0FBOEJULE9BQU9pRSxTQUF2QyxDQUFSOztBQUVBO0FBQ0EsV0FBS1AsV0FBV00sUUFBaEIsRUFBMkI7QUFDMUI7QUFDQUgscUJBQWE3RCxPQUFRL0osT0FBUixNQUFzQitKLE9BQVEvSixPQUFSLElBQW9CLEVBQTFDLENBQWI7QUFDQXFJLGdCQUFRdUYsV0FBWW5OLElBQVosS0FBc0IsRUFBOUI7QUFDQW9OLG9CQUFZeEYsTUFBTSxDQUFOLE1BQWF0RSxPQUFiLElBQXdCc0UsTUFBTSxDQUFOLENBQXBDO0FBQ0FjLGVBQU9kLE1BQU0sQ0FBTixNQUFhdEUsT0FBYixJQUF3QnNFLE1BQU0sQ0FBTixDQUEvQjtBQUNBdUIsZUFBT2lFLGFBQWE5RCxPQUFPeEQsVUFBUCxDQUFtQnNILFNBQW5CLENBQXBCOztBQUVBLGVBQVNqRSxPQUFPLEVBQUVpRSxTQUFGLElBQWVqRSxJQUFmLElBQXVCQSxLQUFNa0QsR0FBTixDQUF2Qjs7QUFFZjtBQUNDM0QsZUFBTzBFLFlBQVksQ0FITCxLQUdXQyxNQUFNcEosR0FBTixFQUgzQixFQUcwQzs7QUFFekM7QUFDQSxhQUFLa0YsS0FBSzVJLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUIsRUFBRW1JLElBQXpCLElBQWlDUyxTQUFTckwsSUFBL0MsRUFBc0Q7QUFDckRxUCxxQkFBWW5OLElBQVosSUFBcUIsQ0FBRXNELE9BQUYsRUFBVzhKLFNBQVgsRUFBc0IxRSxJQUF0QixDQUFyQjtBQUNBO0FBQ0E7QUFDRDs7QUFFRjtBQUNDLFFBckJELE1BcUJPLElBQUs0RSxhQUFhMUYsUUFBUSxDQUFDOUosS0FBTXlCLE9BQU4sTUFBb0J6QixLQUFNeUIsT0FBTixJQUFrQixFQUF0QyxDQUFELEVBQTZDUyxJQUE3QyxDQUFyQixLQUE2RTRILE1BQU0sQ0FBTixNQUFhdEUsT0FBL0YsRUFBeUc7QUFDL0dvRixlQUFPZCxNQUFNLENBQU4sQ0FBUDs7QUFFRDtBQUNDLFFBSk0sTUFJQTtBQUNOO0FBQ0EsZUFBU3VCLE9BQU8sRUFBRWlFLFNBQUYsSUFBZWpFLElBQWYsSUFBdUJBLEtBQU1rRCxHQUFOLENBQXZCLEtBQ2QzRCxPQUFPMEUsWUFBWSxDQURMLEtBQ1dDLE1BQU1wSixHQUFOLEVBRDNCLEVBQzBDOztBQUV6QyxhQUFLLENBQUVnSixTQUFTOUQsS0FBS3BJLFFBQUwsQ0FBY0MsV0FBZCxPQUFnQ2xDLElBQXpDLEdBQWdEcUssS0FBSzVJLFFBQUwsS0FBa0IsQ0FBcEUsS0FBMkUsRUFBRW1JLElBQWxGLEVBQXlGO0FBQ3hGO0FBQ0EsY0FBSzRFLFFBQUwsRUFBZ0I7QUFDZixZQUFDbkUsS0FBTTVKLE9BQU4sTUFBb0I0SixLQUFNNUosT0FBTixJQUFrQixFQUF0QyxDQUFELEVBQTZDUyxJQUE3QyxJQUFzRCxDQUFFc0QsT0FBRixFQUFXb0YsSUFBWCxDQUF0RDtBQUNBOztBQUVELGNBQUtTLFNBQVNyTCxJQUFkLEVBQXFCO0FBQ3BCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTRLLGVBQVF0SyxJQUFSO0FBQ0EsY0FBT3NLLFNBQVN4SyxLQUFULElBQW9Cd0ssT0FBT3hLLEtBQVAsS0FBaUIsQ0FBakIsSUFBc0J3SyxPQUFPeEssS0FBUCxJQUFnQixDQUFqRTtBQUNBO0FBQ0QsTUFqRkY7QUFrRkEsS0FwSU07O0FBc0lQLGNBQVUsZ0JBQVVzUCxNQUFWLEVBQWtCeEUsUUFBbEIsRUFBNkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFJcEwsSUFBSjtBQUFBLFNBQ0N4QixLQUFLb0csS0FBS2dDLE9BQUwsQ0FBY2dKLE1BQWQsS0FBMEJoTCxLQUFLaUwsVUFBTCxDQUFpQkQsT0FBT3hNLFdBQVAsRUFBakIsQ0FBMUIsSUFDSnVCLE9BQU8zQyxLQUFQLENBQWMseUJBQXlCNE4sTUFBdkMsQ0FGRjs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxTQUFLcFIsR0FBSW1ELE9BQUosQ0FBTCxFQUFxQjtBQUNwQixhQUFPbkQsR0FBSTRNLFFBQUosQ0FBUDtBQUNBOztBQUVEO0FBQ0EsU0FBSzVNLEdBQUdZLE1BQUgsR0FBWSxDQUFqQixFQUFxQjtBQUNwQlksYUFBTyxDQUFFNFAsTUFBRixFQUFVQSxNQUFWLEVBQWtCLEVBQWxCLEVBQXNCeEUsUUFBdEIsQ0FBUDtBQUNBLGFBQU94RyxLQUFLaUwsVUFBTCxDQUFnQjVSLGNBQWhCLENBQWdDMlIsT0FBT3hNLFdBQVAsRUFBaEMsSUFDTitHLGFBQWEsVUFBVS9CLElBQVYsRUFBZ0JsRSxPQUFoQixFQUEwQjtBQUN0QyxXQUFJNEwsR0FBSjtBQUFBLFdBQ0NDLFVBQVV2UixHQUFJNEosSUFBSixFQUFVZ0QsUUFBVixDQURYO0FBQUEsV0FFQ2pMLElBQUk0UCxRQUFRM1EsTUFGYjtBQUdBLGNBQVFlLEdBQVIsRUFBYztBQUNiMlAsY0FBTWpTLFFBQVF5QixJQUFSLENBQWM4SSxJQUFkLEVBQW9CMkgsUUFBUTVQLENBQVIsQ0FBcEIsQ0FBTjtBQUNBaUksYUFBTTBILEdBQU4sSUFBYyxFQUFHNUwsUUFBUzRMLEdBQVQsSUFBaUJDLFFBQVE1UCxDQUFSLENBQXBCLENBQWQ7QUFDQTtBQUNELE9BUkQsQ0FETSxHQVVOLFVBQVVELElBQVYsRUFBaUI7QUFDaEIsY0FBTzFCLEdBQUkwQixJQUFKLEVBQVUsQ0FBVixFQUFhRixJQUFiLENBQVA7QUFDQSxPQVpGO0FBYUE7O0FBRUQsWUFBT3hCLEVBQVA7QUFDQTtBQXpLTSxJQS9GaUI7O0FBMlF6Qm9JLFlBQVM7QUFDUjtBQUNBLFdBQU91RCxhQUFhLFVBQVU3TCxRQUFWLEVBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQUlxTyxRQUFRLEVBQVo7QUFBQSxTQUNDakosVUFBVSxFQURYO0FBQUEsU0FFQ3NNLFVBQVVqTCxRQUFTekcsU0FBU3dELE9BQVQsQ0FBa0JwRCxLQUFsQixFQUF5QixJQUF6QixDQUFULENBRlg7O0FBSUEsWUFBT3NSLFFBQVNyTyxPQUFULElBQ053SSxhQUFhLFVBQVUvQixJQUFWLEVBQWdCbEUsT0FBaEIsRUFBeUIzRixPQUF6QixFQUFrQytRLEdBQWxDLEVBQXdDO0FBQ3BELFVBQUlwUCxJQUFKO0FBQUEsVUFDQytQLFlBQVlELFFBQVM1SCxJQUFULEVBQWUsSUFBZixFQUFxQmtILEdBQXJCLEVBQTBCLEVBQTFCLENBRGI7QUFBQSxVQUVDblAsSUFBSWlJLEtBQUtoSixNQUZWOztBQUlBO0FBQ0EsYUFBUWUsR0FBUixFQUFjO0FBQ2IsV0FBTUQsT0FBTytQLFVBQVU5UCxDQUFWLENBQWIsRUFBNkI7QUFDNUJpSSxhQUFLakksQ0FBTCxJQUFVLEVBQUUrRCxRQUFRL0QsQ0FBUixJQUFhRCxJQUFmLENBQVY7QUFDQTtBQUNEO0FBQ0QsTUFYRCxDQURNLEdBYU4sVUFBVUEsSUFBVixFQUFnQjNCLE9BQWhCLEVBQXlCK1EsR0FBekIsRUFBK0I7QUFDOUIzQyxZQUFNLENBQU4sSUFBV3pNLElBQVg7QUFDQThQLGNBQVNyRCxLQUFULEVBQWdCLElBQWhCLEVBQXNCMkMsR0FBdEIsRUFBMkI1TCxPQUEzQjtBQUNBLGFBQU8sQ0FBQ0EsUUFBUTJDLEdBQVIsRUFBUjtBQUNBLE1BakJGO0FBa0JBLEtBMUJNLENBRkM7O0FBOEJSLFdBQU84RCxhQUFhLFVBQVU3TCxRQUFWLEVBQXFCO0FBQ3hDLFlBQU8sVUFBVTRCLElBQVYsRUFBaUI7QUFDdkIsYUFBT3lFLE9BQVFyRyxRQUFSLEVBQWtCNEIsSUFBbEIsRUFBeUJkLE1BQXpCLEdBQWtDLENBQXpDO0FBQ0EsTUFGRDtBQUdBLEtBSk0sQ0E5QkM7O0FBb0NSLGdCQUFZK0ssYUFBYSxVQUFVNUcsSUFBVixFQUFpQjtBQUN6QyxZQUFPLFVBQVVyRCxJQUFWLEVBQWlCO0FBQ3ZCLGFBQU8sQ0FBRUEsS0FBS2tPLFdBQUwsSUFBb0JsTyxLQUFLZ1EsU0FBekIsSUFBc0NyTCxRQUFTM0UsSUFBVCxDQUF4QyxFQUEwRHJDLE9BQTFELENBQW1FMEYsSUFBbkUsSUFBNEUsQ0FBQyxDQUFwRjtBQUNBLE1BRkQ7QUFHQSxLQUpXLENBcENKOztBQTBDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVE0RyxhQUFjLFVBQVVnRyxJQUFWLEVBQWlCO0FBQ3RDO0FBQ0EsU0FBSyxDQUFDakosWUFBWWtDLElBQVosQ0FBaUIrRyxRQUFRLEVBQXpCLENBQU4sRUFBcUM7QUFDcEN4TCxhQUFPM0MsS0FBUCxDQUFjLHVCQUF1Qm1PLElBQXJDO0FBQ0E7QUFDREEsWUFBT0EsS0FBS3JPLE9BQUwsQ0FBYzRGLFNBQWQsRUFBeUJDLFNBQXpCLEVBQXFDdkUsV0FBckMsRUFBUDtBQUNBLFlBQU8sVUFBVWxELElBQVYsRUFBaUI7QUFDdkIsVUFBSWtRLFFBQUo7QUFDQSxTQUFHO0FBQ0YsV0FBTUEsV0FBVy9LLGlCQUNoQm5GLEtBQUtpUSxJQURXLEdBRWhCalEsS0FBS29KLFlBQUwsQ0FBa0IsVUFBbEIsS0FBaUNwSixLQUFLb0osWUFBTCxDQUFrQixNQUFsQixDQUZsQyxFQUUrRDs7QUFFOUQ4RyxtQkFBV0EsU0FBU2hOLFdBQVQsRUFBWDtBQUNBLGVBQU9nTixhQUFhRCxJQUFiLElBQXFCQyxTQUFTdlMsT0FBVCxDQUFrQnNTLE9BQU8sR0FBekIsTUFBbUMsQ0FBL0Q7QUFDQTtBQUNELE9BUkQsUUFRVSxDQUFDalEsT0FBT0EsS0FBSzZJLFVBQWIsS0FBNEI3SSxLQUFLeUMsUUFBTCxLQUFrQixDQVJ4RDtBQVNBLGFBQU8sS0FBUDtBQUNBLE1BWkQ7QUFhQSxLQW5CTyxDQWpEQTs7QUFzRVI7QUFDQSxjQUFVLGdCQUFVekMsSUFBVixFQUFpQjtBQUMxQixTQUFJbVEsT0FBTzlTLE9BQU8rUyxRQUFQLElBQW1CL1MsT0FBTytTLFFBQVAsQ0FBZ0JELElBQTlDO0FBQ0EsWUFBT0EsUUFBUUEsS0FBSzNTLEtBQUwsQ0FBWSxDQUFaLE1BQW9Cd0MsS0FBSzhJLEVBQXhDO0FBQ0EsS0ExRU87O0FBNEVSLFlBQVEsY0FBVTlJLElBQVYsRUFBaUI7QUFDeEIsWUFBT0EsU0FBU2tGLE9BQWhCO0FBQ0EsS0E5RU87O0FBZ0ZSLGFBQVMsZUFBVWxGLElBQVYsRUFBaUI7QUFDekIsWUFBT0EsU0FBUzlDLFNBQVNtVCxhQUFsQixLQUFvQyxDQUFDblQsU0FBU29ULFFBQVYsSUFBc0JwVCxTQUFTb1QsUUFBVCxFQUExRCxLQUFrRixDQUFDLEVBQUV0USxLQUFLa0MsSUFBTCxJQUFhbEMsS0FBS3VRLElBQWxCLElBQTBCLENBQUN2USxLQUFLd1EsUUFBbEMsQ0FBMUY7QUFDQSxLQWxGTzs7QUFvRlI7QUFDQSxlQUFXLGlCQUFVeFEsSUFBVixFQUFpQjtBQUMzQixZQUFPQSxLQUFLeVEsUUFBTCxLQUFrQixLQUF6QjtBQUNBLEtBdkZPOztBQXlGUixnQkFBWSxrQkFBVXpRLElBQVYsRUFBaUI7QUFDNUIsWUFBT0EsS0FBS3lRLFFBQUwsS0FBa0IsSUFBekI7QUFDQSxLQTNGTzs7QUE2RlIsZUFBVyxpQkFBVXpRLElBQVYsRUFBaUI7QUFDM0I7QUFDQTtBQUNBLFNBQUlpRCxXQUFXakQsS0FBS2lELFFBQUwsQ0FBY0MsV0FBZCxFQUFmO0FBQ0EsWUFBUUQsYUFBYSxPQUFiLElBQXdCLENBQUMsQ0FBQ2pELEtBQUswUSxPQUFoQyxJQUE2Q3pOLGFBQWEsUUFBYixJQUF5QixDQUFDLENBQUNqRCxLQUFLMlEsUUFBcEY7QUFDQSxLQWxHTzs7QUFvR1IsZ0JBQVksa0JBQVUzUSxJQUFWLEVBQWlCO0FBQzVCO0FBQ0E7QUFDQSxTQUFLQSxLQUFLNkksVUFBVixFQUF1QjtBQUN0QjdJLFdBQUs2SSxVQUFMLENBQWdCK0gsYUFBaEI7QUFDQTs7QUFFRCxZQUFPNVEsS0FBSzJRLFFBQUwsS0FBa0IsSUFBekI7QUFDQSxLQTVHTzs7QUE4R1I7QUFDQSxhQUFTLGVBQVUzUSxJQUFWLEVBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBTUEsT0FBT0EsS0FBS2lNLFVBQWxCLEVBQThCak0sSUFBOUIsRUFBb0NBLE9BQU9BLEtBQUs4SyxXQUFoRCxFQUE4RDtBQUM3RCxVQUFLOUssS0FBS3lDLFFBQUwsR0FBZ0IsQ0FBckIsRUFBeUI7QUFDeEIsY0FBTyxLQUFQO0FBQ0E7QUFDRDtBQUNELFlBQU8sSUFBUDtBQUNBLEtBMUhPOztBQTRIUixjQUFVLGdCQUFVekMsSUFBVixFQUFpQjtBQUMxQixZQUFPLENBQUMwRSxLQUFLZ0MsT0FBTCxDQUFhLE9BQWIsRUFBdUIxRyxJQUF2QixDQUFSO0FBQ0EsS0E5SE87O0FBZ0lSO0FBQ0EsY0FBVSxnQkFBVUEsSUFBVixFQUFpQjtBQUMxQixZQUFPbUgsUUFBUStCLElBQVIsQ0FBY2xKLEtBQUtpRCxRQUFuQixDQUFQO0FBQ0EsS0FuSU87O0FBcUlSLGFBQVMsZUFBVWpELElBQVYsRUFBaUI7QUFDekIsWUFBT2tILFFBQVFnQyxJQUFSLENBQWNsSixLQUFLaUQsUUFBbkIsQ0FBUDtBQUNBLEtBdklPOztBQXlJUixjQUFVLGdCQUFVakQsSUFBVixFQUFpQjtBQUMxQixTQUFJZ0IsT0FBT2hCLEtBQUtpRCxRQUFMLENBQWNDLFdBQWQsRUFBWDtBQUNBLFlBQU9sQyxTQUFTLE9BQVQsSUFBb0JoQixLQUFLa0MsSUFBTCxLQUFjLFFBQWxDLElBQThDbEIsU0FBUyxRQUE5RDtBQUNBLEtBNUlPOztBQThJUixZQUFRLGNBQVVoQixJQUFWLEVBQWlCO0FBQ3hCLFNBQUkyTixJQUFKO0FBQ0EsWUFBTzNOLEtBQUtpRCxRQUFMLENBQWNDLFdBQWQsT0FBZ0MsT0FBaEMsSUFDTmxELEtBQUtrQyxJQUFMLEtBQWMsTUFEUjs7QUFHTjtBQUNBO0FBQ0UsTUFBQ3lMLE9BQU8zTixLQUFLb0osWUFBTCxDQUFrQixNQUFsQixDQUFSLEtBQXNDLElBQXRDLElBQThDdUUsS0FBS3pLLFdBQUwsT0FBdUIsTUFMakUsQ0FBUDtBQU1BLEtBdEpPOztBQXdKUjtBQUNBLGFBQVMrSCx1QkFBdUIsWUFBVztBQUMxQyxZQUFPLENBQUUsQ0FBRixDQUFQO0FBQ0EsS0FGUSxDQXpKRDs7QUE2SlIsWUFBUUEsdUJBQXVCLFVBQVVFLFlBQVYsRUFBd0JqTSxNQUF4QixFQUFpQztBQUMvRCxZQUFPLENBQUVBLFNBQVMsQ0FBWCxDQUFQO0FBQ0EsS0FGTyxDQTdKQTs7QUFpS1IsVUFBTStMLHVCQUF1QixVQUFVRSxZQUFWLEVBQXdCak0sTUFBeEIsRUFBZ0NnTSxRQUFoQyxFQUEyQztBQUN2RSxZQUFPLENBQUVBLFdBQVcsQ0FBWCxHQUFlQSxXQUFXaE0sTUFBMUIsR0FBbUNnTSxRQUFyQyxDQUFQO0FBQ0EsS0FGSyxDQWpLRTs7QUFxS1IsWUFBUUQsdUJBQXVCLFVBQVVFLFlBQVYsRUFBd0JqTSxNQUF4QixFQUFpQztBQUMvRCxTQUFJZSxJQUFJLENBQVI7QUFDQSxZQUFRQSxJQUFJZixNQUFaLEVBQW9CZSxLQUFLLENBQXpCLEVBQTZCO0FBQzVCa0wsbUJBQWF6TixJQUFiLENBQW1CdUMsQ0FBbkI7QUFDQTtBQUNELFlBQU9rTCxZQUFQO0FBQ0EsS0FOTyxDQXJLQTs7QUE2S1IsV0FBT0YsdUJBQXVCLFVBQVVFLFlBQVYsRUFBd0JqTSxNQUF4QixFQUFpQztBQUM5RCxTQUFJZSxJQUFJLENBQVI7QUFDQSxZQUFRQSxJQUFJZixNQUFaLEVBQW9CZSxLQUFLLENBQXpCLEVBQTZCO0FBQzVCa0wsbUJBQWF6TixJQUFiLENBQW1CdUMsQ0FBbkI7QUFDQTtBQUNELFlBQU9rTCxZQUFQO0FBQ0EsS0FOTSxDQTdLQzs7QUFxTFIsVUFBTUYsdUJBQXVCLFVBQVVFLFlBQVYsRUFBd0JqTSxNQUF4QixFQUFnQ2dNLFFBQWhDLEVBQTJDO0FBQ3ZFLFNBQUlqTCxJQUFJaUwsV0FBVyxDQUFYLEdBQWVBLFdBQVdoTSxNQUExQixHQUFtQ2dNLFFBQTNDO0FBQ0EsWUFBUSxFQUFFakwsQ0FBRixJQUFPLENBQWYsR0FBb0I7QUFDbkJrTCxtQkFBYXpOLElBQWIsQ0FBbUJ1QyxDQUFuQjtBQUNBO0FBQ0QsWUFBT2tMLFlBQVA7QUFDQSxLQU5LLENBckxFOztBQTZMUixVQUFNRix1QkFBdUIsVUFBVUUsWUFBVixFQUF3QmpNLE1BQXhCLEVBQWdDZ00sUUFBaEMsRUFBMkM7QUFDdkUsU0FBSWpMLElBQUlpTCxXQUFXLENBQVgsR0FBZUEsV0FBV2hNLE1BQTFCLEdBQW1DZ00sUUFBM0M7QUFDQSxZQUFRLEVBQUVqTCxDQUFGLEdBQU1mLE1BQWQsR0FBd0I7QUFDdkJpTSxtQkFBYXpOLElBQWIsQ0FBbUJ1QyxDQUFuQjtBQUNBO0FBQ0QsWUFBT2tMLFlBQVA7QUFDQSxLQU5LO0FBN0xFO0FBM1FnQixHQUExQjs7QUFrZEF6RyxPQUFLZ0MsT0FBTCxDQUFhLEtBQWIsSUFBc0JoQyxLQUFLZ0MsT0FBTCxDQUFhLElBQWIsQ0FBdEI7O0FBRUE7QUFDQSxPQUFNekcsQ0FBTixJQUFXLEVBQUU0USxPQUFPLElBQVQsRUFBZUMsVUFBVSxJQUF6QixFQUErQkMsTUFBTSxJQUFyQyxFQUEyQ0MsVUFBVSxJQUFyRCxFQUEyREMsT0FBTyxJQUFsRSxFQUFYLEVBQXNGO0FBQ3JGdk0sUUFBS2dDLE9BQUwsQ0FBY3pHLENBQWQsSUFBb0I4SyxrQkFBbUI5SyxDQUFuQixDQUFwQjtBQUNBO0FBQ0QsT0FBTUEsQ0FBTixJQUFXLEVBQUVpUixRQUFRLElBQVYsRUFBZ0JDLE9BQU8sSUFBdkIsRUFBWCxFQUEyQztBQUMxQ3pNLFFBQUtnQyxPQUFMLENBQWN6RyxDQUFkLElBQW9CK0ssbUJBQW9CL0ssQ0FBcEIsQ0FBcEI7QUFDQTs7QUFFRDtBQUNBLFdBQVMwUCxVQUFULEdBQXNCLENBQUU7QUFDeEJBLGFBQVc1USxTQUFYLEdBQXVCMkYsS0FBSzBNLE9BQUwsR0FBZTFNLEtBQUtnQyxPQUEzQztBQUNBaEMsT0FBS2lMLFVBQUwsR0FBa0IsSUFBSUEsVUFBSixFQUFsQjs7QUFFQSxXQUFTeEcsUUFBVCxDQUFtQi9LLFFBQW5CLEVBQTZCaVQsU0FBN0IsRUFBeUM7QUFDeEMsT0FBSXhCLE9BQUo7QUFBQSxPQUFhMUgsS0FBYjtBQUFBLE9BQW9CbUosTUFBcEI7QUFBQSxPQUE0QnBQLElBQTVCO0FBQUEsT0FDQ3FQLEtBREQ7QUFBQSxPQUNRbEosTUFEUjtBQUFBLE9BQ2dCbUosVUFEaEI7QUFBQSxPQUVDQyxTQUFTN0wsV0FBWXhILFdBQVcsR0FBdkIsQ0FGVjs7QUFJQSxPQUFLcVQsTUFBTCxFQUFjO0FBQ2IsV0FBT0osWUFBWSxDQUFaLEdBQWdCSSxPQUFPalUsS0FBUCxDQUFjLENBQWQsQ0FBdkI7QUFDQTs7QUFFRCtULFdBQVFuVCxRQUFSO0FBQ0FpSyxZQUFTLEVBQVQ7QUFDQW1KLGdCQUFhOU0sS0FBSzhKLFNBQWxCOztBQUVBLFVBQVErQyxLQUFSLEVBQWdCOztBQUVmO0FBQ0EsUUFBSyxDQUFDMUIsT0FBRCxLQUFhMUgsUUFBUXZCLE9BQU8rQixJQUFQLENBQWE0SSxLQUFiLENBQXJCLENBQUwsRUFBa0Q7QUFDakQsU0FBS3BKLEtBQUwsRUFBYTtBQUNaO0FBQ0FvSixjQUFRQSxNQUFNL1QsS0FBTixDQUFhMkssTUFBTSxDQUFOLEVBQVNqSixNQUF0QixLQUFrQ3FTLEtBQTFDO0FBQ0E7QUFDRGxKLFlBQU8zSyxJQUFQLENBQWM0VCxTQUFTLEVBQXZCO0FBQ0E7O0FBRUR6QixjQUFVLEtBQVY7O0FBRUE7QUFDQSxRQUFNMUgsUUFBUXRCLGFBQWE4QixJQUFiLENBQW1CNEksS0FBbkIsQ0FBZCxFQUE0QztBQUMzQzFCLGVBQVUxSCxNQUFNNkIsS0FBTixFQUFWO0FBQ0FzSCxZQUFPNVQsSUFBUCxDQUFZO0FBQ1h5RixhQUFPME0sT0FESTtBQUVYO0FBQ0EzTixZQUFNaUcsTUFBTSxDQUFOLEVBQVN2RyxPQUFULENBQWtCcEQsS0FBbEIsRUFBeUIsR0FBekI7QUFISyxNQUFaO0FBS0ErUyxhQUFRQSxNQUFNL1QsS0FBTixDQUFhcVMsUUFBUTNRLE1BQXJCLENBQVI7QUFDQTs7QUFFRDtBQUNBLFNBQU1nRCxJQUFOLElBQWN3QyxLQUFLMkgsTUFBbkIsRUFBNEI7QUFDM0IsU0FBSyxDQUFDbEUsUUFBUWxCLFVBQVcvRSxJQUFYLEVBQWtCeUcsSUFBbEIsQ0FBd0I0SSxLQUF4QixDQUFULE1BQThDLENBQUNDLFdBQVl0UCxJQUFaLENBQUQsS0FDakRpRyxRQUFRcUosV0FBWXRQLElBQVosRUFBb0JpRyxLQUFwQixDQUR5QyxDQUE5QyxDQUFMLEVBQzBDO0FBQ3pDMEgsZ0JBQVUxSCxNQUFNNkIsS0FBTixFQUFWO0FBQ0FzSCxhQUFPNVQsSUFBUCxDQUFZO0FBQ1h5RixjQUFPME0sT0FESTtBQUVYM04sYUFBTUEsSUFGSztBQUdYOEIsZ0JBQVNtRTtBQUhFLE9BQVo7QUFLQW9KLGNBQVFBLE1BQU0vVCxLQUFOLENBQWFxUyxRQUFRM1EsTUFBckIsQ0FBUjtBQUNBO0FBQ0Q7O0FBRUQsUUFBSyxDQUFDMlEsT0FBTixFQUFnQjtBQUNmO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFPd0IsWUFDTkUsTUFBTXJTLE1BREEsR0FFTnFTLFFBQ0M5TSxPQUFPM0MsS0FBUCxDQUFjMUQsUUFBZCxDQUREO0FBRUM7QUFDQXdILGNBQVl4SCxRQUFaLEVBQXNCaUssTUFBdEIsRUFBK0I3SyxLQUEvQixDQUFzQyxDQUF0QyxDQUxGO0FBTUE7O0FBRUQsV0FBUzhMLFVBQVQsQ0FBcUJnSSxNQUFyQixFQUE4QjtBQUM3QixPQUFJclIsSUFBSSxDQUFSO0FBQUEsT0FDQ00sTUFBTStRLE9BQU9wUyxNQURkO0FBQUEsT0FFQ2QsV0FBVyxFQUZaO0FBR0EsVUFBUTZCLElBQUlNLEdBQVosRUFBaUJOLEdBQWpCLEVBQXVCO0FBQ3RCN0IsZ0JBQVlrVCxPQUFPclIsQ0FBUCxFQUFVa0QsS0FBdEI7QUFDQTtBQUNELFVBQU8vRSxRQUFQO0FBQ0E7O0FBRUQsV0FBU3NULGFBQVQsQ0FBd0I1QixPQUF4QixFQUFpQzZCLFVBQWpDLEVBQTZDQyxJQUE3QyxFQUFvRDtBQUNuRCxPQUFJckQsTUFBTW9ELFdBQVdwRCxHQUFyQjtBQUFBLE9BQ0NzRCxtQkFBbUJELFFBQVFyRCxRQUFRLFlBRHBDO0FBQUEsT0FFQ3VELFdBQVdyTSxNQUZaOztBQUlBLFVBQU9rTSxXQUFXdlIsS0FBWDtBQUNOO0FBQ0EsYUFBVUosSUFBVixFQUFnQjNCLE9BQWhCLEVBQXlCK1EsR0FBekIsRUFBK0I7QUFDOUIsV0FBU3BQLE9BQU9BLEtBQU11TyxHQUFOLENBQWhCLEVBQStCO0FBQzlCLFNBQUt2TyxLQUFLeUMsUUFBTCxLQUFrQixDQUFsQixJQUF1Qm9QLGdCQUE1QixFQUErQztBQUM5QyxhQUFPL0IsUUFBUzlQLElBQVQsRUFBZTNCLE9BQWYsRUFBd0IrUSxHQUF4QixDQUFQO0FBQ0E7QUFDRDtBQUNELElBUks7O0FBVU47QUFDQSxhQUFVcFAsSUFBVixFQUFnQjNCLE9BQWhCLEVBQXlCK1EsR0FBekIsRUFBK0I7QUFDOUIsUUFBSTJDLFFBQUo7QUFBQSxRQUFjMUMsVUFBZDtBQUFBLFFBQ0MyQyxXQUFXLENBQUV4TSxPQUFGLEVBQVdzTSxRQUFYLENBRFo7O0FBR0E7QUFDQSxRQUFLMUMsR0FBTCxFQUFXO0FBQ1YsWUFBU3BQLE9BQU9BLEtBQU11TyxHQUFOLENBQWhCLEVBQStCO0FBQzlCLFVBQUt2TyxLQUFLeUMsUUFBTCxLQUFrQixDQUFsQixJQUF1Qm9QLGdCQUE1QixFQUErQztBQUM5QyxXQUFLL0IsUUFBUzlQLElBQVQsRUFBZTNCLE9BQWYsRUFBd0IrUSxHQUF4QixDQUFMLEVBQXFDO0FBQ3BDLGVBQU8sSUFBUDtBQUNBO0FBQ0Q7QUFDRDtBQUNELEtBUkQsTUFRTztBQUNOLFlBQVNwUCxPQUFPQSxLQUFNdU8sR0FBTixDQUFoQixFQUErQjtBQUM5QixVQUFLdk8sS0FBS3lDLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUJvUCxnQkFBNUIsRUFBK0M7QUFDOUN4QyxvQkFBYXJQLEtBQU15QixPQUFOLE1BQW9CekIsS0FBTXlCLE9BQU4sSUFBa0IsRUFBdEMsQ0FBYjtBQUNBLFdBQUssQ0FBQ3NRLFdBQVcxQyxXQUFZZCxHQUFaLENBQVosS0FDSndELFNBQVUsQ0FBVixNQUFrQnZNLE9BRGQsSUFDeUJ1TSxTQUFVLENBQVYsTUFBa0JELFFBRGhELEVBQzJEOztBQUUxRDtBQUNBLGVBQVFFLFNBQVUsQ0FBVixJQUFnQkQsU0FBVSxDQUFWLENBQXhCO0FBQ0EsUUFMRCxNQUtPO0FBQ047QUFDQTFDLG1CQUFZZCxHQUFaLElBQW9CeUQsUUFBcEI7O0FBRUE7QUFDQSxZQUFNQSxTQUFVLENBQVYsSUFBZ0JsQyxRQUFTOVAsSUFBVCxFQUFlM0IsT0FBZixFQUF3QitRLEdBQXhCLENBQXRCLEVBQXVEO0FBQ3RELGdCQUFPLElBQVA7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEO0FBQ0QsSUE3Q0Y7QUE4Q0E7O0FBRUQsV0FBUzZDLGNBQVQsQ0FBeUJDLFFBQXpCLEVBQW9DO0FBQ25DLFVBQU9BLFNBQVNoVCxNQUFULEdBQWtCLENBQWxCLEdBQ04sVUFBVWMsSUFBVixFQUFnQjNCLE9BQWhCLEVBQXlCK1EsR0FBekIsRUFBK0I7QUFDOUIsUUFBSW5QLElBQUlpUyxTQUFTaFQsTUFBakI7QUFDQSxXQUFRZSxHQUFSLEVBQWM7QUFDYixTQUFLLENBQUNpUyxTQUFTalMsQ0FBVCxFQUFhRCxJQUFiLEVBQW1CM0IsT0FBbkIsRUFBNEIrUSxHQUE1QixDQUFOLEVBQTBDO0FBQ3pDLGFBQU8sS0FBUDtBQUNBO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDQSxJQVRLLEdBVU44QyxTQUFTLENBQVQsQ0FWRDtBQVdBOztBQUVELFdBQVNDLFFBQVQsQ0FBbUJwQyxTQUFuQixFQUE4QmhRLEdBQTlCLEVBQW1Dc00sTUFBbkMsRUFBMkNoTyxPQUEzQyxFQUFvRCtRLEdBQXBELEVBQTBEO0FBQ3pELE9BQUlwUCxJQUFKO0FBQUEsT0FDQ29TLGVBQWUsRUFEaEI7QUFBQSxPQUVDblMsSUFBSSxDQUZMO0FBQUEsT0FHQ00sTUFBTXdQLFVBQVU3USxNQUhqQjtBQUFBLE9BSUNtVCxTQUFTdFMsT0FBTyxJQUpqQjs7QUFNQSxVQUFRRSxJQUFJTSxHQUFaLEVBQWlCTixHQUFqQixFQUF1QjtBQUN0QixRQUFNRCxPQUFPK1AsVUFBVTlQLENBQVYsQ0FBYixFQUE2QjtBQUM1QixTQUFLLENBQUNvTSxNQUFELElBQVdBLE9BQVFyTSxJQUFSLEVBQWMzQixPQUFkLEVBQXVCK1EsR0FBdkIsQ0FBaEIsRUFBK0M7QUFDOUNnRCxtQkFBYTFVLElBQWIsQ0FBbUJzQyxJQUFuQjtBQUNBLFVBQUtxUyxNQUFMLEVBQWM7QUFDYnRTLFdBQUlyQyxJQUFKLENBQVV1QyxDQUFWO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsVUFBT21TLFlBQVA7QUFDQTs7QUFFRCxXQUFTRSxVQUFULENBQXFCOUQsU0FBckIsRUFBZ0NwUSxRQUFoQyxFQUEwQzBSLE9BQTFDLEVBQW1EeUMsVUFBbkQsRUFBK0RDLFVBQS9ELEVBQTJFQyxZQUEzRSxFQUEwRjtBQUN6RixPQUFLRixjQUFjLENBQUNBLFdBQVk5USxPQUFaLENBQXBCLEVBQTRDO0FBQzNDOFEsaUJBQWFELFdBQVlDLFVBQVosQ0FBYjtBQUNBO0FBQ0QsT0FBS0MsY0FBYyxDQUFDQSxXQUFZL1EsT0FBWixDQUFwQixFQUE0QztBQUMzQytRLGlCQUFhRixXQUFZRSxVQUFaLEVBQXdCQyxZQUF4QixDQUFiO0FBQ0E7QUFDRCxVQUFPeEksYUFBYSxVQUFVL0IsSUFBVixFQUFnQjFFLE9BQWhCLEVBQXlCbkYsT0FBekIsRUFBa0MrUSxHQUFsQyxFQUF3QztBQUMzRCxRQUFJc0QsSUFBSjtBQUFBLFFBQVV6UyxDQUFWO0FBQUEsUUFBYUQsSUFBYjtBQUFBLFFBQ0MyUyxTQUFTLEVBRFY7QUFBQSxRQUVDQyxVQUFVLEVBRlg7QUFBQSxRQUdDQyxjQUFjclAsUUFBUXRFLE1BSHZCOzs7QUFLQztBQUNBTSxZQUFRMEksUUFBUTRLLGlCQUFrQjFVLFlBQVksR0FBOUIsRUFBbUNDLFFBQVFvRSxRQUFSLEdBQW1CLENBQUVwRSxPQUFGLENBQW5CLEdBQWlDQSxPQUFwRSxFQUE2RSxFQUE3RSxDQU5qQjs7O0FBUUM7QUFDQTBVLGdCQUFZdkUsY0FBZXRHLFFBQVEsQ0FBQzlKLFFBQXhCLElBQ1grVCxTQUFVM1MsS0FBVixFQUFpQm1ULE1BQWpCLEVBQXlCbkUsU0FBekIsRUFBb0NuUSxPQUFwQyxFQUE2QytRLEdBQTdDLENBRFcsR0FFWDVQLEtBWEY7QUFBQSxRQWFDd1QsYUFBYWxEO0FBQ1o7QUFDQTBDLG1CQUFnQnRLLE9BQU9zRyxTQUFQLEdBQW1CcUUsZUFBZU4sVUFBbEQ7O0FBRUM7QUFDQSxNQUhEOztBQUtDO0FBQ0EvTyxXQVJXLEdBU1p1UCxTQXRCRjs7QUF3QkE7QUFDQSxRQUFLakQsT0FBTCxFQUFlO0FBQ2RBLGFBQVNpRCxTQUFULEVBQW9CQyxVQUFwQixFQUFnQzNVLE9BQWhDLEVBQXlDK1EsR0FBekM7QUFDQTs7QUFFRDtBQUNBLFFBQUttRCxVQUFMLEVBQWtCO0FBQ2pCRyxZQUFPUCxTQUFVYSxVQUFWLEVBQXNCSixPQUF0QixDQUFQO0FBQ0FMLGdCQUFZRyxJQUFaLEVBQWtCLEVBQWxCLEVBQXNCclUsT0FBdEIsRUFBK0IrUSxHQUEvQjs7QUFFQTtBQUNBblAsU0FBSXlTLEtBQUt4VCxNQUFUO0FBQ0EsWUFBUWUsR0FBUixFQUFjO0FBQ2IsVUFBTUQsT0FBTzBTLEtBQUt6UyxDQUFMLENBQWIsRUFBd0I7QUFDdkIrUyxrQkFBWUosUUFBUTNTLENBQVIsQ0FBWixJQUEyQixFQUFFOFMsVUFBV0gsUUFBUTNTLENBQVIsQ0FBWCxJQUEwQkQsSUFBNUIsQ0FBM0I7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsUUFBS2tJLElBQUwsRUFBWTtBQUNYLFNBQUtzSyxjQUFjaEUsU0FBbkIsRUFBK0I7QUFDOUIsVUFBS2dFLFVBQUwsRUFBa0I7QUFDakI7QUFDQUUsY0FBTyxFQUFQO0FBQ0F6UyxXQUFJK1MsV0FBVzlULE1BQWY7QUFDQSxjQUFRZSxHQUFSLEVBQWM7QUFDYixZQUFNRCxPQUFPZ1QsV0FBVy9TLENBQVgsQ0FBYixFQUE4QjtBQUM3QjtBQUNBeVMsY0FBS2hWLElBQUwsQ0FBWXFWLFVBQVU5UyxDQUFWLElBQWVELElBQTNCO0FBQ0E7QUFDRDtBQUNEd1Msa0JBQVksSUFBWixFQUFtQlEsYUFBYSxFQUFoQyxFQUFxQ04sSUFBckMsRUFBMkN0RCxHQUEzQztBQUNBOztBQUVEO0FBQ0FuUCxVQUFJK1MsV0FBVzlULE1BQWY7QUFDQSxhQUFRZSxHQUFSLEVBQWM7QUFDYixXQUFLLENBQUNELE9BQU9nVCxXQUFXL1MsQ0FBWCxDQUFSLEtBQ0osQ0FBQ3lTLE9BQU9GLGFBQWE3VSxRQUFReUIsSUFBUixDQUFjOEksSUFBZCxFQUFvQmxJLElBQXBCLENBQWIsR0FBMEMyUyxPQUFPMVMsQ0FBUCxDQUFsRCxJQUErRCxDQUFDLENBRGpFLEVBQ3FFOztBQUVwRWlJLGFBQUt3SyxJQUFMLElBQWEsRUFBRWxQLFFBQVFrUCxJQUFSLElBQWdCMVMsSUFBbEIsQ0FBYjtBQUNBO0FBQ0Q7QUFDRDs7QUFFRjtBQUNDLEtBM0JELE1BMkJPO0FBQ05nVCxrQkFBYWIsU0FDWmEsZUFBZXhQLE9BQWYsR0FDQ3dQLFdBQVdyUyxNQUFYLENBQW1Ca1MsV0FBbkIsRUFBZ0NHLFdBQVc5VCxNQUEzQyxDQURELEdBRUM4VCxVQUhXLENBQWI7QUFLQSxTQUFLUixVQUFMLEVBQWtCO0FBQ2pCQSxpQkFBWSxJQUFaLEVBQWtCaFAsT0FBbEIsRUFBMkJ3UCxVQUEzQixFQUF1QzVELEdBQXZDO0FBQ0EsTUFGRCxNQUVPO0FBQ04xUixXQUFLd0MsS0FBTCxDQUFZc0QsT0FBWixFQUFxQndQLFVBQXJCO0FBQ0E7QUFDRDtBQUNELElBbkZNLENBQVA7QUFvRkE7O0FBRUQsV0FBU0MsaUJBQVQsQ0FBNEIzQixNQUE1QixFQUFxQztBQUNwQyxPQUFJNEIsWUFBSjtBQUFBLE9BQWtCcEQsT0FBbEI7QUFBQSxPQUEyQnRQLENBQTNCO0FBQUEsT0FDQ0QsTUFBTStRLE9BQU9wUyxNQURkO0FBQUEsT0FFQ2lVLGtCQUFrQnpPLEtBQUs0SixRQUFMLENBQWVnRCxPQUFPLENBQVAsRUFBVXBQLElBQXpCLENBRm5CO0FBQUEsT0FHQ2tSLG1CQUFtQkQsbUJBQW1Cek8sS0FBSzRKLFFBQUwsQ0FBYyxHQUFkLENBSHZDO0FBQUEsT0FJQ3JPLElBQUlrVCxrQkFBa0IsQ0FBbEIsR0FBc0IsQ0FKM0I7OztBQU1DO0FBQ0FFLGtCQUFlM0IsY0FBZSxVQUFVMVIsSUFBVixFQUFpQjtBQUM5QyxXQUFPQSxTQUFTa1QsWUFBaEI7QUFDQSxJQUZjLEVBRVpFLGdCQUZZLEVBRU0sSUFGTixDQVBoQjtBQUFBLE9BVUNFLGtCQUFrQjVCLGNBQWUsVUFBVTFSLElBQVYsRUFBaUI7QUFDakQsV0FBT3JDLFFBQVF5QixJQUFSLENBQWM4VCxZQUFkLEVBQTRCbFQsSUFBNUIsSUFBcUMsQ0FBQyxDQUE3QztBQUNBLElBRmlCLEVBRWZvVCxnQkFGZSxFQUVHLElBRkgsQ0FWbkI7QUFBQSxPQWFDbEIsV0FBVyxDQUFFLFVBQVVsUyxJQUFWLEVBQWdCM0IsT0FBaEIsRUFBeUIrUSxHQUF6QixFQUErQjtBQUMzQyxXQUFTLENBQUMrRCxlQUFELEtBQXNCL0QsT0FBTy9RLFlBQVl5RyxnQkFBekMsQ0FBRixLQUNOLENBQUNvTyxlQUFlN1UsT0FBaEIsRUFBeUJvRSxRQUF6QixHQUNDNFEsYUFBY3JULElBQWQsRUFBb0IzQixPQUFwQixFQUE2QitRLEdBQTdCLENBREQsR0FFQ2tFLGdCQUFpQnRULElBQWpCLEVBQXVCM0IsT0FBdkIsRUFBZ0MrUSxHQUFoQyxDQUhLLENBQVA7QUFJQSxJQUxVLENBYlo7O0FBb0JBLFVBQVFuUCxJQUFJTSxHQUFaLEVBQWlCTixHQUFqQixFQUF1QjtBQUN0QixRQUFNNlAsVUFBVXBMLEtBQUs0SixRQUFMLENBQWVnRCxPQUFPclIsQ0FBUCxFQUFVaUMsSUFBekIsQ0FBaEIsRUFBbUQ7QUFDbERnUSxnQkFBVyxDQUFFUixjQUFjTyxlQUFnQkMsUUFBaEIsQ0FBZCxFQUEwQ3BDLE9BQTFDLENBQUYsQ0FBWDtBQUNBLEtBRkQsTUFFTztBQUNOQSxlQUFVcEwsS0FBSzJILE1BQUwsQ0FBYWlGLE9BQU9yUixDQUFQLEVBQVVpQyxJQUF2QixFQUE4QmhDLEtBQTlCLENBQXFDLElBQXJDLEVBQTJDb1IsT0FBT3JSLENBQVAsRUFBVStELE9BQXJELENBQVY7O0FBRUE7QUFDQSxTQUFLOEwsUUFBU3JPLE9BQVQsQ0FBTCxFQUEwQjtBQUN6QjtBQUNBakIsVUFBSSxFQUFFUCxDQUFOO0FBQ0EsYUFBUU8sSUFBSUQsR0FBWixFQUFpQkMsR0FBakIsRUFBdUI7QUFDdEIsV0FBS2tFLEtBQUs0SixRQUFMLENBQWVnRCxPQUFPOVEsQ0FBUCxFQUFVMEIsSUFBekIsQ0FBTCxFQUF1QztBQUN0QztBQUNBO0FBQ0Q7QUFDRCxhQUFPb1EsV0FDTnJTLElBQUksQ0FBSixJQUFTZ1MsZUFBZ0JDLFFBQWhCLENBREgsRUFFTmpTLElBQUksQ0FBSixJQUFTcUo7QUFDUjtBQUNBZ0ksYUFBTzlULEtBQVAsQ0FBYyxDQUFkLEVBQWlCeUMsSUFBSSxDQUFyQixFQUF5QnhDLE1BQXpCLENBQWdDLEVBQUUwRixPQUFPbU8sT0FBUXJSLElBQUksQ0FBWixFQUFnQmlDLElBQWhCLEtBQXlCLEdBQXpCLEdBQStCLEdBQS9CLEdBQXFDLEVBQTlDLEVBQWhDLENBRlEsRUFHUE4sT0FITyxDQUdFcEQsS0FIRixFQUdTLElBSFQsQ0FGSCxFQU1Oc1IsT0FOTSxFQU9ON1AsSUFBSU8sQ0FBSixJQUFTeVMsa0JBQW1CM0IsT0FBTzlULEtBQVAsQ0FBY3lDLENBQWQsRUFBaUJPLENBQWpCLENBQW5CLENBUEgsRUFRTkEsSUFBSUQsR0FBSixJQUFXMFMsa0JBQW9CM0IsU0FBU0EsT0FBTzlULEtBQVAsQ0FBY2dELENBQWQsQ0FBN0IsQ0FSTCxFQVNOQSxJQUFJRCxHQUFKLElBQVcrSSxXQUFZZ0ksTUFBWixDQVRMLENBQVA7QUFXQTtBQUNEWSxjQUFTeFUsSUFBVCxDQUFlb1MsT0FBZjtBQUNBO0FBQ0Q7O0FBRUQsVUFBT21DLGVBQWdCQyxRQUFoQixDQUFQO0FBQ0E7O0FBRUQsV0FBU3FCLHdCQUFULENBQW1DQyxlQUFuQyxFQUFvREMsV0FBcEQsRUFBa0U7QUFDakUsT0FBSUMsUUFBUUQsWUFBWXZVLE1BQVosR0FBcUIsQ0FBakM7QUFBQSxPQUNDeVUsWUFBWUgsZ0JBQWdCdFUsTUFBaEIsR0FBeUIsQ0FEdEM7QUFBQSxPQUVDMFUsZUFBZSxTQUFmQSxZQUFlLENBQVUxTCxJQUFWLEVBQWdCN0osT0FBaEIsRUFBeUIrUSxHQUF6QixFQUE4QjVMLE9BQTlCLEVBQXVDcVEsU0FBdkMsRUFBbUQ7QUFDakUsUUFBSTdULElBQUo7QUFBQSxRQUFVUSxDQUFWO0FBQUEsUUFBYXNQLE9BQWI7QUFBQSxRQUNDZ0UsZUFBZSxDQURoQjtBQUFBLFFBRUM3VCxJQUFJLEdBRkw7QUFBQSxRQUdDOFAsWUFBWTdILFFBQVEsRUFIckI7QUFBQSxRQUlDNkwsYUFBYSxFQUpkO0FBQUEsUUFLQ0MsZ0JBQWdCbFAsZ0JBTGpCOztBQU1DO0FBQ0F0RixZQUFRMEksUUFBUXlMLGFBQWFqUCxLQUFLMEgsSUFBTCxDQUFVLEtBQVYsRUFBa0IsR0FBbEIsRUFBdUJ5SCxTQUF2QixDQVA5Qjs7QUFRQztBQUNBSSxvQkFBaUJ6TyxXQUFXd08saUJBQWlCLElBQWpCLEdBQXdCLENBQXhCLEdBQTRCdFMsS0FBS0MsTUFBTCxNQUFpQixHQVQxRTtBQUFBLFFBVUNwQixNQUFNZixNQUFNTixNQVZiOztBQVlBLFFBQUsyVSxTQUFMLEVBQWlCO0FBQ2hCL08sd0JBQW1CekcsWUFBWW5CLFFBQVosSUFBd0JtQixPQUEzQztBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBUTRCLE1BQU1NLEdBQU4sSUFBYSxDQUFDUCxPQUFPUixNQUFNUyxDQUFOLENBQVIsS0FBcUIsSUFBMUMsRUFBZ0RBLEdBQWhELEVBQXNEO0FBQ3JELFNBQUswVCxhQUFhM1QsSUFBbEIsRUFBeUI7QUFDeEJRLFVBQUksQ0FBSjtBQUNBLGFBQVNzUCxVQUFVMEQsZ0JBQWdCaFQsR0FBaEIsQ0FBbkIsRUFBMkM7QUFDMUMsV0FBS3NQLFFBQVM5UCxJQUFULEVBQWUzQixPQUFmLEVBQXdCK1EsR0FBeEIsQ0FBTCxFQUFxQztBQUNwQzVMLGdCQUFROUYsSUFBUixDQUFjc0MsSUFBZDtBQUNBO0FBQ0E7QUFDRDtBQUNELFVBQUs2VCxTQUFMLEVBQWlCO0FBQ2hCck8saUJBQVV5TyxhQUFWO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLFNBQUtQLEtBQUwsRUFBYTtBQUNaO0FBQ0EsVUFBTTFULE9BQU8sQ0FBQzhQLE9BQUQsSUFBWTlQLElBQXpCLEVBQWlDO0FBQ2hDOFQ7QUFDQTs7QUFFRDtBQUNBLFVBQUs1TCxJQUFMLEVBQVk7QUFDWDZILGlCQUFVclMsSUFBVixDQUFnQnNDLElBQWhCO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0E4VCxvQkFBZ0I3VCxDQUFoQjtBQUNBLFFBQUt5VCxTQUFTelQsTUFBTTZULFlBQXBCLEVBQW1DO0FBQ2xDdFQsU0FBSSxDQUFKO0FBQ0EsWUFBU3NQLFVBQVUyRCxZQUFZalQsR0FBWixDQUFuQixFQUF1QztBQUN0Q3NQLGNBQVNDLFNBQVQsRUFBb0JnRSxVQUFwQixFQUFnQzFWLE9BQWhDLEVBQXlDK1EsR0FBekM7QUFDQTs7QUFFRCxTQUFLbEgsSUFBTCxFQUFZO0FBQ1g7QUFDQSxVQUFLNEwsZUFBZSxDQUFwQixFQUF3QjtBQUN2QixjQUFRN1QsR0FBUixFQUFjO0FBQ2IsWUFBSyxFQUFFOFAsVUFBVTlQLENBQVYsS0FBZ0I4VCxXQUFXOVQsQ0FBWCxDQUFsQixDQUFMLEVBQXdDO0FBQ3ZDOFQsb0JBQVc5VCxDQUFYLElBQWdCa0csSUFBSS9HLElBQUosQ0FBVW9FLE9BQVYsQ0FBaEI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQXVRLG1CQUFhNUIsU0FBVTRCLFVBQVYsQ0FBYjtBQUNBOztBQUVEO0FBQ0FyVyxVQUFLd0MsS0FBTCxDQUFZc0QsT0FBWixFQUFxQnVRLFVBQXJCOztBQUVBO0FBQ0EsU0FBS0YsYUFBYSxDQUFDM0wsSUFBZCxJQUFzQjZMLFdBQVc3VSxNQUFYLEdBQW9CLENBQTFDLElBQ0Y0VSxlQUFlTCxZQUFZdlUsTUFBN0IsR0FBd0MsQ0FEekMsRUFDNkM7O0FBRTVDdUYsYUFBT3FKLFVBQVAsQ0FBbUJ0SyxPQUFuQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFLcVEsU0FBTCxFQUFpQjtBQUNoQnJPLGVBQVV5TyxhQUFWO0FBQ0FuUCx3QkFBbUJrUCxhQUFuQjtBQUNBOztBQUVELFdBQU9qRSxTQUFQO0FBQ0EsSUEzRkY7O0FBNkZBLFVBQU8yRCxRQUNOekosYUFBYzJKLFlBQWQsQ0FETSxHQUVOQSxZQUZEO0FBR0E7O0FBRUQvTyxZQUFVSixPQUFPSSxPQUFQLEdBQWlCLFVBQVV6RyxRQUFWLEVBQW9COFYsS0FBcEIsQ0FBMEIsdUJBQTFCLEVBQW9EO0FBQzlFLE9BQUlqVSxDQUFKO0FBQUEsT0FDQ3dULGNBQWMsRUFEZjtBQUFBLE9BRUNELGtCQUFrQixFQUZuQjtBQUFBLE9BR0MvQixTQUFTNUwsY0FBZXpILFdBQVcsR0FBMUIsQ0FIVjs7QUFLQSxPQUFLLENBQUNxVCxNQUFOLEVBQWU7QUFDZDtBQUNBLFFBQUssQ0FBQ3lDLEtBQU4sRUFBYztBQUNiQSxhQUFRL0ssU0FBVS9LLFFBQVYsQ0FBUjtBQUNBO0FBQ0Q2QixRQUFJaVUsTUFBTWhWLE1BQVY7QUFDQSxXQUFRZSxHQUFSLEVBQWM7QUFDYndSLGNBQVN3QixrQkFBbUJpQixNQUFNalUsQ0FBTixDQUFuQixDQUFUO0FBQ0EsU0FBS3dSLE9BQVFoUSxPQUFSLENBQUwsRUFBeUI7QUFDeEJnUyxrQkFBWS9WLElBQVosQ0FBa0IrVCxNQUFsQjtBQUNBLE1BRkQsTUFFTztBQUNOK0Isc0JBQWdCOVYsSUFBaEIsQ0FBc0IrVCxNQUF0QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQUEsYUFBUzVMLGNBQWV6SCxRQUFmLEVBQXlCbVYseUJBQTBCQyxlQUExQixFQUEyQ0MsV0FBM0MsQ0FBekIsQ0FBVDtBQUNBO0FBQ0QsVUFBT2hDLE1BQVA7QUFDQSxHQXpCRDs7QUEyQkEsV0FBU3FCLGdCQUFULENBQTJCMVUsUUFBM0IsRUFBcUMrVixRQUFyQyxFQUErQzNRLE9BQS9DLEVBQXlEO0FBQ3hELE9BQUl2RCxJQUFJLENBQVI7QUFBQSxPQUNDTSxNQUFNNFQsU0FBU2pWLE1BRGhCO0FBRUEsVUFBUWUsSUFBSU0sR0FBWixFQUFpQk4sR0FBakIsRUFBdUI7QUFDdEJ3RSxXQUFRckcsUUFBUixFQUFrQitWLFNBQVNsVSxDQUFULENBQWxCLEVBQStCdUQsT0FBL0I7QUFDQTtBQUNELFVBQU9BLE9BQVA7QUFDQTs7QUFFRCxXQUFTb0csTUFBVCxDQUFpQnhMLFFBQWpCLEVBQTJCQyxPQUEzQixFQUFvQ21GLE9BQXBDLEVBQTZDMEUsSUFBN0MsRUFBb0Q7QUFDbkQsT0FBSWpJLENBQUo7QUFBQSxPQUFPcVIsTUFBUDtBQUFBLE9BQWU4QyxLQUFmO0FBQUEsT0FBc0JsUyxJQUF0QjtBQUFBLE9BQTRCa0ssSUFBNUI7QUFBQSxPQUNDakUsUUFBUWdCLFNBQVUvSyxRQUFWLENBRFQ7O0FBR0EsT0FBSyxDQUFDOEosSUFBTixFQUFhO0FBQ1o7QUFDQSxRQUFLQyxNQUFNakosTUFBTixLQUFpQixDQUF0QixFQUEwQjs7QUFFekI7QUFDQW9TLGNBQVNuSixNQUFNLENBQU4sSUFBV0EsTUFBTSxDQUFOLEVBQVMzSyxLQUFULENBQWdCLENBQWhCLENBQXBCO0FBQ0EsU0FBSzhULE9BQU9wUyxNQUFQLEdBQWdCLENBQWhCLElBQXFCLENBQUNrVixRQUFROUMsT0FBTyxDQUFQLENBQVQsRUFBb0JwUCxJQUFwQixLQUE2QixJQUFsRCxJQUNIakUsUUFBUWlPLE9BREwsSUFDZ0I3TixRQUFRb0UsUUFBUixLQUFxQixDQURyQyxJQUMwQzBDLGNBRDFDLElBRUhULEtBQUs0SixRQUFMLENBQWVnRCxPQUFPLENBQVAsRUFBVXBQLElBQXpCLENBRkYsRUFFb0M7O0FBRW5DN0QsZ0JBQVUsQ0FBRXFHLEtBQUswSCxJQUFMLENBQVUsSUFBVixFQUFpQmdJLE1BQU1wUSxPQUFOLENBQWMsQ0FBZCxFQUFpQnBDLE9BQWpCLENBQXlCNEYsU0FBekIsRUFBb0NDLFNBQXBDLENBQWpCLEVBQWlFcEosT0FBakUsS0FBOEUsRUFBaEYsRUFBcUYsQ0FBckYsQ0FBVjtBQUNBLFVBQUssQ0FBQ0EsT0FBTixFQUFnQjtBQUNmLGNBQU9tRixPQUFQO0FBQ0E7QUFDRHBGLGlCQUFXQSxTQUFTWixLQUFULENBQWdCOFQsT0FBT3RILEtBQVAsR0FBZTdHLEtBQWYsQ0FBcUJqRSxNQUFyQyxDQUFYO0FBQ0E7O0FBRUQ7QUFDQWUsU0FBSWdILFVBQVUsY0FBVixFQUEwQmlDLElBQTFCLENBQWdDOUssUUFBaEMsSUFBNkMsQ0FBN0MsR0FBaURrVCxPQUFPcFMsTUFBNUQ7QUFDQSxZQUFRZSxHQUFSLEVBQWM7QUFDYm1VLGNBQVE5QyxPQUFPclIsQ0FBUCxDQUFSOztBQUVBO0FBQ0EsVUFBS3lFLEtBQUs0SixRQUFMLENBQWdCcE0sT0FBT2tTLE1BQU1sUyxJQUE3QixDQUFMLEVBQTRDO0FBQzNDO0FBQ0E7QUFDRCxVQUFNa0ssT0FBTzFILEtBQUswSCxJQUFMLENBQVdsSyxJQUFYLENBQWIsRUFBa0M7QUFDakM7QUFDQSxXQUFNZ0csT0FBT2tFLEtBQ1pnSSxNQUFNcFEsT0FBTixDQUFjLENBQWQsRUFBaUJwQyxPQUFqQixDQUEwQjRGLFNBQTFCLEVBQXFDQyxTQUFyQyxDQURZLEVBRVpILFNBQVM0QixJQUFULENBQWVvSSxPQUFPLENBQVAsRUFBVXBQLElBQXpCLEtBQW1DcUgsWUFBYWxMLFFBQVF3SyxVQUFyQixDQUFuQyxJQUF3RXhLLE9BRjVELENBQWIsRUFHSzs7QUFFSjtBQUNBaVQsZUFBTzNRLE1BQVAsQ0FBZVYsQ0FBZixFQUFrQixDQUFsQjtBQUNBN0IsbUJBQVc4SixLQUFLaEosTUFBTCxJQUFlb0ssV0FBWWdJLE1BQVosQ0FBMUI7QUFDQSxZQUFLLENBQUNsVCxRQUFOLEVBQWlCO0FBQ2hCVixjQUFLd0MsS0FBTCxDQUFZc0QsT0FBWixFQUFxQjBFLElBQXJCO0FBQ0EsZ0JBQU8xRSxPQUFQO0FBQ0E7O0FBRUQ7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQXFCLFdBQVN6RyxRQUFULEVBQW1CK0osS0FBbkIsRUFDQ0QsSUFERCxFQUVDN0osT0FGRCxFQUdDLENBQUM4RyxjQUhGLEVBSUMzQixPQUpELEVBS0M4RCxTQUFTNEIsSUFBVCxDQUFlOUssUUFBZixLQUE2Qm1MLFlBQWFsTCxRQUFRd0ssVUFBckIsQ0FBN0IsSUFBa0V4SyxPQUxuRTtBQU9BLFVBQU9tRixPQUFQO0FBQ0E7O0FBRUQ7O0FBRUE7QUFDQXZGLFVBQVFnUSxVQUFSLEdBQXFCeE0sUUFBUStDLEtBQVIsQ0FBYyxFQUFkLEVBQWtCOUQsSUFBbEIsQ0FBd0JvRixTQUF4QixFQUFvQzBELElBQXBDLENBQXlDLEVBQXpDLE1BQWlEL0gsT0FBdEU7O0FBRUE7QUFDQTtBQUNBeEQsVUFBUStQLGdCQUFSLEdBQTJCLENBQUMsQ0FBQ2hKLFlBQTdCOztBQUVBO0FBQ0FDOztBQUVBO0FBQ0E7QUFDQWhILFVBQVFtUCxZQUFSLEdBQXVCbEQsT0FBTyxVQUFVbUssSUFBVixFQUFpQjtBQUM5QztBQUNBLFVBQU9BLEtBQUtySCx1QkFBTCxDQUE4QjlQLFNBQVNrTixhQUFULENBQXVCLEtBQXZCLENBQTlCLElBQWdFLENBQXZFO0FBQ0EsR0FIc0IsQ0FBdkI7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyxDQUFDRixPQUFPLFVBQVVDLEdBQVYsRUFBZ0I7QUFDNUJBLE9BQUk2QixTQUFKLEdBQWdCLGtCQUFoQjtBQUNBLFVBQU83QixJQUFJOEIsVUFBSixDQUFlN0MsWUFBZixDQUE0QixNQUE1QixNQUF3QyxHQUEvQztBQUNBLEdBSEssQ0FBTixFQUdLO0FBQ0prQixhQUFXLHdCQUFYLEVBQXFDLFVBQVV0SyxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0I0RCxLQUF0QixFQUE4QjtBQUNsRSxRQUFLLENBQUNBLEtBQU4sRUFBYztBQUNiLFlBQU81RSxLQUFLb0osWUFBTCxDQUFtQnBJLElBQW5CLEVBQXlCQSxLQUFLa0MsV0FBTCxPQUF1QixNQUF2QixHQUFnQyxDQUFoQyxHQUFvQyxDQUE3RCxDQUFQO0FBQ0E7QUFDRCxJQUpEO0FBS0E7O0FBRUQ7QUFDQTtBQUNBLE1BQUssQ0FBQ2pGLFFBQVF3SSxVQUFULElBQXVCLENBQUN5RCxPQUFPLFVBQVVDLEdBQVYsRUFBZ0I7QUFDbkRBLE9BQUk2QixTQUFKLEdBQWdCLFVBQWhCO0FBQ0E3QixPQUFJOEIsVUFBSixDQUFlNUMsWUFBZixDQUE2QixPQUE3QixFQUFzQyxFQUF0QztBQUNBLFVBQU9jLElBQUk4QixVQUFKLENBQWU3QyxZQUFmLENBQTZCLE9BQTdCLE1BQTJDLEVBQWxEO0FBQ0EsR0FKNEIsQ0FBN0IsRUFJSztBQUNKa0IsYUFBVyxPQUFYLEVBQW9CLFVBQVV0SyxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0I0RCxLQUF0QixFQUE4QjtBQUNqRCxRQUFLLENBQUNBLEtBQUQsSUFBVTVFLEtBQUtpRCxRQUFMLENBQWNDLFdBQWQsT0FBZ0MsT0FBL0MsRUFBeUQ7QUFDeEQsWUFBT2xELEtBQUtzVSxZQUFaO0FBQ0E7QUFDRCxJQUpEO0FBS0E7O0FBRUQ7QUFDQTtBQUNBLE1BQUssQ0FBQ3BLLE9BQU8sVUFBVUMsR0FBVixFQUFnQjtBQUM1QixVQUFPQSxJQUFJZixZQUFKLENBQWlCLFVBQWpCLEtBQWdDLElBQXZDO0FBQ0EsR0FGSyxDQUFOLEVBRUs7QUFDSmtCLGFBQVdqRSxRQUFYLEVBQXFCLFVBQVVyRyxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0I0RCxLQUF0QixFQUE4QjtBQUNsRCxRQUFJZ0osR0FBSjtBQUNBLFFBQUssQ0FBQ2hKLEtBQU4sRUFBYztBQUNiLFlBQU81RSxLQUFNZ0IsSUFBTixNQUFpQixJQUFqQixHQUF3QkEsS0FBS2tDLFdBQUwsRUFBeEIsR0FDTCxDQUFDMEssTUFBTTVOLEtBQUt1TSxnQkFBTCxDQUF1QnZMLElBQXZCLENBQVAsS0FBeUM0TSxJQUFJQyxTQUE3QyxHQUNBRCxJQUFJekssS0FESixHQUVELElBSEQ7QUFJQTtBQUNELElBUkQ7QUFTQTs7QUFFRCxTQUFPc0IsTUFBUDtBQUVDLEVBMzhERCxDQTI4RElwSCxNQTM4REosQ0FYQTs7QUEwOURBYyxRQUFPaU8sSUFBUCxHQUFjM0gsTUFBZDtBQUNBdEcsUUFBT3NQLElBQVAsR0FBY2hKLE9BQU8ySixTQUFyQjtBQUNBalEsUUFBT3NQLElBQVAsQ0FBWSxHQUFaLElBQW1CdFAsT0FBT3NQLElBQVAsQ0FBWS9HLE9BQS9CO0FBQ0F2SSxRQUFPb1csTUFBUCxHQUFnQjlQLE9BQU9xSixVQUF2QjtBQUNBM1AsUUFBT2tGLElBQVAsR0FBY29CLE9BQU9FLE9BQXJCO0FBQ0F4RyxRQUFPcVcsUUFBUCxHQUFrQi9QLE9BQU9HLEtBQXpCO0FBQ0F6RyxRQUFPbUgsUUFBUCxHQUFrQmIsT0FBT2EsUUFBekI7O0FBSUEsS0FBSW1QLGdCQUFnQnRXLE9BQU9zUCxJQUFQLENBQVl0RixLQUFaLENBQWtCdU0sWUFBdEM7O0FBRUEsS0FBSUMsYUFBYyw0QkFBbEI7O0FBSUEsS0FBSUMsWUFBWSxnQkFBaEI7O0FBRUE7QUFDQSxVQUFTQyxNQUFULENBQWlCbkgsUUFBakIsRUFBMkJvSCxTQUEzQixFQUFzQ0MsR0FBdEMsRUFBNEM7QUFDM0MsTUFBSzVXLE9BQU9rRCxVQUFQLENBQW1CeVQsU0FBbkIsQ0FBTCxFQUFzQztBQUNyQyxVQUFPM1csT0FBTzBGLElBQVAsQ0FBYTZKLFFBQWIsRUFBdUIsVUFBVTFOLElBQVYsRUFBZ0JDLENBQWhCLEVBQW9CO0FBQ2pEO0FBQ0EsV0FBTyxDQUFDLENBQUM2VSxVQUFVMVYsSUFBVixDQUFnQlksSUFBaEIsRUFBc0JDLENBQXRCLEVBQXlCRCxJQUF6QixDQUFGLEtBQXNDK1UsR0FBN0M7QUFDQSxJQUhNLENBQVA7QUFLQTs7QUFFRCxNQUFLRCxVQUFVclMsUUFBZixFQUEwQjtBQUN6QixVQUFPdEUsT0FBTzBGLElBQVAsQ0FBYTZKLFFBQWIsRUFBdUIsVUFBVTFOLElBQVYsRUFBaUI7QUFDOUMsV0FBU0EsU0FBUzhVLFNBQVgsS0FBMkJDLEdBQWxDO0FBQ0EsSUFGTSxDQUFQO0FBSUE7O0FBRUQsTUFBSyxPQUFPRCxTQUFQLEtBQXFCLFFBQTFCLEVBQXFDO0FBQ3BDLE9BQUtGLFVBQVUxTCxJQUFWLENBQWdCNEwsU0FBaEIsQ0FBTCxFQUFtQztBQUNsQyxXQUFPM1csT0FBT2tPLE1BQVAsQ0FBZXlJLFNBQWYsRUFBMEJwSCxRQUExQixFQUFvQ3FILEdBQXBDLENBQVA7QUFDQTs7QUFFREQsZUFBWTNXLE9BQU9rTyxNQUFQLENBQWV5SSxTQUFmLEVBQTBCcEgsUUFBMUIsQ0FBWjtBQUNBOztBQUVELFNBQU92UCxPQUFPMEYsSUFBUCxDQUFhNkosUUFBYixFQUF1QixVQUFVMU4sSUFBVixFQUFpQjtBQUM5QyxVQUFTN0IsT0FBT3VGLE9BQVAsQ0FBZ0IxRCxJQUFoQixFQUFzQjhVLFNBQXRCLEtBQXFDLENBQXZDLEtBQStDQyxHQUF0RDtBQUNBLEdBRk0sQ0FBUDtBQUdBOztBQUVENVcsUUFBT2tPLE1BQVAsR0FBZ0IsVUFBVW9CLElBQVYsRUFBZ0JqTyxLQUFoQixFQUF1QnVWLEdBQXZCLEVBQTZCO0FBQzVDLE1BQUkvVSxPQUFPUixNQUFPLENBQVAsQ0FBWDs7QUFFQSxNQUFLdVYsR0FBTCxFQUFXO0FBQ1Z0SCxVQUFPLFVBQVVBLElBQVYsR0FBaUIsR0FBeEI7QUFDQTs7QUFFRCxTQUFPak8sTUFBTU4sTUFBTixLQUFpQixDQUFqQixJQUFzQmMsS0FBS3lDLFFBQUwsS0FBa0IsQ0FBeEMsR0FDTnRFLE9BQU9pTyxJQUFQLENBQVlNLGVBQVosQ0FBNkIxTSxJQUE3QixFQUFtQ3lOLElBQW5DLElBQTRDLENBQUV6TixJQUFGLENBQTVDLEdBQXVELEVBRGpELEdBRU43QixPQUFPaU8sSUFBUCxDQUFZcEksT0FBWixDQUFxQnlKLElBQXJCLEVBQTJCdFAsT0FBTzBGLElBQVAsQ0FBYXJFLEtBQWIsRUFBb0IsVUFBVVEsSUFBVixFQUFpQjtBQUMvRCxVQUFPQSxLQUFLeUMsUUFBTCxLQUFrQixDQUF6QjtBQUNBLEdBRjBCLENBQTNCLENBRkQ7QUFLQSxFQVpEOztBQWNBdEUsUUFBT0csRUFBUCxDQUFVc0MsTUFBVixDQUFpQjtBQUNoQndMLFFBQU0sY0FBVWhPLFFBQVYsRUFBcUI7QUFDMUIsT0FBSTZCLENBQUo7QUFBQSxPQUNDUixNQUFNLEVBRFA7QUFBQSxPQUVDdVYsT0FBTyxJQUZSO0FBQUEsT0FHQ3pVLE1BQU15VSxLQUFLOVYsTUFIWjs7QUFLQSxPQUFLLE9BQU9kLFFBQVAsS0FBb0IsUUFBekIsRUFBb0M7QUFDbkMsV0FBTyxLQUFLbUIsU0FBTCxDQUFnQnBCLE9BQVFDLFFBQVIsRUFBbUJpTyxNQUFuQixDQUEwQixZQUFXO0FBQzNELFVBQU1wTSxJQUFJLENBQVYsRUFBYUEsSUFBSU0sR0FBakIsRUFBc0JOLEdBQXRCLEVBQTRCO0FBQzNCLFVBQUs5QixPQUFPbUgsUUFBUCxDQUFpQjBQLEtBQU0vVSxDQUFOLENBQWpCLEVBQTRCLElBQTVCLENBQUwsRUFBMEM7QUFDekMsY0FBTyxJQUFQO0FBQ0E7QUFDRDtBQUNELEtBTnNCLENBQWhCLENBQVA7QUFPQTs7QUFFRCxRQUFNQSxJQUFJLENBQVYsRUFBYUEsSUFBSU0sR0FBakIsRUFBc0JOLEdBQXRCLEVBQTRCO0FBQzNCOUIsV0FBT2lPLElBQVAsQ0FBYWhPLFFBQWIsRUFBdUI0VyxLQUFNL1UsQ0FBTixDQUF2QixFQUFrQ1IsR0FBbEM7QUFDQTs7QUFFRDtBQUNBQSxTQUFNLEtBQUtGLFNBQUwsQ0FBZ0JnQixNQUFNLENBQU4sR0FBVXBDLE9BQU9vVyxNQUFQLENBQWU5VSxHQUFmLENBQVYsR0FBaUNBLEdBQWpELENBQU47QUFDQUEsT0FBSXJCLFFBQUosR0FBZSxLQUFLQSxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsR0FBZ0IsR0FBaEIsR0FBc0JBLFFBQXRDLEdBQWlEQSxRQUFoRTtBQUNBLFVBQU9xQixHQUFQO0FBQ0EsR0F6QmU7QUEwQmhCNE0sVUFBUSxnQkFBVWpPLFFBQVYsRUFBcUI7QUFDNUIsVUFBTyxLQUFLbUIsU0FBTCxDQUFnQnNWLE9BQU8sSUFBUCxFQUFhelcsWUFBWSxFQUF6QixFQUE2QixLQUE3QixDQUFoQixDQUFQO0FBQ0EsR0E1QmU7QUE2QmhCMlcsT0FBSyxhQUFVM1csUUFBVixFQUFxQjtBQUN6QixVQUFPLEtBQUttQixTQUFMLENBQWdCc1YsT0FBTyxJQUFQLEVBQWF6VyxZQUFZLEVBQXpCLEVBQTZCLElBQTdCLENBQWhCLENBQVA7QUFDQSxHQS9CZTtBQWdDaEI2VyxNQUFJLFlBQVU3VyxRQUFWLEVBQXFCO0FBQ3hCLFVBQU8sQ0FBQyxDQUFDeVcsT0FDUixJQURROztBQUdSO0FBQ0E7QUFDQSxVQUFPelcsUUFBUCxLQUFvQixRQUFwQixJQUFnQ3FXLGNBQWN2TCxJQUFkLENBQW9COUssUUFBcEIsQ0FBaEMsR0FDQ0QsT0FBUUMsUUFBUixDQURELEdBRUNBLFlBQVksRUFQTCxFQVFSLEtBUlEsRUFTUGMsTUFURjtBQVVBO0FBM0NlLEVBQWpCOztBQStDQTs7O0FBR0E7QUFDQSxLQUFJZ1csVUFBSjs7O0FBRUM7QUFDQWhZLFlBQVdHLE9BQU9ILFFBSG5COzs7QUFLQztBQUNBO0FBQ0E7QUFDQW1LLGNBQWEscUNBUmQ7QUFBQSxLQVVDOUksT0FBT0osT0FBT0csRUFBUCxDQUFVQyxJQUFWLEdBQWlCLFVBQVVILFFBQVYsRUFBb0JDLE9BQXBCLEVBQThCO0FBQ3JELE1BQUk4SixLQUFKLEVBQVduSSxJQUFYOztBQUVBO0FBQ0EsTUFBSyxDQUFDNUIsUUFBTixFQUFpQjtBQUNoQixVQUFPLElBQVA7QUFDQTs7QUFFRDtBQUNBLE1BQUssT0FBT0EsUUFBUCxLQUFvQixRQUF6QixFQUFvQztBQUNuQyxPQUFLQSxTQUFTK1csTUFBVCxDQUFnQixDQUFoQixNQUF1QixHQUF2QixJQUE4Qi9XLFNBQVMrVyxNQUFULENBQWlCL1csU0FBU2MsTUFBVCxHQUFrQixDQUFuQyxNQUEyQyxHQUF6RSxJQUFnRmQsU0FBU2MsTUFBVCxJQUFtQixDQUF4RyxFQUE0RztBQUMzRztBQUNBaUosWUFBUSxDQUFFLElBQUYsRUFBUS9KLFFBQVIsRUFBa0IsSUFBbEIsQ0FBUjtBQUVBLElBSkQsTUFJTztBQUNOK0osWUFBUWQsV0FBV3NCLElBQVgsQ0FBaUJ2SyxRQUFqQixDQUFSO0FBQ0E7O0FBRUQ7QUFDQSxPQUFLK0osVUFBVUEsTUFBTSxDQUFOLEtBQVksQ0FBQzlKLE9BQXZCLENBQUwsRUFBdUM7O0FBRXRDO0FBQ0EsUUFBSzhKLE1BQU0sQ0FBTixDQUFMLEVBQWdCO0FBQ2Y5SixlQUFVQSxtQkFBbUJGLE1BQW5CLEdBQTRCRSxRQUFRLENBQVIsQ0FBNUIsR0FBeUNBLE9BQW5EOztBQUVBO0FBQ0E7QUFDQUYsWUFBT3VCLEtBQVAsQ0FBYyxJQUFkLEVBQW9CdkIsT0FBT2lYLFNBQVAsQ0FDbkJqTixNQUFNLENBQU4sQ0FEbUIsRUFFbkI5SixXQUFXQSxRQUFRb0UsUUFBbkIsR0FBOEJwRSxRQUFRcUssYUFBUixJQUF5QnJLLE9BQXZELEdBQWlFbkIsUUFGOUMsRUFHbkIsSUFIbUIsQ0FBcEI7O0FBTUE7QUFDQSxTQUFLeVgsV0FBV3pMLElBQVgsQ0FBaUJmLE1BQU0sQ0FBTixDQUFqQixLQUErQmhLLE9BQU9tRCxhQUFQLENBQXNCakQsT0FBdEIsQ0FBcEMsRUFBc0U7QUFDckUsV0FBTThKLEtBQU4sSUFBZTlKLE9BQWYsRUFBeUI7QUFDeEI7QUFDQSxXQUFLRixPQUFPa0QsVUFBUCxDQUFtQixLQUFNOEcsS0FBTixDQUFuQixDQUFMLEVBQTBDO0FBQ3pDLGFBQU1BLEtBQU4sRUFBZTlKLFFBQVM4SixLQUFULENBQWY7O0FBRUQ7QUFDQyxRQUpELE1BSU87QUFDTixhQUFLd0YsSUFBTCxDQUFXeEYsS0FBWCxFQUFrQjlKLFFBQVM4SixLQUFULENBQWxCO0FBQ0E7QUFDRDtBQUNEOztBQUVELFlBQU8sSUFBUDs7QUFFRDtBQUNDLEtBNUJELE1BNEJPO0FBQ05uSSxZQUFPOUMsU0FBUzBMLGNBQVQsQ0FBeUJULE1BQU0sQ0FBTixDQUF6QixDQUFQOztBQUVBO0FBQ0E7QUFDQSxTQUFLbkksUUFBUUEsS0FBSzZJLFVBQWxCLEVBQStCO0FBQzlCO0FBQ0E7QUFDQSxVQUFLN0ksS0FBSzhJLEVBQUwsS0FBWVgsTUFBTSxDQUFOLENBQWpCLEVBQTRCO0FBQzNCLGNBQU8rTSxXQUFXOUksSUFBWCxDQUFpQmhPLFFBQWpCLENBQVA7QUFDQTs7QUFFRDtBQUNBLFdBQUtjLE1BQUwsR0FBYyxDQUFkO0FBQ0EsV0FBSyxDQUFMLElBQVVjLElBQVY7QUFDQTs7QUFFRCxVQUFLM0IsT0FBTCxHQUFlbkIsUUFBZjtBQUNBLFVBQUtrQixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFlBQU8sSUFBUDtBQUNBOztBQUVGO0FBQ0MsSUF0REQsTUFzRE8sSUFBSyxDQUFDQyxPQUFELElBQVlBLFFBQVFXLE1BQXpCLEVBQWtDO0FBQ3hDLFdBQU8sQ0FBRVgsV0FBVzZXLFVBQWIsRUFBMEI5SSxJQUExQixDQUFnQ2hPLFFBQWhDLENBQVA7O0FBRUQ7QUFDQTtBQUNDLElBTE0sTUFLQTtBQUNOLFdBQU8sS0FBS2EsV0FBTCxDQUFrQlosT0FBbEIsRUFBNEIrTixJQUE1QixDQUFrQ2hPLFFBQWxDLENBQVA7QUFDQTs7QUFFRjtBQUNDLEdBMUVELE1BMEVPLElBQUtBLFNBQVNxRSxRQUFkLEVBQXlCO0FBQy9CLFFBQUtwRSxPQUFMLEdBQWUsS0FBSyxDQUFMLElBQVVELFFBQXpCO0FBQ0EsUUFBS2MsTUFBTCxHQUFjLENBQWQ7QUFDQSxVQUFPLElBQVA7O0FBRUQ7QUFDQTtBQUNDLEdBUE0sTUFPQSxJQUFLZixPQUFPa0QsVUFBUCxDQUFtQmpELFFBQW5CLENBQUwsRUFBcUM7QUFDM0MsVUFBTyxPQUFPOFcsV0FBV0csS0FBbEIsS0FBNEIsV0FBNUIsR0FDTkgsV0FBV0csS0FBWCxDQUFrQmpYLFFBQWxCLENBRE07QUFFTjtBQUNBQSxZQUFVRCxNQUFWLENBSEQ7QUFJQTs7QUFFRCxNQUFLQyxTQUFTQSxRQUFULEtBQXNCb0QsU0FBM0IsRUFBdUM7QUFDdEMsUUFBS3BELFFBQUwsR0FBZ0JBLFNBQVNBLFFBQXpCO0FBQ0EsUUFBS0MsT0FBTCxHQUFlRCxTQUFTQyxPQUF4QjtBQUNBOztBQUVELFNBQU9GLE9BQU9tRixTQUFQLENBQWtCbEYsUUFBbEIsRUFBNEIsSUFBNUIsQ0FBUDtBQUNBLEVBakhGOztBQW1IQTtBQUNBRyxNQUFLUSxTQUFMLEdBQWlCWixPQUFPRyxFQUF4Qjs7QUFFQTtBQUNBNFcsY0FBYS9XLE9BQVFqQixRQUFSLENBQWI7O0FBR0EsS0FBSW9ZLGVBQWUsZ0NBQW5COztBQUNDO0FBQ0FDLG9CQUFtQjtBQUNsQkMsWUFBVSxJQURRO0FBRWxCQyxZQUFVLElBRlE7QUFHbEJDLFFBQU0sSUFIWTtBQUlsQkMsUUFBTTtBQUpZLEVBRnBCOztBQVNBeFgsUUFBT3lDLE1BQVAsQ0FBYztBQUNiMk4sT0FBSyxhQUFVdk8sSUFBVixFQUFnQnVPLElBQWhCLEVBQXFCcUgsS0FBckIsRUFBNkI7QUFDakMsT0FBSS9GLFVBQVUsRUFBZDtBQUFBLE9BQ0NsRixNQUFNM0ssS0FBTXVPLElBQU4sQ0FEUDs7QUFHQSxVQUFRNUQsT0FBT0EsSUFBSWxJLFFBQUosS0FBaUIsQ0FBeEIsS0FBOEJtVCxVQUFVcFUsU0FBVixJQUF1Qm1KLElBQUlsSSxRQUFKLEtBQWlCLENBQXhDLElBQTZDLENBQUN0RSxPQUFRd00sR0FBUixFQUFjc0ssRUFBZCxDQUFrQlcsS0FBbEIsQ0FBNUUsQ0FBUixFQUFpSDtBQUNoSCxRQUFLakwsSUFBSWxJLFFBQUosS0FBaUIsQ0FBdEIsRUFBMEI7QUFDekJvTixhQUFRblMsSUFBUixDQUFjaU4sR0FBZDtBQUNBO0FBQ0RBLFVBQU1BLElBQUk0RCxJQUFKLENBQU47QUFDQTtBQUNELFVBQU9zQixPQUFQO0FBQ0EsR0FaWTs7QUFjYmdHLFdBQVMsaUJBQVVDLENBQVYsRUFBYTlWLElBQWIsRUFBb0I7QUFDNUIsT0FBSStWLElBQUksRUFBUjs7QUFFQSxVQUFRRCxDQUFSLEVBQVdBLElBQUlBLEVBQUVoTCxXQUFqQixFQUErQjtBQUM5QixRQUFLZ0wsRUFBRXJULFFBQUYsS0FBZSxDQUFmLElBQW9CcVQsTUFBTTlWLElBQS9CLEVBQXNDO0FBQ3JDK1YsT0FBRXJZLElBQUYsQ0FBUW9ZLENBQVI7QUFDQTtBQUNEOztBQUVELFVBQU9DLENBQVA7QUFDQTtBQXhCWSxFQUFkOztBQTJCQTVYLFFBQU9HLEVBQVAsQ0FBVXNDLE1BQVYsQ0FBaUI7QUFDaEJvVixPQUFLLGFBQVU3VSxNQUFWLEVBQW1CO0FBQ3ZCLE9BQUlsQixDQUFKO0FBQUEsT0FDQ2dXLFVBQVU5WCxPQUFRZ0QsTUFBUixFQUFnQixJQUFoQixDQURYO0FBQUEsT0FFQ1osTUFBTTBWLFFBQVEvVyxNQUZmOztBQUlBLFVBQU8sS0FBS21OLE1BQUwsQ0FBWSxZQUFXO0FBQzdCLFNBQU1wTSxJQUFJLENBQVYsRUFBYUEsSUFBSU0sR0FBakIsRUFBc0JOLEdBQXRCLEVBQTRCO0FBQzNCLFNBQUs5QixPQUFPbUgsUUFBUCxDQUFpQixJQUFqQixFQUF1QjJRLFFBQVFoVyxDQUFSLENBQXZCLENBQUwsRUFBMkM7QUFDMUMsYUFBTyxJQUFQO0FBQ0E7QUFDRDtBQUNELElBTk0sQ0FBUDtBQU9BLEdBYmU7O0FBZWhCaVcsV0FBUyxpQkFBVTlILFNBQVYsRUFBcUIvUCxPQUFyQixFQUErQjtBQUN2QyxPQUFJc00sR0FBSjtBQUFBLE9BQ0MxSyxJQUFJLENBREw7QUFBQSxPQUVDa1csSUFBSSxLQUFLalgsTUFGVjtBQUFBLE9BR0MyUSxVQUFVLEVBSFg7QUFBQSxPQUlDdUcsTUFBTTNCLGNBQWN2TCxJQUFkLENBQW9Ca0YsU0FBcEIsS0FBbUMsT0FBT0EsU0FBUCxLQUFxQixRQUF4RCxHQUNMalEsT0FBUWlRLFNBQVIsRUFBbUIvUCxXQUFXLEtBQUtBLE9BQW5DLENBREssR0FFTCxDQU5GOztBQVFBLFVBQVE0QixJQUFJa1csQ0FBWixFQUFlbFcsR0FBZixFQUFxQjtBQUNwQixTQUFNMEssTUFBTSxLQUFLMUssQ0FBTCxDQUFaLEVBQXFCMEssT0FBT0EsUUFBUXRNLE9BQXBDLEVBQTZDc00sTUFBTUEsSUFBSTlCLFVBQXZELEVBQW9FO0FBQ25FO0FBQ0EsU0FBSzhCLElBQUlsSSxRQUFKLEdBQWUsRUFBZixLQUFzQjJULE1BQzFCQSxJQUFJQyxLQUFKLENBQVUxTCxHQUFWLElBQWlCLENBQUMsQ0FEUTs7QUFHMUI7QUFDQUEsU0FBSWxJLFFBQUosS0FBaUIsQ0FBakIsSUFDQ3RFLE9BQU9pTyxJQUFQLENBQVlNLGVBQVosQ0FBNEIvQixHQUE1QixFQUFpQ3lELFNBQWpDLENBTEcsQ0FBTCxFQUtpRDs7QUFFaER5QixjQUFRblMsSUFBUixDQUFjaU4sR0FBZDtBQUNBO0FBQ0E7QUFDRDtBQUNEOztBQUVELFVBQU8sS0FBS3BMLFNBQUwsQ0FBZ0JzUSxRQUFRM1EsTUFBUixHQUFpQixDQUFqQixHQUFxQmYsT0FBT29XLE1BQVAsQ0FBZTFFLE9BQWYsQ0FBckIsR0FBZ0RBLE9BQWhFLENBQVA7QUFDQSxHQXpDZTs7QUEyQ2hCO0FBQ0E7QUFDQXdHLFNBQU8sZUFBVXJXLElBQVYsRUFBaUI7O0FBRXZCO0FBQ0EsT0FBSyxDQUFDQSxJQUFOLEVBQWE7QUFDWixXQUFTLEtBQUssQ0FBTCxLQUFXLEtBQUssQ0FBTCxFQUFRNkksVUFBckIsR0FBb0MsS0FBS3pJLEtBQUwsR0FBYWtXLE9BQWIsR0FBdUJwWCxNQUEzRCxHQUFvRSxDQUFDLENBQTVFO0FBQ0E7O0FBRUQ7QUFDQSxPQUFLLE9BQU9jLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7QUFDL0IsV0FBTzdCLE9BQU91RixPQUFQLENBQWdCLEtBQUssQ0FBTCxDQUFoQixFQUF5QnZGLE9BQVE2QixJQUFSLENBQXpCLENBQVA7QUFDQTs7QUFFRDtBQUNBLFVBQU83QixPQUFPdUYsT0FBUDtBQUNOO0FBQ0ExRCxRQUFLaEIsTUFBTCxHQUFjZ0IsS0FBSyxDQUFMLENBQWQsR0FBd0JBLElBRmxCLEVBRXdCLElBRnhCLENBQVA7QUFHQSxHQTdEZTs7QUErRGhCdVcsT0FBSyxhQUFVblksUUFBVixFQUFvQkMsT0FBcEIsRUFBOEI7QUFDbEMsVUFBTyxLQUFLa0IsU0FBTCxDQUNOcEIsT0FBT29XLE1BQVAsQ0FDQ3BXLE9BQU91QixLQUFQLENBQWMsS0FBS0wsR0FBTCxFQUFkLEVBQTBCbEIsT0FBUUMsUUFBUixFQUFrQkMsT0FBbEIsQ0FBMUIsQ0FERCxDQURNLENBQVA7QUFLQSxHQXJFZTs7QUF1RWhCbVksV0FBUyxpQkFBVXBZLFFBQVYsRUFBcUI7QUFDN0IsVUFBTyxLQUFLbVksR0FBTCxDQUFVblksWUFBWSxJQUFaLEdBQ2hCLEtBQUt1QixVQURXLEdBQ0UsS0FBS0EsVUFBTCxDQUFnQjBNLE1BQWhCLENBQXVCak8sUUFBdkIsQ0FEWixDQUFQO0FBR0E7QUEzRWUsRUFBakI7O0FBOEVBLFVBQVN5WCxPQUFULENBQWtCbEwsR0FBbEIsRUFBdUI0RCxHQUF2QixFQUE2QjtBQUM1QixLQUFHO0FBQ0Y1RCxTQUFNQSxJQUFLNEQsR0FBTCxDQUFOO0FBQ0EsR0FGRCxRQUVVNUQsT0FBT0EsSUFBSWxJLFFBQUosS0FBaUIsQ0FGbEM7O0FBSUEsU0FBT2tJLEdBQVA7QUFDQTs7QUFFRHhNLFFBQU95QixJQUFQLENBQVk7QUFDWDRMLFVBQVEsZ0JBQVV4TCxJQUFWLEVBQWlCO0FBQ3hCLE9BQUl3TCxTQUFTeEwsS0FBSzZJLFVBQWxCO0FBQ0EsVUFBTzJDLFVBQVVBLE9BQU8vSSxRQUFQLEtBQW9CLEVBQTlCLEdBQW1DK0ksTUFBbkMsR0FBNEMsSUFBbkQ7QUFDQSxHQUpVO0FBS1hpTCxXQUFTLGlCQUFVelcsSUFBVixFQUFpQjtBQUN6QixVQUFPN0IsT0FBT29RLEdBQVAsQ0FBWXZPLElBQVosRUFBa0IsWUFBbEIsQ0FBUDtBQUNBLEdBUFU7QUFRWDBXLGdCQUFjLHNCQUFVMVcsSUFBVixFQUFnQkMsQ0FBaEIsRUFBbUIyVixLQUFuQixFQUEyQjtBQUN4QyxVQUFPelgsT0FBT29RLEdBQVAsQ0FBWXZPLElBQVosRUFBa0IsWUFBbEIsRUFBZ0M0VixLQUFoQyxDQUFQO0FBQ0EsR0FWVTtBQVdYRixRQUFNLGNBQVUxVixJQUFWLEVBQWlCO0FBQ3RCLFVBQU82VixRQUFTN1YsSUFBVCxFQUFlLGFBQWYsQ0FBUDtBQUNBLEdBYlU7QUFjWDJWLFFBQU0sY0FBVTNWLElBQVYsRUFBaUI7QUFDdEIsVUFBTzZWLFFBQVM3VixJQUFULEVBQWUsaUJBQWYsQ0FBUDtBQUNBLEdBaEJVO0FBaUJYMlcsV0FBUyxpQkFBVTNXLElBQVYsRUFBaUI7QUFDekIsVUFBTzdCLE9BQU9vUSxHQUFQLENBQVl2TyxJQUFaLEVBQWtCLGFBQWxCLENBQVA7QUFDQSxHQW5CVTtBQW9CWHNXLFdBQVMsaUJBQVV0VyxJQUFWLEVBQWlCO0FBQ3pCLFVBQU83QixPQUFPb1EsR0FBUCxDQUFZdk8sSUFBWixFQUFrQixpQkFBbEIsQ0FBUDtBQUNBLEdBdEJVO0FBdUJYNFcsYUFBVyxtQkFBVTVXLElBQVYsRUFBZ0JDLENBQWhCLEVBQW1CMlYsS0FBbkIsRUFBMkI7QUFDckMsVUFBT3pYLE9BQU9vUSxHQUFQLENBQVl2TyxJQUFaLEVBQWtCLGFBQWxCLEVBQWlDNFYsS0FBakMsQ0FBUDtBQUNBLEdBekJVO0FBMEJYaUIsYUFBVyxtQkFBVTdXLElBQVYsRUFBZ0JDLENBQWhCLEVBQW1CMlYsS0FBbkIsRUFBMkI7QUFDckMsVUFBT3pYLE9BQU9vUSxHQUFQLENBQVl2TyxJQUFaLEVBQWtCLGlCQUFsQixFQUFxQzRWLEtBQXJDLENBQVA7QUFDQSxHQTVCVTtBQTZCWGtCLFlBQVUsa0JBQVU5VyxJQUFWLEVBQWlCO0FBQzFCLFVBQU83QixPQUFPMFgsT0FBUCxDQUFnQixDQUFFN1YsS0FBSzZJLFVBQUwsSUFBbUIsRUFBckIsRUFBMEJvRCxVQUExQyxFQUFzRGpNLElBQXRELENBQVA7QUFDQSxHQS9CVTtBQWdDWHdWLFlBQVUsa0JBQVV4VixJQUFWLEVBQWlCO0FBQzFCLFVBQU83QixPQUFPMFgsT0FBUCxDQUFnQjdWLEtBQUtpTSxVQUFyQixDQUFQO0FBQ0EsR0FsQ1U7QUFtQ1h3SixZQUFVLGtCQUFVelYsSUFBVixFQUFpQjtBQUMxQixVQUFPN0IsT0FBTzhFLFFBQVAsQ0FBaUJqRCxJQUFqQixFQUF1QixRQUF2QixJQUNOQSxLQUFLK1csZUFBTCxJQUF3Qi9XLEtBQUtnWCxhQUFMLENBQW1COVosUUFEckMsR0FFTmlCLE9BQU91QixLQUFQLENBQWMsRUFBZCxFQUFrQk0sS0FBS2dJLFVBQXZCLENBRkQ7QUFHQTtBQXZDVSxFQUFaLEVBd0NHLFVBQVVoSCxJQUFWLEVBQWdCMUMsRUFBaEIsRUFBcUI7QUFDdkJILFNBQU9HLEVBQVAsQ0FBVzBDLElBQVgsSUFBb0IsVUFBVTRVLEtBQVYsRUFBaUJ4WCxRQUFqQixFQUE0QjtBQUMvQyxPQUFJcUIsTUFBTXRCLE9BQU80QixHQUFQLENBQVksSUFBWixFQUFrQnpCLEVBQWxCLEVBQXNCc1gsS0FBdEIsQ0FBVjs7QUFFQSxPQUFLNVUsS0FBS3hELEtBQUwsQ0FBWSxDQUFDLENBQWIsTUFBcUIsT0FBMUIsRUFBb0M7QUFDbkNZLGVBQVd3WCxLQUFYO0FBQ0E7O0FBRUQsT0FBS3hYLFlBQVksT0FBT0EsUUFBUCxLQUFvQixRQUFyQyxFQUFnRDtBQUMvQ3FCLFVBQU10QixPQUFPa08sTUFBUCxDQUFlak8sUUFBZixFQUF5QnFCLEdBQXpCLENBQU47QUFDQTs7QUFFRCxPQUFLLEtBQUtQLE1BQUwsR0FBYyxDQUFuQixFQUF1QjtBQUN0QjtBQUNBLFFBQUssQ0FBQ3FXLGlCQUFrQnZVLElBQWxCLENBQU4sRUFBaUM7QUFDaEN2QixXQUFNdEIsT0FBT29XLE1BQVAsQ0FBZTlVLEdBQWYsQ0FBTjtBQUNBOztBQUVEO0FBQ0EsUUFBSzZWLGFBQWFwTSxJQUFiLENBQW1CbEksSUFBbkIsQ0FBTCxFQUFpQztBQUNoQ3ZCLFdBQU1BLElBQUl3WCxPQUFKLEVBQU47QUFDQTtBQUNEOztBQUVELFVBQU8sS0FBSzFYLFNBQUwsQ0FBZ0JFLEdBQWhCLENBQVA7QUFDQSxHQXhCRDtBQXlCQSxFQWxFRDtBQW1FQSxLQUFJeVgsWUFBYSxNQUFqQjs7QUFJQTtBQUNBLEtBQUlDLGVBQWUsRUFBbkI7O0FBRUE7QUFDQSxVQUFTQyxhQUFULENBQXdCblcsT0FBeEIsRUFBa0M7QUFDakMsTUFBSW9XLFNBQVNGLGFBQWNsVyxPQUFkLElBQTBCLEVBQXZDO0FBQ0E5QyxTQUFPeUIsSUFBUCxDQUFhcUIsUUFBUWtILEtBQVIsQ0FBZStPLFNBQWYsS0FBOEIsRUFBM0MsRUFBK0MsVUFBVXhQLENBQVYsRUFBYTRQLElBQWIsRUFBb0I7QUFDbEVELFVBQVFDLElBQVIsSUFBaUIsSUFBakI7QUFDQSxHQUZEO0FBR0EsU0FBT0QsTUFBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBbFosUUFBT29aLFNBQVAsR0FBbUIsVUFBVXRXLE9BQVYsRUFBb0I7O0FBRXRDO0FBQ0E7QUFDQUEsWUFBVSxPQUFPQSxPQUFQLEtBQW1CLFFBQW5CLEdBQ1BrVyxhQUFjbFcsT0FBZCxLQUEyQm1XLGNBQWVuVyxPQUFmLENBRHBCLEdBRVQ5QyxPQUFPeUMsTUFBUCxDQUFlLEVBQWYsRUFBbUJLLE9BQW5CLENBRkQ7O0FBSUEsTUFBSTtBQUNIdVcsUUFERDs7QUFFQztBQUNBQyxRQUhEOztBQUlDO0FBQ0FDLFFBTEQ7O0FBTUM7QUFDQUMsY0FQRDs7QUFRQztBQUNBQyxhQVREOztBQVVDO0FBQ0FDLGFBWEQ7O0FBWUM7QUFDQUMsU0FBTyxFQWJSOztBQWNDO0FBQ0FDLFVBQVEsQ0FBQzlXLFFBQVErVyxJQUFULElBQWlCLEVBZjFCOztBQWdCQztBQUNBQyxTQUFPLFNBQVBBLElBQU8sQ0FBVXBWLElBQVYsRUFBaUI7QUFDdkI0VSxZQUFTeFcsUUFBUXdXLE1BQVIsSUFBa0I1VSxJQUEzQjtBQUNBNlUsWUFBUSxJQUFSO0FBQ0FFLGlCQUFjQyxlQUFlLENBQTdCO0FBQ0FBLGlCQUFjLENBQWQ7QUFDQUYsa0JBQWVHLEtBQUs1WSxNQUFwQjtBQUNBc1ksWUFBUyxJQUFUO0FBQ0EsVUFBUU0sUUFBUUYsY0FBY0QsWUFBOUIsRUFBNENDLGFBQTVDLEVBQTREO0FBQzNELFFBQUtFLEtBQU1GLFdBQU4sRUFBb0IxWCxLQUFwQixDQUEyQjJDLEtBQU0sQ0FBTixDQUEzQixFQUFzQ0EsS0FBTSxDQUFOLENBQXRDLE1BQXNELEtBQXRELElBQStENUIsUUFBUWlYLFdBQTVFLEVBQTBGO0FBQ3pGVCxjQUFTLEtBQVQsQ0FEeUYsQ0FDekU7QUFDaEI7QUFDQTtBQUNEO0FBQ0RELFlBQVMsS0FBVDtBQUNBLE9BQUtNLElBQUwsRUFBWTtBQUNYLFFBQUtDLEtBQUwsRUFBYTtBQUNaLFNBQUtBLE1BQU03WSxNQUFYLEVBQW9CO0FBQ25CK1ksV0FBTUYsTUFBTS9OLEtBQU4sRUFBTjtBQUNBO0FBQ0QsS0FKRCxNQUlPLElBQUt5TixNQUFMLEVBQWM7QUFDcEJLLFlBQU8sRUFBUDtBQUNBLEtBRk0sTUFFQTtBQUNOOUMsVUFBS21ELE9BQUw7QUFDQTtBQUNEO0FBQ0QsR0ExQ0Y7O0FBMkNDO0FBQ0FuRCxTQUFPO0FBQ047QUFDQXVCLFFBQUssZUFBVztBQUNmLFFBQUt1QixJQUFMLEVBQVk7QUFDWDtBQUNBLFNBQUl2SSxRQUFRdUksS0FBSzVZLE1BQWpCO0FBQ0EsTUFBQyxTQUFTcVgsR0FBVCxDQUFjelcsSUFBZCxFQUFxQjtBQUNyQjNCLGFBQU95QixJQUFQLENBQWFFLElBQWIsRUFBbUIsVUFBVTRILENBQVYsRUFBYXhELEdBQWIsRUFBbUI7QUFDckMsV0FBSWhDLE9BQU8vRCxPQUFPK0QsSUFBUCxDQUFhZ0MsR0FBYixDQUFYO0FBQ0EsV0FBS2hDLFNBQVMsVUFBZCxFQUEyQjtBQUMxQixZQUFLLENBQUNqQixRQUFRc1QsTUFBVCxJQUFtQixDQUFDUyxLQUFLZ0IsR0FBTCxDQUFVOVIsR0FBVixDQUF6QixFQUEyQztBQUMxQzRULGNBQUtwYSxJQUFMLENBQVd3RyxHQUFYO0FBQ0E7QUFDRCxRQUpELE1BSU8sSUFBS0EsT0FBT0EsSUFBSWhGLE1BQVgsSUFBcUJnRCxTQUFTLFFBQW5DLEVBQThDO0FBQ3BEO0FBQ0FxVSxZQUFLclMsR0FBTDtBQUNBO0FBQ0QsT0FWRDtBQVdBLE1BWkQsRUFZSS9ELFNBWko7QUFhQTtBQUNBO0FBQ0EsU0FBS3FYLE1BQUwsRUFBYztBQUNiRyxxQkFBZUcsS0FBSzVZLE1BQXBCO0FBQ0Q7QUFDQTtBQUNDLE1BSkQsTUFJTyxJQUFLdVksTUFBTCxFQUFjO0FBQ3BCSSxvQkFBY3RJLEtBQWQ7QUFDQTBJLFdBQU1SLE1BQU47QUFDQTtBQUNEO0FBQ0QsV0FBTyxJQUFQO0FBQ0EsSUEvQks7QUFnQ047QUFDQVcsV0FBUSxrQkFBVztBQUNsQixRQUFLTixJQUFMLEVBQVk7QUFDWDNaLFlBQU95QixJQUFQLENBQWFPLFNBQWIsRUFBd0IsVUFBVXVILENBQVYsRUFBYXhELEdBQWIsRUFBbUI7QUFDMUMsVUFBSW1TLEtBQUo7QUFDQSxhQUFRLENBQUVBLFFBQVFsWSxPQUFPdUYsT0FBUCxDQUFnQlEsR0FBaEIsRUFBcUI0VCxJQUFyQixFQUEyQnpCLEtBQTNCLENBQVYsSUFBaUQsQ0FBQyxDQUExRCxFQUE4RDtBQUM3RHlCLFlBQUtuWCxNQUFMLENBQWEwVixLQUFiLEVBQW9CLENBQXBCO0FBQ0E7QUFDQSxXQUFLbUIsTUFBTCxFQUFjO0FBQ2IsWUFBS25CLFNBQVNzQixZQUFkLEVBQTZCO0FBQzVCQTtBQUNBO0FBQ0QsWUFBS3RCLFNBQVN1QixXQUFkLEVBQTRCO0FBQzNCQTtBQUNBO0FBQ0Q7QUFDRDtBQUNELE1BZEQ7QUFlQTtBQUNELFdBQU8sSUFBUDtBQUNBLElBcERLO0FBcUROO0FBQ0E7QUFDQTVCLFFBQUssYUFBVTFYLEVBQVYsRUFBZTtBQUNuQixXQUFPQSxLQUFLSCxPQUFPdUYsT0FBUCxDQUFnQnBGLEVBQWhCLEVBQW9Cd1osSUFBcEIsSUFBNkIsQ0FBQyxDQUFuQyxHQUF1QyxDQUFDLEVBQUdBLFFBQVFBLEtBQUs1WSxNQUFoQixDQUEvQztBQUNBLElBekRLO0FBMEROO0FBQ0FtWixVQUFPLGlCQUFXO0FBQ2pCUCxXQUFPLEVBQVA7QUFDQUgsbUJBQWUsQ0FBZjtBQUNBLFdBQU8sSUFBUDtBQUNBLElBL0RLO0FBZ0VOO0FBQ0FRLFlBQVMsbUJBQVc7QUFDbkJMLFdBQU9DLFFBQVFOLFNBQVNqVyxTQUF4QjtBQUNBLFdBQU8sSUFBUDtBQUNBLElBcEVLO0FBcUVOO0FBQ0FpUCxhQUFVLG9CQUFXO0FBQ3BCLFdBQU8sQ0FBQ3FILElBQVI7QUFDQSxJQXhFSztBQXlFTjtBQUNBUSxTQUFNLGdCQUFXO0FBQ2hCUCxZQUFRdlcsU0FBUjtBQUNBLFFBQUssQ0FBQ2lXLE1BQU4sRUFBZTtBQUNkekMsVUFBS21ELE9BQUw7QUFDQTtBQUNELFdBQU8sSUFBUDtBQUNBLElBaEZLO0FBaUZOO0FBQ0FJLFdBQVEsa0JBQVc7QUFDbEIsV0FBTyxDQUFDUixLQUFSO0FBQ0EsSUFwRks7QUFxRk47QUFDQVMsYUFBVSxrQkFBVW5hLE9BQVYsRUFBbUJ5QixJQUFuQixFQUEwQjtBQUNuQyxRQUFLZ1ksU0FBVSxDQUFDSixNQUFELElBQVVLLEtBQXBCLENBQUwsRUFBbUM7QUFDbENqWSxZQUFPQSxRQUFRLEVBQWY7QUFDQUEsWUFBTyxDQUFFekIsT0FBRixFQUFXeUIsS0FBS3RDLEtBQUwsR0FBYXNDLEtBQUt0QyxLQUFMLEVBQWIsR0FBNEJzQyxJQUF2QyxDQUFQO0FBQ0EsU0FBSzBYLE1BQUwsRUFBYztBQUNiTyxZQUFNcmEsSUFBTixDQUFZb0MsSUFBWjtBQUNBLE1BRkQsTUFFTztBQUNObVksV0FBTW5ZLElBQU47QUFDQTtBQUNEO0FBQ0QsV0FBTyxJQUFQO0FBQ0EsSUFqR0s7QUFrR047QUFDQW1ZLFNBQU0sZ0JBQVc7QUFDaEJqRCxTQUFLd0QsUUFBTCxDQUFlLElBQWYsRUFBcUJyWSxTQUFyQjtBQUNBLFdBQU8sSUFBUDtBQUNBLElBdEdLO0FBdUdOO0FBQ0F1WCxVQUFPLGlCQUFXO0FBQ2pCLFdBQU8sQ0FBQyxDQUFDQSxNQUFUO0FBQ0E7QUExR0ssR0E1Q1I7O0FBeUpBLFNBQU8xQyxJQUFQO0FBQ0EsRUFsS0Q7O0FBcUtBN1csUUFBT3lDLE1BQVAsQ0FBYzs7QUFFYjZYLFlBQVUsa0JBQVVDLElBQVYsRUFBaUI7QUFDMUIsT0FBSUMsU0FBUztBQUNYO0FBQ0EsSUFBRSxTQUFGLEVBQWEsTUFBYixFQUFxQnhhLE9BQU9vWixTQUFQLENBQWlCLGFBQWpCLENBQXJCLEVBQXNELFVBQXRELENBRlcsRUFHWCxDQUFFLFFBQUYsRUFBWSxNQUFaLEVBQW9CcFosT0FBT29aLFNBQVAsQ0FBaUIsYUFBakIsQ0FBcEIsRUFBcUQsVUFBckQsQ0FIVyxFQUlYLENBQUUsUUFBRixFQUFZLFVBQVosRUFBd0JwWixPQUFPb1osU0FBUCxDQUFpQixRQUFqQixDQUF4QixDQUpXLENBQWI7QUFBQSxPQU1DcUIsU0FBUSxTQU5UO0FBQUEsT0FPQ0MsV0FBVTtBQUNURCxXQUFPLGlCQUFXO0FBQ2pCLFlBQU9BLE1BQVA7QUFDQSxLQUhRO0FBSVRFLFlBQVEsa0JBQVc7QUFDbEJDLGNBQVN0VCxJQUFULENBQWV0RixTQUFmLEVBQTJCNlksSUFBM0IsQ0FBaUM3WSxTQUFqQztBQUNBLFlBQU8sSUFBUDtBQUNBLEtBUFE7QUFRVDhZLFVBQU0sZ0JBQVUsZ0NBQW1DO0FBQ2xELFNBQUlDLE1BQU0vWSxTQUFWO0FBQ0EsWUFBT2hDLE9BQU9zYSxRQUFQLENBQWdCLFVBQVVVLFFBQVYsRUFBcUI7QUFDM0NoYixhQUFPeUIsSUFBUCxDQUFhK1ksTUFBYixFQUFxQixVQUFVMVksQ0FBVixFQUFhbVosS0FBYixFQUFxQjtBQUN6QyxXQUFJOWEsS0FBS0gsT0FBT2tELFVBQVAsQ0FBbUI2WCxJQUFLalosQ0FBTCxDQUFuQixLQUFpQ2laLElBQUtqWixDQUFMLENBQTFDO0FBQ0E7QUFDQThZLGdCQUFVSyxNQUFNLENBQU4sQ0FBVixFQUFxQixZQUFXO0FBQy9CLFlBQUlDLFdBQVcvYSxNQUFNQSxHQUFHNEIsS0FBSCxDQUFVLElBQVYsRUFBZ0JDLFNBQWhCLENBQXJCO0FBQ0EsWUFBS2taLFlBQVlsYixPQUFPa0QsVUFBUCxDQUFtQmdZLFNBQVNSLE9BQTVCLENBQWpCLEVBQXlEO0FBQ3hEUSxrQkFBU1IsT0FBVCxHQUNFcFQsSUFERixDQUNRMFQsU0FBU0csT0FEakIsRUFFRU4sSUFGRixDQUVRRyxTQUFTSSxNQUZqQixFQUdFQyxRQUhGLENBR1lMLFNBQVNNLE1BSHJCO0FBSUEsU0FMRCxNQUtPO0FBQ05OLGtCQUFVQyxNQUFPLENBQVAsSUFBYSxNQUF2QixFQUFpQyxTQUFTUCxRQUFULEdBQW1CTSxTQUFTTixPQUFULEVBQW5CLEdBQXdDLElBQXpFLEVBQStFdmEsS0FBSyxDQUFFK2EsUUFBRixDQUFMLEdBQW9CbFosU0FBbkc7QUFDQTtBQUNELFFBVkQ7QUFXQSxPQWREO0FBZUErWSxZQUFNLElBQU47QUFDQSxNQWpCTSxFQWlCSkwsT0FqQkksRUFBUDtBQWtCQSxLQTVCUTtBQTZCVDtBQUNBO0FBQ0FBLGFBQVMsaUJBQVU1VyxHQUFWLEVBQWdCO0FBQ3hCLFlBQU9BLE9BQU8sSUFBUCxHQUFjOUQsT0FBT3lDLE1BQVAsQ0FBZXFCLEdBQWYsRUFBb0I0VyxRQUFwQixDQUFkLEdBQThDQSxRQUFyRDtBQUNBO0FBakNRLElBUFg7QUFBQSxPQTBDQ0UsV0FBVyxFQTFDWjs7QUE0Q0E7QUFDQUYsWUFBUWEsSUFBUixHQUFlYixTQUFRSSxJQUF2Qjs7QUFFQTtBQUNBOWEsVUFBT3lCLElBQVAsQ0FBYStZLE1BQWIsRUFBcUIsVUFBVTFZLENBQVYsRUFBYW1aLEtBQWIsRUFBcUI7QUFDekMsUUFBSXRCLE9BQU9zQixNQUFPLENBQVAsQ0FBWDtBQUFBLFFBQ0NPLGNBQWNQLE1BQU8sQ0FBUCxDQURmOztBQUdBO0FBQ0FQLGFBQVNPLE1BQU0sQ0FBTixDQUFULElBQXNCdEIsS0FBS3ZCLEdBQTNCOztBQUVBO0FBQ0EsUUFBS29ELFdBQUwsRUFBbUI7QUFDbEI3QixVQUFLdkIsR0FBTCxDQUFTLFlBQVc7QUFDbkI7QUFDQXFDLGVBQVFlLFdBQVI7O0FBRUQ7QUFDQyxNQUxELEVBS0doQixPQUFRMVksSUFBSSxDQUFaLEVBQWlCLENBQWpCLEVBQXFCa1ksT0FMeEIsRUFLaUNRLE9BQVEsQ0FBUixFQUFhLENBQWIsRUFBaUJMLElBTGxEO0FBTUE7O0FBRUQ7QUFDQVMsYUFBVUssTUFBTSxDQUFOLENBQVYsSUFBdUIsWUFBVztBQUNqQ0wsY0FBVUssTUFBTSxDQUFOLElBQVcsTUFBckIsRUFBK0IsU0FBU0wsUUFBVCxHQUFvQkYsUUFBcEIsR0FBOEIsSUFBN0QsRUFBbUUxWSxTQUFuRTtBQUNBLFlBQU8sSUFBUDtBQUNBLEtBSEQ7QUFJQTRZLGFBQVVLLE1BQU0sQ0FBTixJQUFXLE1BQXJCLElBQWdDdEIsS0FBS1UsUUFBckM7QUFDQSxJQXZCRDs7QUF5QkE7QUFDQUssWUFBUUEsT0FBUixDQUFpQkUsUUFBakI7O0FBRUE7QUFDQSxPQUFLTCxJQUFMLEVBQVk7QUFDWEEsU0FBS3RaLElBQUwsQ0FBVzJaLFFBQVgsRUFBcUJBLFFBQXJCO0FBQ0E7O0FBRUQ7QUFDQSxVQUFPQSxRQUFQO0FBQ0EsR0F0Rlk7O0FBd0ZiO0FBQ0FhLFFBQU0sY0FBVUMsV0FBVixDQUFzQix5QkFBdEIsRUFBa0Q7QUFDdkQsT0FBSTVaLElBQUksQ0FBUjtBQUFBLE9BQ0M2WixnQkFBZ0J0YyxPQUFNNEIsSUFBTixDQUFZZSxTQUFaLENBRGpCO0FBQUEsT0FFQ2pCLFNBQVM0YSxjQUFjNWEsTUFGeEI7OztBQUlDO0FBQ0E2YSxlQUFZN2EsV0FBVyxDQUFYLElBQWtCMmEsZUFBZTFiLE9BQU9rRCxVQUFQLENBQW1Cd1ksWUFBWWhCLE9BQS9CLENBQWpDLEdBQThFM1osTUFBOUUsR0FBdUYsQ0FMcEc7OztBQU9DO0FBQ0E2WixjQUFXZ0IsY0FBYyxDQUFkLEdBQWtCRixXQUFsQixHQUFnQzFiLE9BQU9zYSxRQUFQLEVBUjVDOzs7QUFVQztBQUNBdUIsZ0JBQWEsU0FBYkEsVUFBYSxDQUFVL1osQ0FBVixFQUFha1UsUUFBYixFQUF1QjhGLE1BQXZCLEVBQWdDO0FBQzVDLFdBQU8sVUFBVTlXLEtBQVYsRUFBa0I7QUFDeEJnUixjQUFVbFUsQ0FBVixJQUFnQixJQUFoQjtBQUNBZ2EsWUFBUWhhLENBQVIsSUFBY0UsVUFBVWpCLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUIxQixPQUFNNEIsSUFBTixDQUFZZSxTQUFaLENBQXZCLEdBQWlEZ0QsS0FBL0Q7QUFDQSxTQUFLOFcsV0FBV0MsY0FBaEIsRUFBaUM7QUFDaENuQixlQUFTb0IsVUFBVCxDQUFxQmhHLFFBQXJCLEVBQStCOEYsTUFBL0I7QUFFQSxNQUhELE1BR08sSUFBSyxDQUFFLEdBQUVGLFNBQVQsRUFBc0I7QUFDNUJoQixlQUFTcUIsV0FBVCxDQUFzQmpHLFFBQXRCLEVBQWdDOEYsTUFBaEM7QUFDQTtBQUNELEtBVEQ7QUFVQSxJQXRCRjtBQUFBLE9Bd0JDQyxjQXhCRDtBQUFBLE9Bd0JpQkcsZ0JBeEJqQjtBQUFBLE9Bd0JtQ0MsZUF4Qm5DOztBQTBCQTtBQUNBLE9BQUtwYixTQUFTLENBQWQsRUFBa0I7QUFDakJnYixxQkFBaUIsSUFBSS9YLEtBQUosQ0FBV2pELE1BQVgsQ0FBakI7QUFDQW1iLHVCQUFtQixJQUFJbFksS0FBSixDQUFXakQsTUFBWCxDQUFuQjtBQUNBb2Isc0JBQWtCLElBQUluWSxLQUFKLENBQVdqRCxNQUFYLENBQWxCO0FBQ0EsV0FBUWUsSUFBSWYsTUFBWixFQUFvQmUsR0FBcEIsRUFBMEI7QUFDekIsU0FBSzZaLGNBQWU3WixDQUFmLEtBQXNCOUIsT0FBT2tELFVBQVAsQ0FBbUJ5WSxjQUFlN1osQ0FBZixFQUFtQjRZLE9BQXRDLENBQTNCLEVBQTZFO0FBQzVFaUIsb0JBQWU3WixDQUFmLEVBQW1CNFksT0FBbkIsR0FDRXBULElBREYsQ0FDUXVVLFdBQVkvWixDQUFaLEVBQWVxYSxlQUFmLEVBQWdDUixhQUFoQyxDQURSLEVBRUVkLElBRkYsQ0FFUUQsU0FBU1EsTUFGakIsRUFHRUMsUUFIRixDQUdZUSxXQUFZL1osQ0FBWixFQUFlb2EsZ0JBQWYsRUFBaUNILGNBQWpDLENBSFo7QUFJQSxNQUxELE1BS087QUFDTixRQUFFSCxTQUFGO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0EsT0FBSyxDQUFDQSxTQUFOLEVBQWtCO0FBQ2pCaEIsYUFBU3FCLFdBQVQsQ0FBc0JFLGVBQXRCLEVBQXVDUixhQUF2QztBQUNBOztBQUVELFVBQU9mLFNBQVNGLE9BQVQsRUFBUDtBQUNBO0FBM0lZLEVBQWQ7O0FBK0lBO0FBQ0EsS0FBSTBCLFNBQUo7O0FBRUFwYyxRQUFPRyxFQUFQLENBQVUrVyxLQUFWLEdBQWtCLFVBQVUvVyxFQUFWLEVBQWU7QUFDaEM7QUFDQUgsU0FBT2tYLEtBQVAsQ0FBYXdELE9BQWIsR0FBdUJwVCxJQUF2QixDQUE2Qm5ILEVBQTdCOztBQUVBLFNBQU8sSUFBUDtBQUNBLEVBTEQ7O0FBT0FILFFBQU95QyxNQUFQLENBQWM7QUFDYjtBQUNBaUIsV0FBUyxLQUZJOztBQUliO0FBQ0E7QUFDQTJZLGFBQVcsQ0FORTs7QUFRYjtBQUNBQyxhQUFXLG1CQUFVQyxJQUFWLEVBQWlCO0FBQzNCLE9BQUtBLElBQUwsRUFBWTtBQUNYdmMsV0FBT3FjLFNBQVA7QUFDQSxJQUZELE1BRU87QUFDTnJjLFdBQU9rWCxLQUFQLENBQWMsSUFBZDtBQUNBO0FBQ0QsR0FmWTs7QUFpQmI7QUFDQUEsU0FBTyxlQUFVc0YsSUFBVixFQUFpQjs7QUFFdkI7QUFDQSxPQUFLQSxTQUFTLElBQVQsR0FBZ0IsRUFBRXhjLE9BQU9xYyxTQUF6QixHQUFxQ3JjLE9BQU8wRCxPQUFqRCxFQUEyRDtBQUMxRDtBQUNBOztBQUVEO0FBQ0EsT0FBSyxDQUFDM0UsU0FBUzBkLElBQWYsRUFBc0I7QUFDckIsV0FBT0MsV0FBWTFjLE9BQU9rWCxLQUFuQixDQUFQO0FBQ0E7O0FBRUQ7QUFDQWxYLFVBQU8wRCxPQUFQLEdBQWlCLElBQWpCOztBQUVBO0FBQ0EsT0FBSzhZLFNBQVMsSUFBVCxJQUFpQixFQUFFeGMsT0FBT3FjLFNBQVQsR0FBcUIsQ0FBM0MsRUFBK0M7QUFDOUM7QUFDQTs7QUFFRDtBQUNBRCxhQUFVSCxXQUFWLENBQXVCbGQsUUFBdkIsRUFBaUMsQ0FBRWlCLE1BQUYsQ0FBakM7O0FBRUE7QUFDQSxPQUFLQSxPQUFPRyxFQUFQLENBQVV3YyxPQUFmLEVBQXlCO0FBQ3hCM2MsV0FBUWpCLFFBQVIsRUFBbUI0ZCxPQUFuQixDQUEyQixPQUEzQixFQUFvQ0MsR0FBcEMsQ0FBd0MsT0FBeEM7QUFDQTtBQUNEO0FBN0NZLEVBQWQ7O0FBZ0RBOzs7QUFHQSxVQUFTQyxNQUFULEdBQWtCO0FBQ2pCLE1BQUs5ZCxTQUFTeU8sZ0JBQWQsRUFBaUM7QUFDaEN6TyxZQUFTK2QsbUJBQVQsQ0FBOEIsa0JBQTlCLEVBQWtEQyxTQUFsRCxFQUE2RCxLQUE3RDtBQUNBN2QsVUFBTzRkLG1CQUFQLENBQTRCLE1BQTVCLEVBQW9DQyxTQUFwQyxFQUErQyxLQUEvQztBQUVBLEdBSkQsTUFJTztBQUNOaGUsWUFBU2llLFdBQVQsQ0FBc0Isb0JBQXRCLEVBQTRDRCxTQUE1QztBQUNBN2QsVUFBTzhkLFdBQVAsQ0FBb0IsUUFBcEIsRUFBOEJELFNBQTlCO0FBQ0E7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU0EsU0FBVCxHQUFxQjtBQUNwQjtBQUNBLE1BQUtoZSxTQUFTeU8sZ0JBQVQsSUFBNkJ5UCxNQUFNbFosSUFBTixLQUFlLE1BQTVDLElBQXNEaEYsU0FBU21lLFVBQVQsS0FBd0IsVUFBbkYsRUFBZ0c7QUFDL0ZMO0FBQ0E3YyxVQUFPa1gsS0FBUDtBQUNBO0FBQ0Q7O0FBRURsWCxRQUFPa1gsS0FBUCxDQUFhd0QsT0FBYixHQUF1QixVQUFVNVcsR0FBVixFQUFnQjtBQUN0QyxNQUFLLENBQUNzWSxTQUFOLEVBQWtCOztBQUVqQkEsZUFBWXBjLE9BQU9zYSxRQUFQLEVBQVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBS3ZiLFNBQVNtZSxVQUFULEtBQXdCLFVBQTdCLEVBQTBDO0FBQ3pDO0FBQ0FSLGVBQVkxYyxPQUFPa1gsS0FBbkI7O0FBRUQ7QUFDQyxJQUxELE1BS08sSUFBS25ZLFNBQVN5TyxnQkFBZCxFQUFpQztBQUN2QztBQUNBek8sYUFBU3lPLGdCQUFULENBQTJCLGtCQUEzQixFQUErQ3VQLFNBQS9DLEVBQTBELEtBQTFEOztBQUVBO0FBQ0E3ZCxXQUFPc08sZ0JBQVAsQ0FBeUIsTUFBekIsRUFBaUN1UCxTQUFqQyxFQUE0QyxLQUE1Qzs7QUFFRDtBQUNDLElBUk0sTUFRQTtBQUNOO0FBQ0FoZSxhQUFTME8sV0FBVCxDQUFzQixvQkFBdEIsRUFBNENzUCxTQUE1Qzs7QUFFQTtBQUNBN2QsV0FBT3VPLFdBQVAsQ0FBb0IsUUFBcEIsRUFBOEJzUCxTQUE5Qjs7QUFFQTtBQUNBO0FBQ0EsUUFBSXhQLE1BQU0sS0FBVjs7QUFFQSxRQUFJO0FBQ0hBLFdBQU1yTyxPQUFPaWUsWUFBUCxJQUF1QixJQUF2QixJQUErQnBlLFNBQVNrTyxlQUE5QztBQUNBLEtBRkQsQ0FFRSxPQUFNMUksQ0FBTixFQUFTLENBQUU7O0FBRWIsUUFBS2dKLE9BQU9BLElBQUk2UCxRQUFoQixFQUEyQjtBQUMxQixNQUFDLFNBQVNDLGFBQVQsR0FBeUI7QUFDekIsVUFBSyxDQUFDcmQsT0FBTzBELE9BQWIsRUFBdUI7O0FBRXRCLFdBQUk7QUFDSDtBQUNBO0FBQ0E2SixZQUFJNlAsUUFBSixDQUFhLE1BQWI7QUFDQSxRQUpELENBSUUsT0FBTTdZLENBQU4sRUFBUztBQUNWLGVBQU9tWSxXQUFZVyxhQUFaLEVBQTJCLEVBQTNCLENBQVA7QUFDQTs7QUFFRDtBQUNBUjs7QUFFQTtBQUNBN2MsY0FBT2tYLEtBQVA7QUFDQTtBQUNELE1BakJEO0FBa0JBO0FBQ0Q7QUFDRDtBQUNELFNBQU9rRixVQUFVMUIsT0FBVixDQUFtQjVXLEdBQW5CLENBQVA7QUFDQSxFQTNERDs7QUE4REEsS0FBSWdFLGVBQUEsOEJBQXNCekUsU0FBdEIsQ0FBSjs7QUFJQTtBQUNBO0FBQ0EsS0FBSXZCLENBQUo7QUFDQSxNQUFNQSxDQUFOLElBQVc5QixPQUFRRixPQUFSLENBQVgsRUFBK0I7QUFDOUI7QUFDQTtBQUNEQSxTQUFRMEUsT0FBUixHQUFrQjFDLE1BQU0sR0FBeEI7O0FBRUE7QUFDQTtBQUNBaEMsU0FBUXdkLHNCQUFSLEdBQWlDLEtBQWpDOztBQUVBdGQsUUFBTyxZQUFXO0FBQ2pCO0FBQ0E7O0FBRUEsTUFBSXVkLFNBQUo7QUFBQSxNQUFldlIsR0FBZjtBQUFBLE1BQ0N5USxPQUFPMWQsU0FBUzZMLG9CQUFULENBQThCLE1BQTlCLEVBQXNDLENBQXRDLENBRFI7O0FBR0EsTUFBSyxDQUFDNlIsSUFBTixFQUFhO0FBQ1o7QUFDQTtBQUNBOztBQUVEO0FBQ0FjLGNBQVl4ZSxTQUFTa04sYUFBVCxDQUF3QixLQUF4QixDQUFaO0FBQ0FzUixZQUFVQyxLQUFWLENBQWdCQyxPQUFoQixHQUEwQiwrRUFBMUI7O0FBRUF6UixRQUFNak4sU0FBU2tOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBTjtBQUNBd1EsT0FBSzlPLFdBQUwsQ0FBa0I0UCxTQUFsQixFQUE4QjVQLFdBQTlCLENBQTJDM0IsR0FBM0M7O0FBRUEsTUFBSyxRQUFPQSxJQUFJd1IsS0FBSixDQUFVRSxJQUFqQixNQUEwQjVWLFlBQS9CLEVBQThDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0FrRSxPQUFJd1IsS0FBSixDQUFVQyxPQUFWLEdBQW9CLCtEQUFwQjs7QUFFQSxPQUFNM2QsUUFBUXdkLHNCQUFSLEdBQW1DdFIsSUFBSTJSLFdBQUosS0FBb0IsQ0FBN0QsRUFBb0U7QUFDbkU7QUFDQTtBQUNBO0FBQ0FsQixTQUFLZSxLQUFMLENBQVdFLElBQVgsR0FBa0IsQ0FBbEI7QUFDQTtBQUNEOztBQUVEakIsT0FBS3ZRLFdBQUwsQ0FBa0JxUixTQUFsQjs7QUFFQTtBQUNBQSxjQUFZdlIsTUFBTSxJQUFsQjtBQUNBLEVBdENEOztBQTJDQSxFQUFDLFlBQVc7QUFDWCxNQUFJQSxNQUFNak4sU0FBU2tOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBVjs7QUFFQTtBQUNBLE1BQUluTSxRQUFROGQsYUFBUixJQUF5QixJQUE3QixFQUFtQztBQUNsQztBQUNBOWQsV0FBUThkLGFBQVIsR0FBd0IsSUFBeEI7QUFDQSxPQUFJO0FBQ0gsV0FBTzVSLElBQUlqQixJQUFYO0FBQ0EsSUFGRCxDQUVFLE9BQU94RyxDQUFQLEVBQVc7QUFDWnpFLFlBQVE4ZCxhQUFSLEdBQXdCLEtBQXhCO0FBQ0E7QUFDRDs7QUFFRDtBQUNBNVIsUUFBTSxJQUFOO0FBQ0EsRUFoQkQ7O0FBbUJBOzs7QUFHQWhNLFFBQU82ZCxVQUFQLEdBQW9CLFVBQVVoYyxJQUFWLEVBQWlCO0FBQ3BDLE1BQUlpYyxTQUFTOWQsT0FBTzhkLE1BQVAsQ0FBZSxDQUFDamMsS0FBS2lELFFBQUwsR0FBZ0IsR0FBakIsRUFBc0JDLFdBQXRCLEVBQWYsQ0FBYjtBQUFBLE1BQ0NULFdBQVcsQ0FBQ3pDLEtBQUt5QyxRQUFOLElBQWtCLENBRDlCOztBQUdBO0FBQ0EsU0FBT0EsYUFBYSxDQUFiLElBQWtCQSxhQUFhLENBQS9CLEdBQ04sS0FETTs7QUFHTjtBQUNBLEdBQUN3WixNQUFELElBQVdBLFdBQVcsSUFBWCxJQUFtQmpjLEtBQUtvSixZQUFMLENBQWtCLFNBQWxCLE1BQWlDNlMsTUFKaEU7QUFLQSxFQVZEOztBQWFBLEtBQUlDLFNBQVMsK0JBQWI7QUFBQSxLQUNDQyxhQUFhLFVBRGQ7O0FBR0EsVUFBU0MsUUFBVCxDQUFtQnBjLElBQW5CLEVBQXlCd0MsR0FBekIsRUFBOEJLLElBQTlCLEVBQXFDO0FBQ3BDO0FBQ0E7QUFDQSxNQUFLQSxTQUFTckIsU0FBVCxJQUFzQnhCLEtBQUt5QyxRQUFMLEtBQWtCLENBQTdDLEVBQWlEOztBQUVoRCxPQUFJekIsT0FBTyxVQUFVd0IsSUFBSVosT0FBSixDQUFhdWEsVUFBYixFQUF5QixLQUF6QixFQUFpQ2paLFdBQWpDLEVBQXJCOztBQUVBTCxVQUFPN0MsS0FBS29KLFlBQUwsQ0FBbUJwSSxJQUFuQixDQUFQOztBQUVBLE9BQUssT0FBTzZCLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7QUFDL0IsUUFBSTtBQUNIQSxZQUFPQSxTQUFTLE1BQVQsR0FBa0IsSUFBbEIsR0FDTkEsU0FBUyxPQUFULEdBQW1CLEtBQW5CLEdBQ0FBLFNBQVMsTUFBVCxHQUFrQixJQUFsQjtBQUNBO0FBQ0EsTUFBQ0EsSUFBRCxHQUFRLEVBQVIsS0FBZUEsSUFBZixHQUFzQixDQUFDQSxJQUF2QixHQUNBcVosT0FBT2hULElBQVAsQ0FBYXJHLElBQWIsSUFBc0IxRSxPQUFPa2UsU0FBUCxDQUFrQnhaLElBQWxCLENBQXRCLEdBQ0FBLElBTkQ7QUFPQSxLQVJELENBUUUsT0FBT0gsQ0FBUCxFQUFXLENBQUU7O0FBRWY7QUFDQXZFLFdBQU8wRSxJQUFQLENBQWE3QyxJQUFiLEVBQW1Cd0MsR0FBbkIsRUFBd0JLLElBQXhCO0FBRUEsSUFkRCxNQWNPO0FBQ05BLFdBQU9yQixTQUFQO0FBQ0E7QUFDRDs7QUFFRCxTQUFPcUIsSUFBUDtBQUNBOztBQUVEO0FBQ0EsVUFBU3laLGlCQUFULENBQTRCcmEsR0FBNUIsRUFBa0M7QUFDakMsTUFBSWpCLElBQUo7QUFDQSxPQUFNQSxJQUFOLElBQWNpQixHQUFkLEVBQW9COztBQUVuQjtBQUNBLE9BQUtqQixTQUFTLE1BQVQsSUFBbUI3QyxPQUFPb0UsYUFBUCxDQUFzQk4sSUFBSWpCLElBQUosQ0FBdEIsQ0FBeEIsRUFBNEQ7QUFDM0Q7QUFDQTtBQUNELE9BQUtBLFNBQVMsUUFBZCxFQUF5QjtBQUN4QixXQUFPLEtBQVA7QUFDQTtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNBOztBQUVELFVBQVN1YixZQUFULENBQXVCdmMsSUFBdkIsRUFBNkJnQixJQUE3QixFQUFtQzZCLElBQW5DLEVBQXlDMlosR0FBekMsQ0FBNkMsdUJBQTdDLEVBQXVFO0FBQ3RFLE1BQUssQ0FBQ3JlLE9BQU82ZCxVQUFQLENBQW1CaGMsSUFBbkIsQ0FBTixFQUFrQztBQUNqQztBQUNBOztBQUVELE1BQUlQLEdBQUo7QUFBQSxNQUFTZ2QsU0FBVDtBQUFBLE1BQ0NDLGNBQWN2ZSxPQUFPc0QsT0FEdEI7OztBQUdDO0FBQ0E7QUFDQWtiLFdBQVMzYyxLQUFLeUMsUUFMZjs7O0FBT0M7QUFDQTtBQUNBcUgsVUFBUTZTLFNBQVN4ZSxPQUFPMkwsS0FBaEIsR0FBd0I5SixJQVRqQzs7O0FBV0M7QUFDQTtBQUNBOEksT0FBSzZULFNBQVMzYyxLQUFNMGMsV0FBTixDQUFULEdBQStCMWMsS0FBTTBjLFdBQU4sS0FBdUJBLFdBYjVEOztBQWVBO0FBQ0E7QUFDQSxNQUFLLENBQUMsQ0FBQzVULEVBQUQsSUFBTyxDQUFDZ0IsTUFBTWhCLEVBQU4sQ0FBUixJQUFzQixDQUFDMFQsR0FBRCxJQUFRLENBQUMxUyxNQUFNaEIsRUFBTixFQUFVakcsSUFBMUMsS0FBb0RBLFNBQVNyQixTQUE3RCxJQUEwRSxPQUFPUixJQUFQLEtBQWdCLFFBQS9GLEVBQTBHO0FBQ3pHO0FBQ0E7O0FBRUQsTUFBSyxDQUFDOEgsRUFBTixFQUFXO0FBQ1Y7QUFDQTtBQUNBLE9BQUs2VCxNQUFMLEVBQWM7QUFDYjdULFNBQUs5SSxLQUFNMGMsV0FBTixJQUFzQm5mLFdBQVc0SSxHQUFYLE1BQW9CaEksT0FBT2dHLElBQVAsRUFBL0M7QUFDQSxJQUZELE1BRU87QUFDTjJFLFNBQUs0VCxXQUFMO0FBQ0E7QUFDRDs7QUFFRCxNQUFLLENBQUM1UyxNQUFPaEIsRUFBUCxDQUFOLEVBQW9CO0FBQ25CO0FBQ0E7QUFDQWdCLFNBQU9oQixFQUFQLElBQWM2VCxTQUFTLEVBQVQsR0FBYyxFQUFFQyxRQUFRemUsT0FBTzZELElBQWpCLEVBQTVCO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLE1BQUssUUFBT2hCLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEIsT0FBT0EsSUFBUCxLQUFnQixVQUFqRCxFQUE4RDtBQUM3RCxPQUFLd2IsR0FBTCxFQUFXO0FBQ1YxUyxVQUFPaEIsRUFBUCxJQUFjM0ssT0FBT3lDLE1BQVAsQ0FBZWtKLE1BQU9oQixFQUFQLENBQWYsRUFBNEI5SCxJQUE1QixDQUFkO0FBQ0EsSUFGRCxNQUVPO0FBQ044SSxVQUFPaEIsRUFBUCxFQUFZakcsSUFBWixHQUFtQjFFLE9BQU95QyxNQUFQLENBQWVrSixNQUFPaEIsRUFBUCxFQUFZakcsSUFBM0IsRUFBaUM3QixJQUFqQyxDQUFuQjtBQUNBO0FBQ0Q7O0FBRUR5YixjQUFZM1MsTUFBT2hCLEVBQVAsQ0FBWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLENBQUMwVCxHQUFOLEVBQVk7QUFDWCxPQUFLLENBQUNDLFVBQVU1WixJQUFoQixFQUF1QjtBQUN0QjRaLGNBQVU1WixJQUFWLEdBQWlCLEVBQWpCO0FBQ0E7O0FBRUQ0WixlQUFZQSxVQUFVNVosSUFBdEI7QUFDQTs7QUFFRCxNQUFLQSxTQUFTckIsU0FBZCxFQUEwQjtBQUN6QmliLGFBQVd0ZSxPQUFPNEUsU0FBUCxDQUFrQi9CLElBQWxCLENBQVgsSUFBd0M2QixJQUF4QztBQUNBOztBQUVEO0FBQ0E7QUFDQSxNQUFLLE9BQU83QixJQUFQLEtBQWdCLFFBQXJCLEVBQWdDOztBQUUvQjtBQUNBdkIsU0FBTWdkLFVBQVd6YixJQUFYLENBQU47O0FBRUE7QUFDQSxPQUFLdkIsT0FBTyxJQUFaLEVBQW1COztBQUVsQjtBQUNBQSxVQUFNZ2QsVUFBV3RlLE9BQU80RSxTQUFQLENBQWtCL0IsSUFBbEIsQ0FBWCxDQUFOO0FBQ0E7QUFDRCxHQVhELE1BV087QUFDTnZCLFNBQU1nZCxTQUFOO0FBQ0E7O0FBRUQsU0FBT2hkLEdBQVA7QUFDQTs7QUFFRCxVQUFTb2Qsa0JBQVQsQ0FBNkI3YyxJQUE3QixFQUFtQ2dCLElBQW5DLEVBQXlDd2IsR0FBekMsRUFBK0M7QUFDOUMsTUFBSyxDQUFDcmUsT0FBTzZkLFVBQVAsQ0FBbUJoYyxJQUFuQixDQUFOLEVBQWtDO0FBQ2pDO0FBQ0E7O0FBRUQsTUFBSXljLFNBQUo7QUFBQSxNQUFleGMsQ0FBZjtBQUFBLE1BQ0MwYyxTQUFTM2MsS0FBS3lDLFFBRGY7OztBQUdDO0FBQ0FxSCxVQUFRNlMsU0FBU3hlLE9BQU8yTCxLQUFoQixHQUF3QjlKLElBSmpDO0FBQUEsTUFLQzhJLEtBQUs2VCxTQUFTM2MsS0FBTTdCLE9BQU9zRCxPQUFiLENBQVQsR0FBa0N0RCxPQUFPc0QsT0FML0M7O0FBT0E7QUFDQTtBQUNBLE1BQUssQ0FBQ3FJLE1BQU9oQixFQUFQLENBQU4sRUFBb0I7QUFDbkI7QUFDQTs7QUFFRCxNQUFLOUgsSUFBTCxFQUFZOztBQUVYeWIsZUFBWUQsTUFBTTFTLE1BQU9oQixFQUFQLENBQU4sR0FBb0JnQixNQUFPaEIsRUFBUCxFQUFZakcsSUFBNUM7O0FBRUEsT0FBSzRaLFNBQUwsRUFBaUI7O0FBRWhCO0FBQ0EsUUFBSyxDQUFDdGUsT0FBT29ELE9BQVAsQ0FBZ0JQLElBQWhCLENBQU4sRUFBK0I7O0FBRTlCO0FBQ0EsU0FBS0EsUUFBUXliLFNBQWIsRUFBeUI7QUFDeEJ6YixhQUFPLENBQUVBLElBQUYsQ0FBUDtBQUNBLE1BRkQsTUFFTzs7QUFFTjtBQUNBQSxhQUFPN0MsT0FBTzRFLFNBQVAsQ0FBa0IvQixJQUFsQixDQUFQO0FBQ0EsVUFBS0EsUUFBUXliLFNBQWIsRUFBeUI7QUFDeEJ6YixjQUFPLENBQUVBLElBQUYsQ0FBUDtBQUNBLE9BRkQsTUFFTztBQUNOQSxjQUFPQSxLQUFLd0QsS0FBTCxDQUFXLEdBQVgsQ0FBUDtBQUNBO0FBQ0Q7QUFDRCxLQWZELE1BZU87QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXhELFlBQU9BLEtBQUt2RCxNQUFMLENBQWFVLE9BQU80QixHQUFQLENBQVlpQixJQUFaLEVBQWtCN0MsT0FBTzRFLFNBQXpCLENBQWIsQ0FBUDtBQUNBOztBQUVEOUMsUUFBSWUsS0FBSzlCLE1BQVQ7QUFDQSxXQUFRZSxHQUFSLEVBQWM7QUFDYixZQUFPd2MsVUFBV3piLEtBQUtmLENBQUwsQ0FBWCxDQUFQO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLFFBQUt1YyxNQUFNLENBQUNGLGtCQUFrQkcsU0FBbEIsQ0FBUCxHQUFzQyxDQUFDdGUsT0FBT29FLGFBQVAsQ0FBcUJrYSxTQUFyQixDQUE1QyxFQUE4RTtBQUM3RTtBQUNBO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLE1BQUssQ0FBQ0QsR0FBTixFQUFZO0FBQ1gsVUFBTzFTLE1BQU9oQixFQUFQLEVBQVlqRyxJQUFuQjs7QUFFQTtBQUNBO0FBQ0EsT0FBSyxDQUFDeVosa0JBQW1CeFMsTUFBT2hCLEVBQVAsQ0FBbkIsQ0FBTixFQUF5QztBQUN4QztBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFLNlQsTUFBTCxFQUFjO0FBQ2J4ZSxVQUFPMmUsU0FBUCxDQUFrQixDQUFFOWMsSUFBRixDQUFsQixFQUE0QixJQUE1Qjs7QUFFRDtBQUNBO0FBQ0MsR0FMRCxNQUtPLElBQUsvQixRQUFROGQsYUFBUixJQUF5QmpTLFNBQVNBLE1BQU16TSxNQUE3QyxFQUFzRDtBQUM1RDtBQUNBLFVBQU95TSxNQUFPaEIsRUFBUCxDQUFQOztBQUVEO0FBQ0MsR0FMTSxNQUtBO0FBQ05nQixTQUFPaEIsRUFBUCxJQUFjLElBQWQ7QUFDQTtBQUNEOztBQUVEM0ssUUFBT3lDLE1BQVAsQ0FBYztBQUNia0osU0FBTyxFQURNOztBQUdiO0FBQ0E7QUFDQW1TLFVBQVE7QUFDUCxjQUFXLElBREo7QUFFUCxhQUFVLElBRkg7QUFHUDtBQUNBLGNBQVc7QUFKSixHQUxLOztBQVliYyxXQUFTLGlCQUFVL2MsSUFBVixFQUFpQjtBQUN6QkEsVUFBT0EsS0FBS3lDLFFBQUwsR0FBZ0J0RSxPQUFPMkwsS0FBUCxDQUFjOUosS0FBSzdCLE9BQU9zRCxPQUFaLENBQWQsQ0FBaEIsR0FBdUR6QixLQUFNN0IsT0FBT3NELE9BQWIsQ0FBOUQ7QUFDQSxVQUFPLENBQUMsQ0FBQ3pCLElBQUYsSUFBVSxDQUFDc2Msa0JBQW1CdGMsSUFBbkIsQ0FBbEI7QUFDQSxHQWZZOztBQWlCYjZDLFFBQU0sY0FBVTdDLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQjZCLEtBQXRCLEVBQTZCO0FBQ2xDLFVBQU8wWixhQUFjdmMsSUFBZCxFQUFvQmdCLElBQXBCLEVBQTBCNkIsS0FBMUIsQ0FBUDtBQUNBLEdBbkJZOztBQXFCYm1hLGNBQVksb0JBQVVoZCxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBdUI7QUFDbEMsVUFBTzZiLG1CQUFvQjdjLElBQXBCLEVBQTBCZ0IsSUFBMUIsQ0FBUDtBQUNBLEdBdkJZOztBQXlCYjtBQUNBaWMsU0FBTyxlQUFVamQsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCNkIsSUFBdEIsRUFBNkI7QUFDbkMsVUFBTzBaLGFBQWN2YyxJQUFkLEVBQW9CZ0IsSUFBcEIsRUFBMEI2QixJQUExQixFQUFnQyxJQUFoQyxDQUFQO0FBQ0EsR0E1Qlk7O0FBOEJicWEsZUFBYSxxQkFBVWxkLElBQVYsRUFBZ0JnQixJQUFoQixFQUF1QjtBQUNuQyxVQUFPNmIsbUJBQW9CN2MsSUFBcEIsRUFBMEJnQixJQUExQixFQUFnQyxJQUFoQyxDQUFQO0FBQ0E7QUFoQ1ksRUFBZDs7QUFtQ0E3QyxRQUFPRyxFQUFQLENBQVVzQyxNQUFWLENBQWlCO0FBQ2hCaUMsUUFBTSxjQUFVTCxHQUFWLEVBQWVXLEtBQWYsRUFBdUI7QUFDNUIsT0FBSWxELENBQUo7QUFBQSxPQUFPZSxJQUFQO0FBQUEsT0FBYTZCLElBQWI7QUFBQSxPQUNDN0MsT0FBTyxLQUFLLENBQUwsQ0FEUjtBQUFBLE9BRUN1SyxRQUFRdkssUUFBUUEsS0FBS3lHLFVBRnRCOztBQUlBO0FBQ0E7O0FBRUE7QUFDQSxPQUFLakUsUUFBUWhCLFNBQWIsRUFBeUI7QUFDeEIsUUFBSyxLQUFLdEMsTUFBVixFQUFtQjtBQUNsQjJELFlBQU8xRSxPQUFPMEUsSUFBUCxDQUFhN0MsSUFBYixDQUFQOztBQUVBLFNBQUtBLEtBQUt5QyxRQUFMLEtBQWtCLENBQWxCLElBQXVCLENBQUN0RSxPQUFPOGUsS0FBUCxDQUFjamQsSUFBZCxFQUFvQixhQUFwQixDQUE3QixFQUFtRTtBQUNsRUMsVUFBSXNLLE1BQU1yTCxNQUFWO0FBQ0EsYUFBUWUsR0FBUixFQUFjO0FBQ2JlLGNBQU91SixNQUFNdEssQ0FBTixFQUFTZSxJQUFoQjs7QUFFQSxXQUFLQSxLQUFLckQsT0FBTCxDQUFhLE9BQWIsTUFBMEIsQ0FBL0IsRUFBbUM7QUFDbENxRCxlQUFPN0MsT0FBTzRFLFNBQVAsQ0FBa0IvQixLQUFLeEQsS0FBTCxDQUFXLENBQVgsQ0FBbEIsQ0FBUDs7QUFFQTRlLGlCQUFVcGMsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCNkIsS0FBTTdCLElBQU4sQ0FBdEI7QUFDQTtBQUNEO0FBQ0Q3QyxhQUFPOGUsS0FBUCxDQUFjamQsSUFBZCxFQUFvQixhQUFwQixFQUFtQyxJQUFuQztBQUNBO0FBQ0Q7O0FBRUQsV0FBTzZDLElBQVA7QUFDQTs7QUFFRDtBQUNBLE9BQUssUUFBT0wsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQXBCLEVBQStCO0FBQzlCLFdBQU8sS0FBSzVDLElBQUwsQ0FBVSxZQUFXO0FBQzNCekIsWUFBTzBFLElBQVAsQ0FBYSxJQUFiLEVBQW1CTCxHQUFuQjtBQUNBLEtBRk0sQ0FBUDtBQUdBOztBQUVELFVBQU9yQyxVQUFVakIsTUFBVixHQUFtQixDQUFuQjs7QUFFTjtBQUNBLFFBQUtVLElBQUwsQ0FBVSxZQUFXO0FBQ3BCekIsV0FBTzBFLElBQVAsQ0FBYSxJQUFiLEVBQW1CTCxHQUFuQixFQUF3QlcsS0FBeEI7QUFDQSxJQUZELENBSE07O0FBT047QUFDQTtBQUNBbkQsVUFBT29jLFNBQVVwYyxJQUFWLEVBQWdCd0MsR0FBaEIsRUFBcUJyRSxPQUFPMEUsSUFBUCxDQUFhN0MsSUFBYixFQUFtQndDLEdBQW5CLENBQXJCLENBQVAsR0FBeURoQixTQVQxRDtBQVVBLEdBakRlOztBQW1EaEJ3YixjQUFZLG9CQUFVeGEsR0FBVixFQUFnQjtBQUMzQixVQUFPLEtBQUs1QyxJQUFMLENBQVUsWUFBVztBQUMzQnpCLFdBQU82ZSxVQUFQLENBQW1CLElBQW5CLEVBQXlCeGEsR0FBekI7QUFDQSxJQUZNLENBQVA7QUFHQTtBQXZEZSxFQUFqQjs7QUEyREFyRSxRQUFPeUMsTUFBUCxDQUFjO0FBQ2J1YyxTQUFPLGVBQVVuZCxJQUFWLEVBQWdCa0MsSUFBaEIsRUFBc0JXLElBQXRCLEVBQTZCO0FBQ25DLE9BQUlzYSxLQUFKOztBQUVBLE9BQUtuZCxJQUFMLEVBQVk7QUFDWGtDLFdBQU8sQ0FBRUEsUUFBUSxJQUFWLElBQW1CLE9BQTFCO0FBQ0FpYixZQUFRaGYsT0FBTzhlLEtBQVAsQ0FBY2pkLElBQWQsRUFBb0JrQyxJQUFwQixDQUFSOztBQUVBO0FBQ0EsUUFBS1csSUFBTCxFQUFZO0FBQ1gsU0FBSyxDQUFDc2EsS0FBRCxJQUFVaGYsT0FBT29ELE9BQVAsQ0FBZXNCLElBQWYsQ0FBZixFQUFzQztBQUNyQ3NhLGNBQVFoZixPQUFPOGUsS0FBUCxDQUFjamQsSUFBZCxFQUFvQmtDLElBQXBCLEVBQTBCL0QsT0FBT21GLFNBQVAsQ0FBaUJULElBQWpCLENBQTFCLENBQVI7QUFDQSxNQUZELE1BRU87QUFDTnNhLFlBQU16ZixJQUFOLENBQVltRixJQUFaO0FBQ0E7QUFDRDtBQUNELFdBQU9zYSxTQUFTLEVBQWhCO0FBQ0E7QUFDRCxHQWxCWTs7QUFvQmJDLFdBQVMsaUJBQVVwZCxJQUFWLEVBQWdCa0MsSUFBaEIsRUFBdUI7QUFDL0JBLFVBQU9BLFFBQVEsSUFBZjs7QUFFQSxPQUFJaWIsUUFBUWhmLE9BQU9nZixLQUFQLENBQWNuZCxJQUFkLEVBQW9Ca0MsSUFBcEIsQ0FBWjtBQUFBLE9BQ0NtYixjQUFjRixNQUFNamUsTUFEckI7QUFBQSxPQUVDWixLQUFLNmUsTUFBTW5ULEtBQU4sRUFGTjtBQUFBLE9BR0NzVCxRQUFRbmYsT0FBT29mLFdBQVAsQ0FBb0J2ZCxJQUFwQixFQUEwQmtDLElBQTFCLENBSFQ7QUFBQSxPQUlDd1QsT0FBTyxTQUFQQSxJQUFPLEdBQVc7QUFDakJ2WCxXQUFPaWYsT0FBUCxDQUFnQnBkLElBQWhCLEVBQXNCa0MsSUFBdEI7QUFDQSxJQU5GOztBQVFBO0FBQ0EsT0FBSzVELE9BQU8sWUFBWixFQUEyQjtBQUMxQkEsU0FBSzZlLE1BQU1uVCxLQUFOLEVBQUw7QUFDQXFUO0FBQ0E7O0FBRUQsT0FBSy9lLEVBQUwsRUFBVTs7QUFFVDtBQUNBO0FBQ0EsUUFBSzRELFNBQVMsSUFBZCxFQUFxQjtBQUNwQmliLFdBQU0zUCxPQUFOLENBQWUsWUFBZjtBQUNBOztBQUVEO0FBQ0EsV0FBTzhQLE1BQU1FLElBQWI7QUFDQWxmLE9BQUdjLElBQUgsQ0FBU1ksSUFBVCxFQUFlMFYsSUFBZixFQUFxQjRILEtBQXJCO0FBQ0E7O0FBRUQsT0FBSyxDQUFDRCxXQUFELElBQWdCQyxLQUFyQixFQUE2QjtBQUM1QkEsVUFBTWpGLEtBQU4sQ0FBWUosSUFBWjtBQUNBO0FBQ0QsR0FyRFk7O0FBdURiO0FBQ0FzRixlQUFhLHFCQUFVdmQsSUFBVixFQUFnQmtDLElBQWhCLEVBQXVCO0FBQ25DLE9BQUlNLE1BQU1OLE9BQU8sWUFBakI7QUFDQSxVQUFPL0QsT0FBTzhlLEtBQVAsQ0FBY2pkLElBQWQsRUFBb0J3QyxHQUFwQixLQUE2QnJFLE9BQU84ZSxLQUFQLENBQWNqZCxJQUFkLEVBQW9Cd0MsR0FBcEIsRUFBeUI7QUFDNUQ2VixXQUFPbGEsT0FBT29aLFNBQVAsQ0FBaUIsYUFBakIsRUFBZ0NoQixHQUFoQyxDQUFvQyxZQUFXO0FBQ3JEcFksWUFBTytlLFdBQVAsQ0FBb0JsZCxJQUFwQixFQUEwQmtDLE9BQU8sT0FBakM7QUFDQS9ELFlBQU8rZSxXQUFQLENBQW9CbGQsSUFBcEIsRUFBMEJ3QyxHQUExQjtBQUNBLEtBSE07QUFEcUQsSUFBekIsQ0FBcEM7QUFNQTtBQWhFWSxFQUFkOztBQW1FQXJFLFFBQU9HLEVBQVAsQ0FBVXNDLE1BQVYsQ0FBaUI7QUFDaEJ1YyxTQUFPLGVBQVVqYixJQUFWLEVBQWdCVyxJQUFoQixFQUF1QjtBQUM3QixPQUFJNGEsU0FBUyxDQUFiOztBQUVBLE9BQUssT0FBT3ZiLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7QUFDL0JXLFdBQU9YLElBQVA7QUFDQUEsV0FBTyxJQUFQO0FBQ0F1YjtBQUNBOztBQUVELE9BQUt0ZCxVQUFVakIsTUFBVixHQUFtQnVlLE1BQXhCLEVBQWlDO0FBQ2hDLFdBQU90ZixPQUFPZ2YsS0FBUCxDQUFjLEtBQUssQ0FBTCxDQUFkLEVBQXVCamIsSUFBdkIsQ0FBUDtBQUNBOztBQUVELFVBQU9XLFNBQVNyQixTQUFULEdBQ04sSUFETSxHQUVOLEtBQUs1QixJQUFMLENBQVUsWUFBVztBQUNwQixRQUFJdWQsUUFBUWhmLE9BQU9nZixLQUFQLENBQWMsSUFBZCxFQUFvQmpiLElBQXBCLEVBQTBCVyxJQUExQixDQUFaOztBQUVBO0FBQ0ExRSxXQUFPb2YsV0FBUCxDQUFvQixJQUFwQixFQUEwQnJiLElBQTFCOztBQUVBLFFBQUtBLFNBQVMsSUFBVCxJQUFpQmliLE1BQU0sQ0FBTixNQUFhLFlBQW5DLEVBQWtEO0FBQ2pEaGYsWUFBT2lmLE9BQVAsQ0FBZ0IsSUFBaEIsRUFBc0JsYixJQUF0QjtBQUNBO0FBQ0QsSUFURCxDQUZEO0FBWUEsR0ExQmU7QUEyQmhCa2IsV0FBUyxpQkFBVWxiLElBQVYsRUFBaUI7QUFDekIsVUFBTyxLQUFLdEMsSUFBTCxDQUFVLFlBQVc7QUFDM0J6QixXQUFPaWYsT0FBUCxDQUFnQixJQUFoQixFQUFzQmxiLElBQXRCO0FBQ0EsSUFGTSxDQUFQO0FBR0EsR0EvQmU7QUFnQ2hCd2IsY0FBWSxvQkFBVXhiLElBQVYsRUFBaUI7QUFDNUIsVUFBTyxLQUFLaWIsS0FBTCxDQUFZamIsUUFBUSxJQUFwQixFQUEwQixFQUExQixDQUFQO0FBQ0EsR0FsQ2U7QUFtQ2hCO0FBQ0E7QUFDQTJXLFdBQVMsaUJBQVUzVyxJQUFWLEVBQWdCRCxHQUFoQixFQUFzQjtBQUM5QixPQUFJb0MsR0FBSjtBQUFBLE9BQ0NzWixRQUFRLENBRFQ7QUFBQSxPQUVDQyxRQUFRemYsT0FBT3NhLFFBQVAsRUFGVDtBQUFBLE9BR0MvSyxXQUFXLElBSFo7QUFBQSxPQUlDek4sSUFBSSxLQUFLZixNQUpWO0FBQUEsT0FLQ29hLFVBQVUsU0FBVkEsT0FBVSxHQUFXO0FBQ3BCLFFBQUssQ0FBRyxHQUFFcUUsS0FBVixFQUFvQjtBQUNuQkMsV0FBTXhELFdBQU4sQ0FBbUIxTSxRQUFuQixFQUE2QixDQUFFQSxRQUFGLENBQTdCO0FBQ0E7QUFDRCxJQVRGOztBQVdBLE9BQUssT0FBT3hMLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7QUFDL0JELFVBQU1DLElBQU47QUFDQUEsV0FBT1YsU0FBUDtBQUNBO0FBQ0RVLFVBQU9BLFFBQVEsSUFBZjs7QUFFQSxVQUFRakMsR0FBUixFQUFjO0FBQ2JvRSxVQUFNbEcsT0FBTzhlLEtBQVAsQ0FBY3ZQLFNBQVV6TixDQUFWLENBQWQsRUFBNkJpQyxPQUFPLFlBQXBDLENBQU47QUFDQSxRQUFLbUMsT0FBT0EsSUFBSWdVLEtBQWhCLEVBQXdCO0FBQ3ZCc0Y7QUFDQXRaLFNBQUlnVSxLQUFKLENBQVU5QixHQUFWLENBQWUrQyxPQUFmO0FBQ0E7QUFDRDtBQUNEQTtBQUNBLFVBQU9zRSxNQUFNL0UsT0FBTixDQUFlNVcsR0FBZixDQUFQO0FBQ0E7QUFoRWUsRUFBakI7QUFrRUEsS0FBSTRiLE9BQVEscUNBQUQsQ0FBd0NDLE1BQW5EOztBQUVBLEtBQUlDLFlBQVksQ0FBRSxLQUFGLEVBQVMsT0FBVCxFQUFrQixRQUFsQixFQUE0QixNQUE1QixDQUFoQjs7QUFFQSxLQUFJQyxXQUFXLFNBQVhBLFFBQVcsQ0FBVWhlLElBQVYsRUFBZ0JpZSxFQUFoQixFQUFxQjtBQUNsQztBQUNBO0FBQ0FqZSxTQUFPaWUsTUFBTWplLElBQWI7QUFDQSxTQUFPN0IsT0FBTytmLEdBQVAsQ0FBWWxlLElBQVosRUFBa0IsU0FBbEIsTUFBa0MsTUFBbEMsSUFBNEMsQ0FBQzdCLE9BQU9tSCxRQUFQLENBQWlCdEYsS0FBSzBJLGFBQXRCLEVBQXFDMUksSUFBckMsQ0FBcEQ7QUFDQSxFQUxGOztBQVNBO0FBQ0E7QUFDQSxLQUFJbWUsU0FBU2hnQixPQUFPZ2dCLE1BQVAsR0FBZ0IsVUFBVTNlLEtBQVYsRUFBaUJsQixFQUFqQixFQUFxQmtFLEdBQXJCLEVBQTBCVyxLQUExQixFQUFpQ2liLFNBQWpDLEVBQTRDQyxRQUE1QyxFQUFzREMsR0FBdEQsRUFBNEQ7QUFDeEYsTUFBSXJlLElBQUksQ0FBUjtBQUFBLE1BQ0NmLFNBQVNNLE1BQU1OLE1BRGhCO0FBQUEsTUFFQ3FmLE9BQU8vYixPQUFPLElBRmY7O0FBSUE7QUFDQSxNQUFLckUsT0FBTytELElBQVAsQ0FBYU0sR0FBYixNQUF1QixRQUE1QixFQUF1QztBQUN0QzRiLGVBQVksSUFBWjtBQUNBLFFBQU1uZSxDQUFOLElBQVd1QyxHQUFYLEVBQWlCO0FBQ2hCckUsV0FBT2dnQixNQUFQLENBQWUzZSxLQUFmLEVBQXNCbEIsRUFBdEIsRUFBMEIyQixDQUExQixFQUE2QnVDLElBQUl2QyxDQUFKLENBQTdCLEVBQXFDLElBQXJDLEVBQTJDb2UsUUFBM0MsRUFBcURDLEdBQXJEO0FBQ0E7O0FBRUY7QUFDQyxHQVBELE1BT08sSUFBS25iLFVBQVUzQixTQUFmLEVBQTJCO0FBQ2pDNGMsZUFBWSxJQUFaOztBQUVBLE9BQUssQ0FBQ2pnQixPQUFPa0QsVUFBUCxDQUFtQjhCLEtBQW5CLENBQU4sRUFBbUM7QUFDbENtYixVQUFNLElBQU47QUFDQTs7QUFFRCxPQUFLQyxJQUFMLEVBQVk7QUFDWDtBQUNBLFFBQUtELEdBQUwsRUFBVztBQUNWaGdCLFFBQUdjLElBQUgsQ0FBU0ksS0FBVCxFQUFnQjJELEtBQWhCO0FBQ0E3RSxVQUFLLElBQUw7O0FBRUQ7QUFDQyxLQUxELE1BS087QUFDTmlnQixZQUFPamdCLEVBQVA7QUFDQUEsVUFBSyxZQUFVMEIsSUFBVixFQUFnQndDLEdBQWhCLEVBQXFCVyxLQUFyQixFQUE2QjtBQUNqQyxhQUFPb2IsS0FBS25mLElBQUwsQ0FBV2pCLE9BQVE2QixJQUFSLENBQVgsRUFBMkJtRCxLQUEzQixDQUFQO0FBQ0EsTUFGRDtBQUdBO0FBQ0Q7O0FBRUQsT0FBSzdFLEVBQUwsRUFBVTtBQUNULFdBQVEyQixJQUFJZixNQUFaLEVBQW9CZSxHQUFwQixFQUEwQjtBQUN6QjNCLFFBQUlrQixNQUFNUyxDQUFOLENBQUosRUFBY3VDLEdBQWQsRUFBbUI4YixNQUFNbmIsS0FBTixHQUFjQSxNQUFNL0QsSUFBTixDQUFZSSxNQUFNUyxDQUFOLENBQVosRUFBc0JBLENBQXRCLEVBQXlCM0IsR0FBSWtCLE1BQU1TLENBQU4sQ0FBSixFQUFjdUMsR0FBZCxDQUF6QixDQUFqQztBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxTQUFPNGIsWUFDTjVlLEtBRE07O0FBR047QUFDQStlLFNBQ0NqZ0IsR0FBR2MsSUFBSCxDQUFTSSxLQUFULENBREQsR0FFQ04sU0FBU1osR0FBSWtCLE1BQU0sQ0FBTixDQUFKLEVBQWNnRCxHQUFkLENBQVQsR0FBK0I2YixRQU5qQztBQU9BLEVBakREO0FBa0RBLEtBQUlHLGlCQUFrQix1QkFBdEI7O0FBSUEsRUFBQyxZQUFXO0FBQ1gsTUFBSUMsV0FBV3ZoQixTQUFTd2hCLHNCQUFULEVBQWY7QUFBQSxNQUNDdlUsTUFBTWpOLFNBQVNrTixhQUFULENBQXVCLEtBQXZCLENBRFA7QUFBQSxNQUVDcUMsUUFBUXZQLFNBQVNrTixhQUFULENBQXVCLE9BQXZCLENBRlQ7O0FBSUE7QUFDQUQsTUFBSWQsWUFBSixDQUFrQixXQUFsQixFQUErQixHQUEvQjtBQUNBYyxNQUFJNkIsU0FBSixHQUFnQiw0Q0FBaEI7O0FBRUE7QUFDQS9OLFVBQVEwZ0IsaUJBQVIsR0FBNEJ4VSxJQUFJOEIsVUFBSixDQUFleEosUUFBZixLQUE0QixDQUF4RDs7QUFFQTtBQUNBO0FBQ0F4RSxVQUFRMmdCLEtBQVIsR0FBZ0IsQ0FBQ3pVLElBQUlwQixvQkFBSixDQUEwQixPQUExQixFQUFvQzdKLE1BQXJEOztBQUVBO0FBQ0E7QUFDQWpCLFVBQVE0Z0IsYUFBUixHQUF3QixDQUFDLENBQUMxVSxJQUFJcEIsb0JBQUosQ0FBMEIsTUFBMUIsRUFBbUM3SixNQUE3RDs7QUFFQTtBQUNBO0FBQ0FqQixVQUFRNmdCLFVBQVIsR0FDQzVoQixTQUFTa04sYUFBVCxDQUF3QixLQUF4QixFQUFnQzJVLFNBQWhDLENBQTJDLElBQTNDLEVBQWtEQyxTQUFsRCxLQUFnRSxlQURqRTs7QUFHQTtBQUNBO0FBQ0F2UyxRQUFNdkssSUFBTixHQUFhLFVBQWI7QUFDQXVLLFFBQU1pRSxPQUFOLEdBQWdCLElBQWhCO0FBQ0ErTixXQUFTM1MsV0FBVCxDQUFzQlcsS0FBdEI7QUFDQXhPLFVBQVFnaEIsYUFBUixHQUF3QnhTLE1BQU1pRSxPQUE5Qjs7QUFFQTtBQUNBO0FBQ0F2RyxNQUFJNkIsU0FBSixHQUFnQix3QkFBaEI7QUFDQS9OLFVBQVFpaEIsY0FBUixHQUF5QixDQUFDLENBQUMvVSxJQUFJNFUsU0FBSixDQUFlLElBQWYsRUFBc0J0UCxTQUF0QixDQUFnQzZFLFlBQTNEOztBQUVBO0FBQ0FtSyxXQUFTM1MsV0FBVCxDQUFzQjNCLEdBQXRCO0FBQ0FBLE1BQUk2QixTQUFKLEdBQWdCLGtEQUFoQjs7QUFFQTtBQUNBO0FBQ0EvTixVQUFRa2hCLFVBQVIsR0FBcUJoVixJQUFJNFUsU0FBSixDQUFlLElBQWYsRUFBc0JBLFNBQXRCLENBQWlDLElBQWpDLEVBQXdDdFAsU0FBeEMsQ0FBa0RpQixPQUF2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQXpTLFVBQVFtaEIsWUFBUixHQUF1QixJQUF2QjtBQUNBLE1BQUtqVixJQUFJeUIsV0FBVCxFQUF1QjtBQUN0QnpCLE9BQUl5QixXQUFKLENBQWlCLFNBQWpCLEVBQTRCLFlBQVc7QUFDdEMzTixZQUFRbWhCLFlBQVIsR0FBdUIsS0FBdkI7QUFDQSxJQUZEOztBQUlBalYsT0FBSTRVLFNBQUosQ0FBZSxJQUFmLEVBQXNCTSxLQUF0QjtBQUNBOztBQUVEO0FBQ0EsTUFBSXBoQixRQUFROGQsYUFBUixJQUF5QixJQUE3QixFQUFtQztBQUNsQztBQUNBOWQsV0FBUThkLGFBQVIsR0FBd0IsSUFBeEI7QUFDQSxPQUFJO0FBQ0gsV0FBTzVSLElBQUlqQixJQUFYO0FBQ0EsSUFGRCxDQUVFLE9BQU94RyxDQUFQLEVBQVc7QUFDWnpFLFlBQVE4ZCxhQUFSLEdBQXdCLEtBQXhCO0FBQ0E7QUFDRDs7QUFFRDtBQUNBMEMsYUFBV3RVLE1BQU1zQyxRQUFRLElBQXpCO0FBQ0EsRUF0RUQ7O0FBeUVBLEVBQUMsWUFBVztBQUNYLE1BQUl4TSxDQUFKO0FBQUEsTUFBT3FmLFNBQVA7QUFBQSxNQUNDblYsTUFBTWpOLFNBQVNrTixhQUFULENBQXdCLEtBQXhCLENBRFA7O0FBR0E7QUFDQSxPQUFNbkssQ0FBTixJQUFXLEVBQUVpUixRQUFRLElBQVYsRUFBZ0JxTyxRQUFRLElBQXhCLEVBQThCQyxTQUFTLElBQXZDLEVBQVgsRUFBMEQ7QUFDekRGLGVBQVksT0FBT3JmLENBQW5COztBQUVBLE9BQUssRUFBRWhDLFFBQVNnQyxJQUFJLFNBQWIsSUFBMkJxZixhQUFhamlCLE1BQTFDLENBQUwsRUFBeUQ7QUFDeEQ7QUFDQThNLFFBQUlkLFlBQUosQ0FBa0JpVyxTQUFsQixFQUE2QixHQUE3QjtBQUNBcmhCLFlBQVNnQyxJQUFJLFNBQWIsSUFBMkJrSyxJQUFJMUQsVUFBSixDQUFnQjZZLFNBQWhCLEVBQTRCN2QsT0FBNUIsS0FBd0MsS0FBbkU7QUFDQTtBQUNEOztBQUVEO0FBQ0EwSSxRQUFNLElBQU47QUFDQSxFQWpCRDs7QUFvQkEsS0FBSXNWLGFBQWEsOEJBQWpCO0FBQUEsS0FDQ0MsWUFBWSxNQURiO0FBQUEsS0FFQ0MsY0FBYyw4QkFGZjtBQUFBLEtBR0NDLGNBQWMsaUNBSGY7QUFBQSxLQUlDQyxpQkFBaUIsc0JBSmxCOztBQU1BLFVBQVNDLFVBQVQsR0FBc0I7QUFDckIsU0FBTyxJQUFQO0FBQ0E7O0FBRUQsVUFBU0MsV0FBVCxHQUF1QjtBQUN0QixTQUFPLEtBQVA7QUFDQTs7QUFFRCxVQUFTQyxpQkFBVCxHQUE2QjtBQUM1QixNQUFJO0FBQ0gsVUFBTzlpQixTQUFTbVQsYUFBaEI7QUFDQSxHQUZELENBRUUsT0FBUTRQLEdBQVIsRUFBYyxDQUFHO0FBQ25COztBQUVEOzs7O0FBSUE5aEIsUUFBT2lkLEtBQVAsR0FBZTs7QUFFZHRlLFVBQVEsRUFGTTs7QUFJZHlaLE9BQUssYUFBVXZXLElBQVYsRUFBZ0JrZ0IsS0FBaEIsRUFBdUIxVixPQUF2QixFQUFnQzNILElBQWhDLEVBQXNDekUsUUFBdEMsRUFBaUQ7QUFDckQsT0FBSWlHLEdBQUo7QUFBQSxPQUFTOGIsTUFBVDtBQUFBLE9BQWlCQyxDQUFqQjtBQUFBLE9BQW9CQyxXQUFwQjtBQUFBLE9BQ0NDLE9BREQ7QUFBQSxPQUNVQyxXQURWO0FBQUEsT0FDdUJDLFNBRHZCO0FBQUEsT0FFQ0MsUUFGRDtBQUFBLE9BRVd2ZSxJQUZYO0FBQUEsT0FFaUJ3ZSxVQUZqQjtBQUFBLE9BRTZCQyxRQUY3QjtBQUFBLE9BR0NDLFdBQVd6aUIsT0FBTzhlLEtBQVAsQ0FBY2pkLElBQWQsQ0FIWjs7QUFLQTtBQUNBLE9BQUssQ0FBQzRnQixRQUFOLEVBQWlCO0FBQ2hCO0FBQ0E7O0FBRUQ7QUFDQSxPQUFLcFcsUUFBUUEsT0FBYixFQUF1QjtBQUN0QjZWLGtCQUFjN1YsT0FBZDtBQUNBQSxjQUFVNlYsWUFBWTdWLE9BQXRCO0FBQ0FwTSxlQUFXaWlCLFlBQVlqaUIsUUFBdkI7QUFDQTs7QUFFRDtBQUNBLE9BQUssQ0FBQ29NLFFBQVFyRyxJQUFkLEVBQXFCO0FBQ3BCcUcsWUFBUXJHLElBQVIsR0FBZWhHLE9BQU9nRyxJQUFQLEVBQWY7QUFDQTs7QUFFRDtBQUNBLE9BQUssRUFBRWdjLFNBQVNTLFNBQVNULE1BQXBCLENBQUwsRUFBbUM7QUFDbENBLGFBQVNTLFNBQVNULE1BQVQsR0FBa0IsRUFBM0I7QUFDQTtBQUNELE9BQUssRUFBRUksY0FBY0ssU0FBU0MsTUFBekIsQ0FBTCxFQUF3QztBQUN2Q04sa0JBQWNLLFNBQVNDLE1BQVQsR0FBa0IsVUFBVW5lLENBQVYsRUFBYztBQUM3QztBQUNBO0FBQ0EsWUFBTyxRQUFPdkUsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQjhILFlBQWxCLEtBQW1DLENBQUN2RCxDQUFELElBQU12RSxPQUFPaWQsS0FBUCxDQUFhMEYsU0FBYixLQUEyQnBlLEVBQUVSLElBQXRFLElBQ04vRCxPQUFPaWQsS0FBUCxDQUFhMkYsUUFBYixDQUFzQjdnQixLQUF0QixDQUE2QnFnQixZQUFZdmdCLElBQXpDLEVBQStDRyxTQUEvQyxDQURNLEdBRU5xQixTQUZEO0FBR0EsS0FORDtBQU9BO0FBQ0ErZSxnQkFBWXZnQixJQUFaLEdBQW1CQSxJQUFuQjtBQUNBOztBQUVEO0FBQ0FrZ0IsV0FBUSxDQUFFQSxTQUFTLEVBQVgsRUFBZ0IvWCxLQUFoQixDQUF1QitPLFNBQXZCLEtBQXNDLENBQUUsRUFBRixDQUE5QztBQUNBa0osT0FBSUYsTUFBTWhoQixNQUFWO0FBQ0EsVUFBUWtoQixHQUFSLEVBQWM7QUFDYi9iLFVBQU13YixlQUFlbFgsSUFBZixDQUFxQnVYLE1BQU1FLENBQU4sQ0FBckIsS0FBbUMsRUFBekM7QUFDQWxlLFdBQU95ZSxXQUFXdGMsSUFBSSxDQUFKLENBQWxCO0FBQ0FxYyxpQkFBYSxDQUFFcmMsSUFBSSxDQUFKLEtBQVUsRUFBWixFQUFpQkcsS0FBakIsQ0FBd0IsR0FBeEIsRUFBOEI5RCxJQUE5QixFQUFiOztBQUVBO0FBQ0EsUUFBSyxDQUFDd0IsSUFBTixFQUFhO0FBQ1o7QUFDQTs7QUFFRDtBQUNBb2UsY0FBVW5pQixPQUFPaWQsS0FBUCxDQUFha0YsT0FBYixDQUFzQnBlLElBQXRCLEtBQWdDLEVBQTFDOztBQUVBO0FBQ0FBLFdBQU8sQ0FBRTlELFdBQVdraUIsUUFBUVUsWUFBbkIsR0FBa0NWLFFBQVFXLFFBQTVDLEtBQTBEL2UsSUFBakU7O0FBRUE7QUFDQW9lLGNBQVVuaUIsT0FBT2lkLEtBQVAsQ0FBYWtGLE9BQWIsQ0FBc0JwZSxJQUF0QixLQUFnQyxFQUExQzs7QUFFQTtBQUNBc2UsZ0JBQVlyaUIsT0FBT3lDLE1BQVAsQ0FBYztBQUN6QnNCLFdBQU1BLElBRG1CO0FBRXpCeWUsZUFBVUEsUUFGZTtBQUd6QjlkLFdBQU1BLElBSG1CO0FBSXpCMkgsY0FBU0EsT0FKZ0I7QUFLekJyRyxXQUFNcUcsUUFBUXJHLElBTFc7QUFNekIvRixlQUFVQSxRQU5lO0FBT3pCc1csbUJBQWN0VyxZQUFZRCxPQUFPc1AsSUFBUCxDQUFZdEYsS0FBWixDQUFrQnVNLFlBQWxCLENBQStCeEwsSUFBL0IsQ0FBcUM5SyxRQUFyQyxDQVBEO0FBUXpCOGlCLGdCQUFXUixXQUFXbFgsSUFBWCxDQUFnQixHQUFoQjtBQVJjLEtBQWQsRUFTVDZXLFdBVFMsQ0FBWjs7QUFXQTtBQUNBLFFBQUssRUFBRUksV0FBV04sT0FBUWplLElBQVIsQ0FBYixDQUFMLEVBQW9DO0FBQ25DdWUsZ0JBQVdOLE9BQVFqZSxJQUFSLElBQWlCLEVBQTVCO0FBQ0F1ZSxjQUFTVSxhQUFULEdBQXlCLENBQXpCOztBQUVBO0FBQ0EsU0FBSyxDQUFDYixRQUFRYyxLQUFULElBQWtCZCxRQUFRYyxLQUFSLENBQWNoaUIsSUFBZCxDQUFvQlksSUFBcEIsRUFBMEI2QyxJQUExQixFQUFnQzZkLFVBQWhDLEVBQTRDSCxXQUE1QyxNQUE4RCxLQUFyRixFQUE2RjtBQUM1RjtBQUNBLFVBQUt2Z0IsS0FBSzJMLGdCQUFWLEVBQTZCO0FBQzVCM0wsWUFBSzJMLGdCQUFMLENBQXVCekosSUFBdkIsRUFBNkJxZSxXQUE3QixFQUEwQyxLQUExQztBQUVBLE9BSEQsTUFHTyxJQUFLdmdCLEtBQUs0TCxXQUFWLEVBQXdCO0FBQzlCNUwsWUFBSzRMLFdBQUwsQ0FBa0IsT0FBTzFKLElBQXpCLEVBQStCcWUsV0FBL0I7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsUUFBS0QsUUFBUS9KLEdBQWIsRUFBbUI7QUFDbEIrSixhQUFRL0osR0FBUixDQUFZblgsSUFBWixDQUFrQlksSUFBbEIsRUFBd0J3Z0IsU0FBeEI7O0FBRUEsU0FBSyxDQUFDQSxVQUFVaFcsT0FBVixDQUFrQnJHLElBQXhCLEVBQStCO0FBQzlCcWMsZ0JBQVVoVyxPQUFWLENBQWtCckcsSUFBbEIsR0FBeUJxRyxRQUFRckcsSUFBakM7QUFDQTtBQUNEOztBQUVEO0FBQ0EsUUFBSy9GLFFBQUwsRUFBZ0I7QUFDZnFpQixjQUFTOWYsTUFBVCxDQUFpQjhmLFNBQVNVLGFBQVQsRUFBakIsRUFBMkMsQ0FBM0MsRUFBOENYLFNBQTlDO0FBQ0EsS0FGRCxNQUVPO0FBQ05DLGNBQVMvaUIsSUFBVCxDQUFlOGlCLFNBQWY7QUFDQTs7QUFFRDtBQUNBcmlCLFdBQU9pZCxLQUFQLENBQWF0ZSxNQUFiLENBQXFCb0YsSUFBckIsSUFBOEIsSUFBOUI7QUFDQTs7QUFFRDtBQUNBbEMsVUFBTyxJQUFQO0FBQ0EsR0FuSGE7O0FBcUhkO0FBQ0FvWSxVQUFRLGdCQUFVcFksSUFBVixFQUFnQmtnQixLQUFoQixFQUF1QjFWLE9BQXZCLEVBQWdDcE0sUUFBaEMsRUFBMENpakIsV0FBMUMsRUFBd0Q7QUFDL0QsT0FBSTdnQixDQUFKO0FBQUEsT0FBT2dnQixTQUFQO0FBQUEsT0FBa0JuYyxHQUFsQjtBQUFBLE9BQ0NpZCxTQUREO0FBQUEsT0FDWWxCLENBRFo7QUFBQSxPQUNlRCxNQURmO0FBQUEsT0FFQ0csT0FGRDtBQUFBLE9BRVVHLFFBRlY7QUFBQSxPQUVvQnZlLElBRnBCO0FBQUEsT0FHQ3dlLFVBSEQ7QUFBQSxPQUdhQyxRQUhiO0FBQUEsT0FJQ0MsV0FBV3ppQixPQUFPNGUsT0FBUCxDQUFnQi9jLElBQWhCLEtBQTBCN0IsT0FBTzhlLEtBQVAsQ0FBY2pkLElBQWQsQ0FKdEM7O0FBTUEsT0FBSyxDQUFDNGdCLFFBQUQsSUFBYSxFQUFFVCxTQUFTUyxTQUFTVCxNQUFwQixDQUFsQixFQUFnRDtBQUMvQztBQUNBOztBQUVEO0FBQ0FELFdBQVEsQ0FBRUEsU0FBUyxFQUFYLEVBQWdCL1gsS0FBaEIsQ0FBdUIrTyxTQUF2QixLQUFzQyxDQUFFLEVBQUYsQ0FBOUM7QUFDQWtKLE9BQUlGLE1BQU1oaEIsTUFBVjtBQUNBLFVBQVFraEIsR0FBUixFQUFjO0FBQ2IvYixVQUFNd2IsZUFBZWxYLElBQWYsQ0FBcUJ1WCxNQUFNRSxDQUFOLENBQXJCLEtBQW1DLEVBQXpDO0FBQ0FsZSxXQUFPeWUsV0FBV3RjLElBQUksQ0FBSixDQUFsQjtBQUNBcWMsaUJBQWEsQ0FBRXJjLElBQUksQ0FBSixLQUFVLEVBQVosRUFBaUJHLEtBQWpCLENBQXdCLEdBQXhCLEVBQThCOUQsSUFBOUIsRUFBYjs7QUFFQTtBQUNBLFFBQUssQ0FBQ3dCLElBQU4sRUFBYTtBQUNaLFVBQU1BLElBQU4sSUFBY2llLE1BQWQsRUFBdUI7QUFDdEJoaUIsYUFBT2lkLEtBQVAsQ0FBYWhELE1BQWIsQ0FBcUJwWSxJQUFyQixFQUEyQmtDLE9BQU9nZSxNQUFPRSxDQUFQLENBQWxDLEVBQThDNVYsT0FBOUMsRUFBdURwTSxRQUF2RCxFQUFpRSxJQUFqRTtBQUNBO0FBQ0Q7QUFDQTs7QUFFRGtpQixjQUFVbmlCLE9BQU9pZCxLQUFQLENBQWFrRixPQUFiLENBQXNCcGUsSUFBdEIsS0FBZ0MsRUFBMUM7QUFDQUEsV0FBTyxDQUFFOUQsV0FBV2tpQixRQUFRVSxZQUFuQixHQUFrQ1YsUUFBUVcsUUFBNUMsS0FBMEQvZSxJQUFqRTtBQUNBdWUsZUFBV04sT0FBUWplLElBQVIsS0FBa0IsRUFBN0I7QUFDQW1DLFVBQU1BLElBQUksQ0FBSixLQUFVLElBQUlzQyxNQUFKLENBQVksWUFBWStaLFdBQVdsWCxJQUFYLENBQWdCLGVBQWhCLENBQVosR0FBK0MsU0FBM0QsQ0FBaEI7O0FBRUE7QUFDQThYLGdCQUFZOWdCLElBQUlpZ0IsU0FBU3ZoQixNQUF6QjtBQUNBLFdBQVFzQixHQUFSLEVBQWM7QUFDYmdnQixpQkFBWUMsU0FBVWpnQixDQUFWLENBQVo7O0FBRUEsU0FBSyxDQUFFNmdCLGVBQWVWLGFBQWFILFVBQVVHLFFBQXhDLE1BQ0YsQ0FBQ25XLE9BQUQsSUFBWUEsUUFBUXJHLElBQVIsS0FBaUJxYyxVQUFVcmMsSUFEckMsTUFFRixDQUFDRSxHQUFELElBQVFBLElBQUk2RSxJQUFKLENBQVVzWCxVQUFVVSxTQUFwQixDQUZOLE1BR0YsQ0FBQzlpQixRQUFELElBQWFBLGFBQWFvaUIsVUFBVXBpQixRQUFwQyxJQUFnREEsYUFBYSxJQUFiLElBQXFCb2lCLFVBQVVwaUIsUUFIN0UsQ0FBTCxFQUcrRjtBQUM5RnFpQixlQUFTOWYsTUFBVCxDQUFpQkgsQ0FBakIsRUFBb0IsQ0FBcEI7O0FBRUEsVUFBS2dnQixVQUFVcGlCLFFBQWYsRUFBMEI7QUFDekJxaUIsZ0JBQVNVLGFBQVQ7QUFDQTtBQUNELFVBQUtiLFFBQVFsSSxNQUFiLEVBQXNCO0FBQ3JCa0ksZUFBUWxJLE1BQVIsQ0FBZWhaLElBQWYsQ0FBcUJZLElBQXJCLEVBQTJCd2dCLFNBQTNCO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxRQUFLYyxhQUFhLENBQUNiLFNBQVN2aEIsTUFBNUIsRUFBcUM7QUFDcEMsU0FBSyxDQUFDb2hCLFFBQVFpQixRQUFULElBQXFCakIsUUFBUWlCLFFBQVIsQ0FBaUJuaUIsSUFBakIsQ0FBdUJZLElBQXZCLEVBQTZCMGdCLFVBQTdCLEVBQXlDRSxTQUFTQyxNQUFsRCxNQUErRCxLQUF6RixFQUFpRztBQUNoRzFpQixhQUFPcWpCLFdBQVAsQ0FBb0J4aEIsSUFBcEIsRUFBMEJrQyxJQUExQixFQUFnQzBlLFNBQVNDLE1BQXpDO0FBQ0E7O0FBRUQsWUFBT1YsT0FBUWplLElBQVIsQ0FBUDtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxPQUFLL0QsT0FBT29FLGFBQVAsQ0FBc0I0ZCxNQUF0QixDQUFMLEVBQXNDO0FBQ3JDLFdBQU9TLFNBQVNDLE1BQWhCOztBQUVBO0FBQ0E7QUFDQTFpQixXQUFPK2UsV0FBUCxDQUFvQmxkLElBQXBCLEVBQTBCLFFBQTFCO0FBQ0E7QUFDRCxHQTdMYTs7QUErTGQ4YSxXQUFTLGlCQUFVTSxLQUFWLEVBQWlCdlksSUFBakIsRUFBdUI3QyxJQUF2QixFQUE2QnloQixZQUE3QixFQUE0QztBQUNwRCxPQUFJWixNQUFKO0FBQUEsT0FBWWEsTUFBWjtBQUFBLE9BQW9CL1csR0FBcEI7QUFBQSxPQUNDZ1gsVUFERDtBQUFBLE9BQ2FyQixPQURiO0FBQUEsT0FDc0JqYyxHQUR0QjtBQUFBLE9BQzJCcEUsQ0FEM0I7QUFBQSxPQUVDMmhCLFlBQVksQ0FBRTVoQixRQUFROUMsUUFBVixDQUZiO0FBQUEsT0FHQ2dGLE9BQU9wRSxPQUFPc0IsSUFBUCxDQUFhZ2MsS0FBYixFQUFvQixNQUFwQixJQUErQkEsTUFBTWxaLElBQXJDLEdBQTRDa1osS0FIcEQ7QUFBQSxPQUlDc0YsYUFBYTVpQixPQUFPc0IsSUFBUCxDQUFhZ2MsS0FBYixFQUFvQixXQUFwQixJQUFvQ0EsTUFBTThGLFNBQU4sQ0FBZ0IxYyxLQUFoQixDQUFzQixHQUF0QixDQUFwQyxHQUFpRSxFQUovRTs7QUFNQW1HLFNBQU10RyxNQUFNckUsT0FBT0EsUUFBUTlDLFFBQTNCOztBQUVBO0FBQ0EsT0FBSzhDLEtBQUt5QyxRQUFMLEtBQWtCLENBQWxCLElBQXVCekMsS0FBS3lDLFFBQUwsS0FBa0IsQ0FBOUMsRUFBa0Q7QUFDakQ7QUFDQTs7QUFFRDtBQUNBLE9BQUttZCxZQUFZMVcsSUFBWixDQUFrQmhILE9BQU8vRCxPQUFPaWQsS0FBUCxDQUFhMEYsU0FBdEMsQ0FBTCxFQUF5RDtBQUN4RDtBQUNBOztBQUVELE9BQUs1ZSxLQUFLdkUsT0FBTCxDQUFhLEdBQWIsS0FBcUIsQ0FBMUIsRUFBOEI7QUFDN0I7QUFDQStpQixpQkFBYXhlLEtBQUtzQyxLQUFMLENBQVcsR0FBWCxDQUFiO0FBQ0F0QyxXQUFPd2UsV0FBVzFXLEtBQVgsRUFBUDtBQUNBMFcsZUFBV2hnQixJQUFYO0FBQ0E7QUFDRGdoQixZQUFTeGYsS0FBS3ZFLE9BQUwsQ0FBYSxHQUFiLElBQW9CLENBQXBCLElBQXlCLE9BQU91RSxJQUF6Qzs7QUFFQTtBQUNBa1osV0FBUUEsTUFBT2pkLE9BQU9zRCxPQUFkLElBQ1AyWixLQURPLEdBRVAsSUFBSWpkLE9BQU8wakIsS0FBWCxDQUFrQjNmLElBQWxCLEVBQXdCLFFBQU9rWixLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQWpCLElBQTZCQSxLQUFyRCxDQUZEOztBQUlBO0FBQ0FBLFNBQU0wRyxTQUFOLEdBQWtCTCxlQUFlLENBQWYsR0FBbUIsQ0FBckM7QUFDQXJHLFNBQU04RixTQUFOLEdBQWtCUixXQUFXbFgsSUFBWCxDQUFnQixHQUFoQixDQUFsQjtBQUNBNFIsU0FBTTJHLFlBQU4sR0FBcUIzRyxNQUFNOEYsU0FBTixHQUNwQixJQUFJdmEsTUFBSixDQUFZLFlBQVkrWixXQUFXbFgsSUFBWCxDQUFnQixlQUFoQixDQUFaLEdBQStDLFNBQTNELENBRG9CLEdBRXBCLElBRkQ7O0FBSUE7QUFDQTRSLFNBQU1yTSxNQUFOLEdBQWV2TixTQUFmO0FBQ0EsT0FBSyxDQUFDNFosTUFBTWphLE1BQVosRUFBcUI7QUFDcEJpYSxVQUFNamEsTUFBTixHQUFlbkIsSUFBZjtBQUNBOztBQUVEO0FBQ0E2QyxVQUFPQSxRQUFRLElBQVIsR0FDTixDQUFFdVksS0FBRixDQURNLEdBRU5qZCxPQUFPbUYsU0FBUCxDQUFrQlQsSUFBbEIsRUFBd0IsQ0FBRXVZLEtBQUYsQ0FBeEIsQ0FGRDs7QUFJQTtBQUNBa0YsYUFBVW5pQixPQUFPaWQsS0FBUCxDQUFha0YsT0FBYixDQUFzQnBlLElBQXRCLEtBQWdDLEVBQTFDO0FBQ0EsT0FBSyxDQUFDdWYsWUFBRCxJQUFpQm5CLFFBQVF4RixPQUF6QixJQUFvQ3dGLFFBQVF4RixPQUFSLENBQWdCNWEsS0FBaEIsQ0FBdUJGLElBQXZCLEVBQTZCNkMsSUFBN0IsTUFBd0MsS0FBakYsRUFBeUY7QUFDeEY7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsT0FBSyxDQUFDNGUsWUFBRCxJQUFpQixDQUFDbkIsUUFBUTBCLFFBQTFCLElBQXNDLENBQUM3akIsT0FBT2lFLFFBQVAsQ0FBaUJwQyxJQUFqQixDQUE1QyxFQUFzRTs7QUFFckUyaEIsaUJBQWFyQixRQUFRVSxZQUFSLElBQXdCOWUsSUFBckM7QUFDQSxRQUFLLENBQUMwZCxZQUFZMVcsSUFBWixDQUFrQnlZLGFBQWF6ZixJQUEvQixDQUFOLEVBQThDO0FBQzdDeUksV0FBTUEsSUFBSTlCLFVBQVY7QUFDQTtBQUNELFdBQVE4QixHQUFSLEVBQWFBLE1BQU1BLElBQUk5QixVQUF2QixFQUFvQztBQUNuQytZLGVBQVVsa0IsSUFBVixDQUFnQmlOLEdBQWhCO0FBQ0F0RyxXQUFNc0csR0FBTjtBQUNBOztBQUVEO0FBQ0EsUUFBS3RHLFNBQVNyRSxLQUFLMEksYUFBTCxJQUFzQnhMLFFBQS9CLENBQUwsRUFBZ0Q7QUFDL0Mwa0IsZUFBVWxrQixJQUFWLENBQWdCMkcsSUFBSW9ILFdBQUosSUFBbUJwSCxJQUFJNGQsWUFBdkIsSUFBdUM1a0IsTUFBdkQ7QUFDQTtBQUNEOztBQUVEO0FBQ0E0QyxPQUFJLENBQUo7QUFDQSxVQUFRLENBQUMwSyxNQUFNaVgsVUFBVTNoQixHQUFWLENBQVAsS0FBMEIsQ0FBQ21iLE1BQU04RyxvQkFBTixFQUFuQyxFQUFrRTs7QUFFakU5RyxVQUFNbFosSUFBTixHQUFhakMsSUFBSSxDQUFKLEdBQ1owaEIsVUFEWSxHQUVackIsUUFBUVcsUUFBUixJQUFvQi9lLElBRnJCOztBQUlBO0FBQ0EyZSxhQUFTLENBQUUxaUIsT0FBTzhlLEtBQVAsQ0FBY3RTLEdBQWQsRUFBbUIsUUFBbkIsS0FBaUMsRUFBbkMsRUFBeUN5USxNQUFNbFosSUFBL0MsS0FBeUQvRCxPQUFPOGUsS0FBUCxDQUFjdFMsR0FBZCxFQUFtQixRQUFuQixDQUFsRTtBQUNBLFFBQUtrVyxNQUFMLEVBQWM7QUFDYkEsWUFBTzNnQixLQUFQLENBQWN5SyxHQUFkLEVBQW1COUgsSUFBbkI7QUFDQTs7QUFFRDtBQUNBZ2UsYUFBU2EsVUFBVS9XLElBQUsrVyxNQUFMLENBQW5CO0FBQ0EsUUFBS2IsVUFBVUEsT0FBTzNnQixLQUFqQixJQUEwQi9CLE9BQU82ZCxVQUFQLENBQW1CclIsR0FBbkIsQ0FBL0IsRUFBMEQ7QUFDekR5USxXQUFNck0sTUFBTixHQUFlOFIsT0FBTzNnQixLQUFQLENBQWN5SyxHQUFkLEVBQW1COUgsSUFBbkIsQ0FBZjtBQUNBLFNBQUt1WSxNQUFNck0sTUFBTixLQUFpQixLQUF0QixFQUE4QjtBQUM3QnFNLFlBQU0rRyxjQUFOO0FBQ0E7QUFDRDtBQUNEO0FBQ0QvRyxTQUFNbFosSUFBTixHQUFhQSxJQUFiOztBQUVBO0FBQ0EsT0FBSyxDQUFDdWYsWUFBRCxJQUFpQixDQUFDckcsTUFBTWdILGtCQUFOLEVBQXZCLEVBQW9EOztBQUVuRCxRQUFLLENBQUMsQ0FBQzlCLFFBQVErQixRQUFULElBQXFCL0IsUUFBUStCLFFBQVIsQ0FBaUJuaUIsS0FBakIsQ0FBd0IwaEIsVUFBVXpiLEdBQVYsRUFBeEIsRUFBeUN0RCxJQUF6QyxNQUFvRCxLQUExRSxLQUNKMUUsT0FBTzZkLFVBQVAsQ0FBbUJoYyxJQUFuQixDQURELEVBQzZCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxTQUFLMGhCLFVBQVUxaEIsS0FBTWtDLElBQU4sQ0FBVixJQUEwQixDQUFDL0QsT0FBT2lFLFFBQVAsQ0FBaUJwQyxJQUFqQixDQUFoQyxFQUEwRDs7QUFFekQ7QUFDQXFFLFlBQU1yRSxLQUFNMGhCLE1BQU4sQ0FBTjs7QUFFQSxVQUFLcmQsR0FBTCxFQUFXO0FBQ1ZyRSxZQUFNMGhCLE1BQU4sSUFBaUIsSUFBakI7QUFDQTs7QUFFRDtBQUNBdmpCLGFBQU9pZCxLQUFQLENBQWEwRixTQUFiLEdBQXlCNWUsSUFBekI7QUFDQSxVQUFJO0FBQ0hsQyxZQUFNa0MsSUFBTjtBQUNBLE9BRkQsQ0FFRSxPQUFRUSxDQUFSLEVBQVk7QUFDYjtBQUNBO0FBQ0E7QUFDRHZFLGFBQU9pZCxLQUFQLENBQWEwRixTQUFiLEdBQXlCdGYsU0FBekI7O0FBRUEsVUFBSzZDLEdBQUwsRUFBVztBQUNWckUsWUFBTTBoQixNQUFOLElBQWlCcmQsR0FBakI7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxVQUFPK1csTUFBTXJNLE1BQWI7QUFDQSxHQXZVYTs7QUF5VWRnUyxZQUFVLGtCQUFVM0YsS0FBVixFQUFrQjs7QUFFM0I7QUFDQUEsV0FBUWpkLE9BQU9pZCxLQUFQLENBQWFrSCxHQUFiLENBQWtCbEgsS0FBbEIsQ0FBUjs7QUFFQSxPQUFJbmIsQ0FBSjtBQUFBLE9BQU9SLEdBQVA7QUFBQSxPQUFZK2dCLFNBQVo7QUFBQSxPQUF1QjNRLE9BQXZCO0FBQUEsT0FBZ0NyUCxDQUFoQztBQUFBLE9BQ0MraEIsZUFBZSxFQURoQjtBQUFBLE9BRUN6aUIsT0FBT3RDLE9BQU00QixJQUFOLENBQVllLFNBQVosQ0FGUjtBQUFBLE9BR0NzZ0IsV0FBVyxDQUFFdGlCLE9BQU84ZSxLQUFQLENBQWMsSUFBZCxFQUFvQixRQUFwQixLQUFrQyxFQUFwQyxFQUEwQzdCLE1BQU1sWixJQUFoRCxLQUEwRCxFQUh0RTtBQUFBLE9BSUNvZSxVQUFVbmlCLE9BQU9pZCxLQUFQLENBQWFrRixPQUFiLENBQXNCbEYsTUFBTWxaLElBQTVCLEtBQXNDLEVBSmpEOztBQU1BO0FBQ0FwQyxRQUFLLENBQUwsSUFBVXNiLEtBQVY7QUFDQUEsU0FBTW9ILGNBQU4sR0FBdUIsSUFBdkI7O0FBRUE7QUFDQSxPQUFLbEMsUUFBUW1DLFdBQVIsSUFBdUJuQyxRQUFRbUMsV0FBUixDQUFvQnJqQixJQUFwQixDQUEwQixJQUExQixFQUFnQ2djLEtBQWhDLE1BQTRDLEtBQXhFLEVBQWdGO0FBQy9FO0FBQ0E7O0FBRUQ7QUFDQW1ILGtCQUFlcGtCLE9BQU9pZCxLQUFQLENBQWFxRixRQUFiLENBQXNCcmhCLElBQXRCLENBQTRCLElBQTVCLEVBQWtDZ2MsS0FBbEMsRUFBeUNxRixRQUF6QyxDQUFmOztBQUVBO0FBQ0F4Z0IsT0FBSSxDQUFKO0FBQ0EsVUFBUSxDQUFDNFAsVUFBVTBTLGFBQWN0aUIsR0FBZCxDQUFYLEtBQW1DLENBQUNtYixNQUFNOEcsb0JBQU4sRUFBNUMsRUFBMkU7QUFDMUU5RyxVQUFNc0gsYUFBTixHQUFzQjdTLFFBQVE3UCxJQUE5Qjs7QUFFQVEsUUFBSSxDQUFKO0FBQ0EsV0FBUSxDQUFDZ2dCLFlBQVkzUSxRQUFRNFEsUUFBUixDQUFrQmpnQixHQUFsQixDQUFiLEtBQXlDLENBQUM0YSxNQUFNdUgsNkJBQU4sRUFBbEQsRUFBMEY7O0FBRXpGO0FBQ0E7QUFDQSxTQUFLLENBQUN2SCxNQUFNMkcsWUFBUCxJQUF1QjNHLE1BQU0yRyxZQUFOLENBQW1CN1ksSUFBbkIsQ0FBeUJzWCxVQUFVVSxTQUFuQyxDQUE1QixFQUE2RTs7QUFFNUU5RixZQUFNb0YsU0FBTixHQUFrQkEsU0FBbEI7QUFDQXBGLFlBQU12WSxJQUFOLEdBQWEyZCxVQUFVM2QsSUFBdkI7O0FBRUFwRCxZQUFNLENBQUUsQ0FBQ3RCLE9BQU9pZCxLQUFQLENBQWFrRixPQUFiLENBQXNCRSxVQUFVRyxRQUFoQyxLQUE4QyxFQUEvQyxFQUFtREUsTUFBbkQsSUFBNkRMLFVBQVVoVyxPQUF6RSxFQUNIdEssS0FERyxDQUNJMlAsUUFBUTdQLElBRFosRUFDa0JGLElBRGxCLENBQU47O0FBR0EsVUFBS0wsUUFBUStCLFNBQWIsRUFBeUI7QUFDeEIsV0FBSyxDQUFDNFosTUFBTXJNLE1BQU4sR0FBZXRQLEdBQWhCLE1BQXlCLEtBQTlCLEVBQXNDO0FBQ3JDMmIsY0FBTStHLGNBQU47QUFDQS9HLGNBQU13SCxlQUFOO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLE9BQUt0QyxRQUFRdUMsWUFBYixFQUE0QjtBQUMzQnZDLFlBQVF1QyxZQUFSLENBQXFCempCLElBQXJCLENBQTJCLElBQTNCLEVBQWlDZ2MsS0FBakM7QUFDQTs7QUFFRCxVQUFPQSxNQUFNck0sTUFBYjtBQUNBLEdBbFlhOztBQW9ZZDBSLFlBQVUsa0JBQVVyRixLQUFWLEVBQWlCcUYsU0FBakIsRUFBNEI7QUFDckMsT0FBSXFDLEdBQUo7QUFBQSxPQUFTdEMsU0FBVDtBQUFBLE9BQW9CeGMsT0FBcEI7QUFBQSxPQUE2Qi9ELENBQTdCO0FBQUEsT0FDQ3NpQixlQUFlLEVBRGhCO0FBQUEsT0FFQ3BCLGdCQUFnQlYsVUFBU1UsYUFGMUI7QUFBQSxPQUdDeFcsTUFBTXlRLE1BQU1qYSxNQUhiOztBQUtBO0FBQ0E7QUFDQTtBQUNBLE9BQUtnZ0IsaUJBQWlCeFcsSUFBSWxJLFFBQXJCLEtBQWtDLENBQUMyWSxNQUFNMkgsTUFBUCxJQUFpQjNILE1BQU1sWixJQUFOLEtBQWUsT0FBbEUsQ0FBTCxFQUFrRjs7QUFFakY7QUFDQSxXQUFReUksT0FBTyxJQUFmLEVBQXFCQSxNQUFNQSxJQUFJOUIsVUFBSixJQUFrQixJQUE3QyxFQUFvRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsU0FBSzhCLElBQUlsSSxRQUFKLEtBQWlCLENBQWpCLEtBQXVCa0ksSUFBSThGLFFBQUosS0FBaUIsSUFBakIsSUFBeUIySyxNQUFNbFosSUFBTixLQUFlLE9BQS9ELENBQUwsRUFBK0U7QUFDOUU4QixnQkFBVSxFQUFWO0FBQ0EsV0FBTS9ELElBQUksQ0FBVixFQUFhQSxJQUFJa2hCLGFBQWpCLEVBQWdDbGhCLEdBQWhDLEVBQXNDO0FBQ3JDdWdCLG1CQUFZQyxVQUFVeGdCLENBQVYsQ0FBWjs7QUFFQTtBQUNBNmlCLGFBQU10QyxVQUFVcGlCLFFBQVYsR0FBcUIsR0FBM0I7O0FBRUEsV0FBSzRGLFFBQVM4ZSxHQUFULE1BQW1CdGhCLFNBQXhCLEVBQW9DO0FBQ25Dd0MsZ0JBQVM4ZSxHQUFULElBQWlCdEMsVUFBVTlMLFlBQVYsR0FDaEJ2VyxPQUFRMmtCLEdBQVIsRUFBYSxJQUFiLEVBQW9Cek0sS0FBcEIsQ0FBMkIxTCxHQUEzQixLQUFvQyxDQURwQixHQUVoQnhNLE9BQU9pTyxJQUFQLENBQWEwVyxHQUFiLEVBQWtCLElBQWxCLEVBQXdCLElBQXhCLEVBQThCLENBQUVuWSxHQUFGLENBQTlCLEVBQXdDekwsTUFGekM7QUFHQTtBQUNELFdBQUs4RSxRQUFTOGUsR0FBVCxDQUFMLEVBQXNCO0FBQ3JCOWUsZ0JBQVF0RyxJQUFSLENBQWM4aUIsU0FBZDtBQUNBO0FBQ0Q7QUFDRCxVQUFLeGMsUUFBUTlFLE1BQWIsRUFBc0I7QUFDckJxakIsb0JBQWE3a0IsSUFBYixDQUFrQixFQUFFc0MsTUFBTTJLLEdBQVIsRUFBYThWLFVBQVV6YyxPQUF2QixFQUFsQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVEO0FBQ0EsT0FBS21kLGdCQUFnQlYsVUFBU3ZoQixNQUE5QixFQUF1QztBQUN0Q3FqQixpQkFBYTdrQixJQUFiLENBQWtCLEVBQUVzQyxNQUFNLElBQVIsRUFBY3lnQixVQUFVQSxVQUFTampCLEtBQVQsQ0FBZ0IyakIsYUFBaEIsQ0FBeEIsRUFBbEI7QUFDQTs7QUFFRCxVQUFPb0IsWUFBUDtBQUNBLEdBbmJhOztBQXFiZEQsT0FBSyxhQUFVbEgsS0FBVixFQUFrQjtBQUN0QixPQUFLQSxNQUFPamQsT0FBT3NELE9BQWQsQ0FBTCxFQUErQjtBQUM5QixXQUFPMlosS0FBUDtBQUNBOztBQUVEO0FBQ0EsT0FBSW5iLENBQUo7QUFBQSxPQUFPK2lCLElBQVA7QUFBQSxPQUFhamlCLElBQWI7QUFBQSxPQUNDbUIsT0FBT2taLE1BQU1sWixJQURkO0FBQUEsT0FFQytnQixnQkFBZ0I3SCxLQUZqQjtBQUFBLE9BR0M4SCxVQUFVLEtBQUtDLFFBQUwsQ0FBZWpoQixJQUFmLENBSFg7O0FBS0EsT0FBSyxDQUFDZ2hCLE9BQU4sRUFBZ0I7QUFDZixTQUFLQyxRQUFMLENBQWVqaEIsSUFBZixJQUF3QmdoQixVQUN2QnZELFlBQVl6VyxJQUFaLENBQWtCaEgsSUFBbEIsSUFBMkIsS0FBS2toQixVQUFoQyxHQUNBMUQsVUFBVXhXLElBQVYsQ0FBZ0JoSCxJQUFoQixJQUF5QixLQUFLbWhCLFFBQTlCLEdBQ0EsRUFIRDtBQUlBO0FBQ0R0aUIsVUFBT21pQixRQUFRSSxLQUFSLEdBQWdCLEtBQUtBLEtBQUwsQ0FBVzdsQixNQUFYLENBQW1CeWxCLFFBQVFJLEtBQTNCLENBQWhCLEdBQXFELEtBQUtBLEtBQWpFOztBQUVBbEksV0FBUSxJQUFJamQsT0FBTzBqQixLQUFYLENBQWtCb0IsYUFBbEIsQ0FBUjs7QUFFQWhqQixPQUFJYyxLQUFLN0IsTUFBVDtBQUNBLFVBQVFlLEdBQVIsRUFBYztBQUNiK2lCLFdBQU9qaUIsS0FBTWQsQ0FBTixDQUFQO0FBQ0FtYixVQUFPNEgsSUFBUCxJQUFnQkMsY0FBZUQsSUFBZixDQUFoQjtBQUNBOztBQUVEO0FBQ0E7QUFDQSxPQUFLLENBQUM1SCxNQUFNamEsTUFBWixFQUFxQjtBQUNwQmlhLFVBQU1qYSxNQUFOLEdBQWU4aEIsY0FBY00sVUFBZCxJQUE0QnJtQixRQUEzQztBQUNBOztBQUVEO0FBQ0E7QUFDQSxPQUFLa2UsTUFBTWphLE1BQU4sQ0FBYXNCLFFBQWIsS0FBMEIsQ0FBL0IsRUFBbUM7QUFDbEMyWSxVQUFNamEsTUFBTixHQUFlaWEsTUFBTWphLE1BQU4sQ0FBYTBILFVBQTVCO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBdVMsU0FBTW9JLE9BQU4sR0FBZ0IsQ0FBQyxDQUFDcEksTUFBTW9JLE9BQXhCOztBQUVBLFVBQU9OLFFBQVE3VyxNQUFSLEdBQWlCNlcsUUFBUTdXLE1BQVIsQ0FBZ0IrTyxLQUFoQixFQUF1QjZILGFBQXZCLENBQWpCLEdBQTBEN0gsS0FBakU7QUFDQSxHQWplYTs7QUFtZWQ7QUFDQWtJLFNBQU8sd0hBQXdIOWUsS0FBeEgsQ0FBOEgsR0FBOUgsQ0FwZU87O0FBc2VkMmUsWUFBVSxFQXRlSTs7QUF3ZWRFLFlBQVU7QUFDVEMsVUFBTyw0QkFBNEI5ZSxLQUE1QixDQUFrQyxHQUFsQyxDQURFO0FBRVQ2SCxXQUFRLGdCQUFVK08sS0FBVixFQUFpQnFJLFFBQWpCLEVBQTRCOztBQUVuQztBQUNBLFFBQUtySSxNQUFNc0ksS0FBTixJQUFlLElBQXBCLEVBQTJCO0FBQzFCdEksV0FBTXNJLEtBQU4sR0FBY0QsU0FBU0UsUUFBVCxJQUFxQixJQUFyQixHQUE0QkYsU0FBU0UsUUFBckMsR0FBZ0RGLFNBQVNHLE9BQXZFO0FBQ0E7O0FBRUQsV0FBT3hJLEtBQVA7QUFDQTtBQVZRLEdBeGVJOztBQXFmZGdJLGNBQVk7QUFDWEUsVUFBTyxtR0FBbUc5ZSxLQUFuRyxDQUF5RyxHQUF6RyxDQURJO0FBRVg2SCxXQUFRLGdCQUFVK08sS0FBVixFQUFpQnFJLFFBQWpCLEVBQTRCO0FBQ25DLFFBQUk3SSxJQUFKO0FBQUEsUUFBVWlKLFFBQVY7QUFBQSxRQUFvQnRZLEdBQXBCO0FBQUEsUUFDQ3dYLFNBQVNVLFNBQVNWLE1BRG5CO0FBQUEsUUFFQ2UsY0FBY0wsU0FBU0ssV0FGeEI7O0FBSUE7QUFDQSxRQUFLMUksTUFBTTJJLEtBQU4sSUFBZSxJQUFmLElBQXVCTixTQUFTTyxPQUFULElBQW9CLElBQWhELEVBQXVEO0FBQ3RESCxnQkFBV3pJLE1BQU1qYSxNQUFOLENBQWF1SCxhQUFiLElBQThCeEwsUUFBekM7QUFDQXFPLFdBQU1zWSxTQUFTelksZUFBZjtBQUNBd1AsWUFBT2lKLFNBQVNqSixJQUFoQjs7QUFFQVEsV0FBTTJJLEtBQU4sR0FBY04sU0FBU08sT0FBVCxJQUFxQnpZLE9BQU9BLElBQUkwWSxVQUFYLElBQXlCckosUUFBUUEsS0FBS3FKLFVBQXRDLElBQW9ELENBQXpFLEtBQWlGMVksT0FBT0EsSUFBSTJZLFVBQVgsSUFBeUJ0SixRQUFRQSxLQUFLc0osVUFBdEMsSUFBb0QsQ0FBckksQ0FBZDtBQUNBOUksV0FBTStJLEtBQU4sR0FBY1YsU0FBU1csT0FBVCxJQUFxQjdZLE9BQU9BLElBQUk4WSxTQUFYLElBQXlCekosUUFBUUEsS0FBS3lKLFNBQXRDLElBQW9ELENBQXpFLEtBQWlGOVksT0FBT0EsSUFBSStZLFNBQVgsSUFBeUIxSixRQUFRQSxLQUFLMEosU0FBdEMsSUFBb0QsQ0FBckksQ0FBZDtBQUNBOztBQUVEO0FBQ0EsUUFBSyxDQUFDbEosTUFBTW1KLGFBQVAsSUFBd0JULFdBQTdCLEVBQTJDO0FBQzFDMUksV0FBTW1KLGFBQU4sR0FBc0JULGdCQUFnQjFJLE1BQU1qYSxNQUF0QixHQUErQnNpQixTQUFTZSxTQUF4QyxHQUFvRFYsV0FBMUU7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsUUFBSyxDQUFDMUksTUFBTXNJLEtBQVAsSUFBZ0JYLFdBQVd2aEIsU0FBaEMsRUFBNEM7QUFDM0M0WixXQUFNc0ksS0FBTixHQUFnQlgsU0FBUyxDQUFULEdBQWEsQ0FBYixHQUFtQkEsU0FBUyxDQUFULEdBQWEsQ0FBYixHQUFtQkEsU0FBUyxDQUFULEdBQWEsQ0FBYixHQUFpQixDQUF2RTtBQUNBOztBQUVELFdBQU8zSCxLQUFQO0FBQ0E7QUE3QlUsR0FyZkU7O0FBcWhCZGtGLFdBQVM7QUFDUm1FLFNBQU07QUFDTDtBQUNBekMsY0FBVTtBQUZMLElBREU7QUFLUjBDLFVBQU87QUFDTjtBQUNBNUosYUFBUyxtQkFBVztBQUNuQixTQUFLLFNBQVNrRixtQkFBVCxJQUFnQyxLQUFLMEUsS0FBMUMsRUFBa0Q7QUFDakQsVUFBSTtBQUNILFlBQUtBLEtBQUw7QUFDQSxjQUFPLEtBQVA7QUFDQSxPQUhELENBR0UsT0FBUWhpQixDQUFSLEVBQVk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0QsS0FiSztBQWNOc2Usa0JBQWM7QUFkUixJQUxDO0FBcUJSMkQsU0FBTTtBQUNMN0osYUFBUyxtQkFBVztBQUNuQixTQUFLLFNBQVNrRixtQkFBVCxJQUFnQyxLQUFLMkUsSUFBMUMsRUFBaUQ7QUFDaEQsV0FBS0EsSUFBTDtBQUNBLGFBQU8sS0FBUDtBQUNBO0FBQ0QsS0FOSTtBQU9MM0Qsa0JBQWM7QUFQVCxJQXJCRTtBQThCUjNCLFVBQU87QUFDTjtBQUNBdkUsYUFBUyxtQkFBVztBQUNuQixTQUFLM2MsT0FBTzhFLFFBQVAsQ0FBaUIsSUFBakIsRUFBdUIsT0FBdkIsS0FBb0MsS0FBS2YsSUFBTCxLQUFjLFVBQWxELElBQWdFLEtBQUttZCxLQUExRSxFQUFrRjtBQUNqRixXQUFLQSxLQUFMO0FBQ0EsYUFBTyxLQUFQO0FBQ0E7QUFDRCxLQVBLOztBQVNOO0FBQ0FnRCxjQUFVLGtCQUFVakgsS0FBVixFQUFrQjtBQUMzQixZQUFPamQsT0FBTzhFLFFBQVAsQ0FBaUJtWSxNQUFNamEsTUFBdkIsRUFBK0IsR0FBL0IsQ0FBUDtBQUNBO0FBWkssSUE5QkM7O0FBNkNSeWpCLGlCQUFjO0FBQ2IvQixrQkFBYyxzQkFBVXpILEtBQVYsRUFBa0I7O0FBRS9CO0FBQ0EsU0FBS0EsTUFBTXJNLE1BQU4sS0FBaUJ2TixTQUF0QixFQUFrQztBQUNqQzRaLFlBQU02SCxhQUFOLENBQW9CNEIsV0FBcEIsR0FBa0N6SixNQUFNck0sTUFBeEM7QUFDQTtBQUNEO0FBUFk7QUE3Q04sR0FyaEJLOztBQTZrQmQrVixZQUFVLGtCQUFVNWlCLElBQVYsRUFBZ0JsQyxJQUFoQixFQUFzQm9iLEtBQXRCLEVBQTZCMkosTUFBN0IsRUFBc0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBSXJpQixJQUFJdkUsT0FBT3lDLE1BQVAsQ0FDUCxJQUFJekMsT0FBTzBqQixLQUFYLEVBRE8sRUFFUHpHLEtBRk8sRUFHUDtBQUNDbFosVUFBTUEsSUFEUDtBQUVDOGlCLGlCQUFhLElBRmQ7QUFHQy9CLG1CQUFlO0FBSGhCLElBSE8sQ0FBUjtBQVNBLE9BQUs4QixNQUFMLEVBQWM7QUFDYjVtQixXQUFPaWQsS0FBUCxDQUFhTixPQUFiLENBQXNCcFksQ0FBdEIsRUFBeUIsSUFBekIsRUFBK0IxQyxJQUEvQjtBQUNBLElBRkQsTUFFTztBQUNON0IsV0FBT2lkLEtBQVAsQ0FBYTJGLFFBQWIsQ0FBc0IzaEIsSUFBdEIsQ0FBNEJZLElBQTVCLEVBQWtDMEMsQ0FBbEM7QUFDQTtBQUNELE9BQUtBLEVBQUUwZixrQkFBRixFQUFMLEVBQThCO0FBQzdCaEgsVUFBTStHLGNBQU47QUFDQTtBQUNEO0FBbG1CYSxFQUFmOztBQXFtQkFoa0IsUUFBT3FqQixXQUFQLEdBQXFCdGtCLFNBQVMrZCxtQkFBVCxHQUNwQixVQUFVamIsSUFBVixFQUFnQmtDLElBQWhCLEVBQXNCMmUsTUFBdEIsRUFBK0I7QUFDOUIsTUFBSzdnQixLQUFLaWIsbUJBQVYsRUFBZ0M7QUFDL0JqYixRQUFLaWIsbUJBQUwsQ0FBMEIvWSxJQUExQixFQUFnQzJlLE1BQWhDLEVBQXdDLEtBQXhDO0FBQ0E7QUFDRCxFQUxtQixHQU1wQixVQUFVN2dCLElBQVYsRUFBZ0JrQyxJQUFoQixFQUFzQjJlLE1BQXRCLEVBQStCO0FBQzlCLE1BQUk3ZixPQUFPLE9BQU9rQixJQUFsQjs7QUFFQSxNQUFLbEMsS0FBS21iLFdBQVYsRUFBd0I7O0FBRXZCO0FBQ0E7QUFDQSxPQUFLLFFBQU9uYixLQUFNZ0IsSUFBTixDQUFQLE1BQXdCaUYsWUFBN0IsRUFBNEM7QUFDM0NqRyxTQUFNZ0IsSUFBTixJQUFlLElBQWY7QUFDQTs7QUFFRGhCLFFBQUttYixXQUFMLENBQWtCbmEsSUFBbEIsRUFBd0I2ZixNQUF4QjtBQUNBO0FBQ0QsRUFuQkY7O0FBcUJBMWlCLFFBQU8wakIsS0FBUCxHQUFlLFVBQVVoaEIsR0FBVixFQUFleWlCLEtBQWYsRUFBdUI7QUFDckM7QUFDQSxNQUFLLEVBQUUsZ0JBQWdCbmxCLE9BQU8wakIsS0FBekIsQ0FBTCxFQUF1QztBQUN0QyxVQUFPLElBQUkxakIsT0FBTzBqQixLQUFYLENBQWtCaGhCLEdBQWxCLEVBQXVCeWlCLEtBQXZCLENBQVA7QUFDQTs7QUFFRDtBQUNBLE1BQUt6aUIsT0FBT0EsSUFBSXFCLElBQWhCLEVBQXVCO0FBQ3RCLFFBQUsrZ0IsYUFBTCxHQUFxQnBpQixHQUFyQjtBQUNBLFFBQUtxQixJQUFMLEdBQVlyQixJQUFJcUIsSUFBaEI7O0FBRUE7QUFDQTtBQUNBLFFBQUtrZ0Isa0JBQUwsR0FBMEJ2aEIsSUFBSW9rQixnQkFBSixJQUN4QnBrQixJQUFJb2tCLGdCQUFKLEtBQXlCempCLFNBQXpCO0FBQ0E7QUFDQVgsT0FBSWdrQixXQUFKLEtBQW9CLEtBQXBCO0FBQ0E7QUFDQWhrQixPQUFJcWtCLGlCQUFKLElBQXlCcmtCLElBQUlxa0IsaUJBQUosRUFKekIsQ0FEd0IsR0FNekJwRixVQU55QixHQU96QkMsV0FQRDs7QUFTRDtBQUNDLEdBaEJELE1BZ0JPO0FBQ04sUUFBSzdkLElBQUwsR0FBWXJCLEdBQVo7QUFDQTs7QUFFRDtBQUNBLE1BQUt5aUIsS0FBTCxFQUFhO0FBQ1pubEIsVUFBT3lDLE1BQVAsQ0FBZSxJQUFmLEVBQXFCMGlCLEtBQXJCO0FBQ0E7O0FBRUQ7QUFDQSxPQUFLNkIsU0FBTCxHQUFpQnRrQixPQUFPQSxJQUFJc2tCLFNBQVgsSUFBd0JobkIsT0FBT21HLEdBQVAsRUFBekM7O0FBRUE7QUFDQSxPQUFNbkcsT0FBT3NELE9BQWIsSUFBeUIsSUFBekI7QUFDQSxFQXJDRDs7QUF1Q0E7QUFDQTtBQUNBdEQsUUFBTzBqQixLQUFQLENBQWE5aUIsU0FBYixHQUF5QjtBQUN4QnFqQixzQkFBb0JyQyxXQURJO0FBRXhCbUMsd0JBQXNCbkMsV0FGRTtBQUd4QjRDLGlDQUErQjVDLFdBSFA7O0FBS3hCb0Msa0JBQWdCLDBCQUFXO0FBQzFCLE9BQUl6ZixJQUFJLEtBQUt1Z0IsYUFBYjs7QUFFQSxRQUFLYixrQkFBTCxHQUEwQnRDLFVBQTFCO0FBQ0EsT0FBSyxDQUFDcGQsQ0FBTixFQUFVO0FBQ1Q7QUFDQTs7QUFFRDtBQUNBLE9BQUtBLEVBQUV5ZixjQUFQLEVBQXdCO0FBQ3ZCemYsTUFBRXlmLGNBQUY7O0FBRUQ7QUFDQTtBQUNDLElBTEQsTUFLTztBQUNOemYsTUFBRW1pQixXQUFGLEdBQWdCLEtBQWhCO0FBQ0E7QUFDRCxHQXRCdUI7QUF1QnhCakMsbUJBQWlCLDJCQUFXO0FBQzNCLE9BQUlsZ0IsSUFBSSxLQUFLdWdCLGFBQWI7O0FBRUEsUUFBS2Ysb0JBQUwsR0FBNEJwQyxVQUE1QjtBQUNBLE9BQUssQ0FBQ3BkLENBQU4sRUFBVTtBQUNUO0FBQ0E7QUFDRDtBQUNBLE9BQUtBLEVBQUVrZ0IsZUFBUCxFQUF5QjtBQUN4QmxnQixNQUFFa2dCLGVBQUY7QUFDQTs7QUFFRDtBQUNBO0FBQ0FsZ0IsS0FBRTBpQixZQUFGLEdBQWlCLElBQWpCO0FBQ0EsR0F0Q3VCO0FBdUN4QkMsNEJBQTBCLG9DQUFXO0FBQ3BDLFFBQUsxQyw2QkFBTCxHQUFxQzdDLFVBQXJDO0FBQ0EsUUFBSzhDLGVBQUw7QUFDQTtBQTFDdUIsRUFBekI7O0FBNkNBO0FBQ0F6a0IsUUFBT3lCLElBQVAsQ0FBWTtBQUNYMGxCLGNBQVksV0FERDtBQUVYQyxjQUFZO0FBRkQsRUFBWixFQUdHLFVBQVVDLElBQVYsRUFBZ0JsRCxHQUFoQixFQUFzQjtBQUN4Qm5rQixTQUFPaWQsS0FBUCxDQUFha0YsT0FBYixDQUFzQmtGLElBQXRCLElBQStCO0FBQzlCeEUsaUJBQWNzQixHQURnQjtBQUU5QnJCLGFBQVVxQixHQUZvQjs7QUFJOUJ6QixXQUFRLGdCQUFVekYsS0FBVixFQUFrQjtBQUN6QixRQUFJM2IsR0FBSjtBQUFBLFFBQ0MwQixTQUFTLElBRFY7QUFBQSxRQUVDc2tCLFVBQVVySyxNQUFNbUosYUFGakI7QUFBQSxRQUdDL0QsWUFBWXBGLE1BQU1vRixTQUhuQjs7QUFLQTtBQUNBO0FBQ0EsUUFBSyxDQUFDaUYsT0FBRCxJQUFhQSxZQUFZdGtCLE1BQVosSUFBc0IsQ0FBQ2hELE9BQU9tSCxRQUFQLENBQWlCbkUsTUFBakIsRUFBeUJza0IsT0FBekIsQ0FBekMsRUFBK0U7QUFDOUVySyxXQUFNbFosSUFBTixHQUFhc2UsVUFBVUcsUUFBdkI7QUFDQWxoQixXQUFNK2dCLFVBQVVoVyxPQUFWLENBQWtCdEssS0FBbEIsQ0FBeUIsSUFBekIsRUFBK0JDLFNBQS9CLENBQU47QUFDQWliLFdBQU1sWixJQUFOLEdBQWFvZ0IsR0FBYjtBQUNBO0FBQ0QsV0FBTzdpQixHQUFQO0FBQ0E7QUFsQjZCLEdBQS9CO0FBb0JBLEVBeEJEOztBQTBCQTtBQUNBLEtBQUssQ0FBQ3hCLFFBQVF5bkIsYUFBZCxFQUE4Qjs7QUFFN0J2bkIsU0FBT2lkLEtBQVAsQ0FBYWtGLE9BQWIsQ0FBcUJwUCxNQUFyQixHQUE4QjtBQUM3QmtRLFVBQU8saUJBQVc7QUFDakI7QUFDQSxRQUFLampCLE9BQU84RSxRQUFQLENBQWlCLElBQWpCLEVBQXVCLE1BQXZCLENBQUwsRUFBdUM7QUFDdEMsWUFBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQTlFLFdBQU9pZCxLQUFQLENBQWE3RSxHQUFiLENBQWtCLElBQWxCLEVBQXdCLGdDQUF4QixFQUEwRCxVQUFVN1QsQ0FBVixFQUFjO0FBQ3ZFO0FBQ0EsU0FBSTFDLE9BQU8wQyxFQUFFdkIsTUFBYjtBQUFBLFNBQ0N3a0IsT0FBT3huQixPQUFPOEUsUUFBUCxDQUFpQmpELElBQWpCLEVBQXVCLE9BQXZCLEtBQW9DN0IsT0FBTzhFLFFBQVAsQ0FBaUJqRCxJQUFqQixFQUF1QixRQUF2QixDQUFwQyxHQUF3RUEsS0FBSzJsQixJQUE3RSxHQUFvRm5rQixTQUQ1RjtBQUVBLFNBQUtta0IsUUFBUSxDQUFDeG5CLE9BQU84ZSxLQUFQLENBQWMwSSxJQUFkLEVBQW9CLGVBQXBCLENBQWQsRUFBc0Q7QUFDckR4bkIsYUFBT2lkLEtBQVAsQ0FBYTdFLEdBQWIsQ0FBa0JvUCxJQUFsQixFQUF3QixnQkFBeEIsRUFBMEMsVUFBVXZLLEtBQVYsRUFBa0I7QUFDM0RBLGFBQU13SyxjQUFOLEdBQXVCLElBQXZCO0FBQ0EsT0FGRDtBQUdBem5CLGFBQU84ZSxLQUFQLENBQWMwSSxJQUFkLEVBQW9CLGVBQXBCLEVBQXFDLElBQXJDO0FBQ0E7QUFDRCxLQVZEO0FBV0E7QUFDQSxJQXBCNEI7O0FBc0I3QjlDLGlCQUFjLHNCQUFVekgsS0FBVixFQUFrQjtBQUMvQjtBQUNBLFFBQUtBLE1BQU13SyxjQUFYLEVBQTRCO0FBQzNCLFlBQU94SyxNQUFNd0ssY0FBYjtBQUNBLFNBQUssS0FBSy9jLFVBQUwsSUFBbUIsQ0FBQ3VTLE1BQU0wRyxTQUEvQixFQUEyQztBQUMxQzNqQixhQUFPaWQsS0FBUCxDQUFhMEosUUFBYixDQUF1QixRQUF2QixFQUFpQyxLQUFLamMsVUFBdEMsRUFBa0R1UyxLQUFsRCxFQUF5RCxJQUF6RDtBQUNBO0FBQ0Q7QUFDRCxJQTlCNEI7O0FBZ0M3Qm1HLGFBQVUsb0JBQVc7QUFDcEI7QUFDQSxRQUFLcGpCLE9BQU84RSxRQUFQLENBQWlCLElBQWpCLEVBQXVCLE1BQXZCLENBQUwsRUFBdUM7QUFDdEMsWUFBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQTlFLFdBQU9pZCxLQUFQLENBQWFoRCxNQUFiLENBQXFCLElBQXJCLEVBQTJCLFVBQTNCO0FBQ0E7QUF4QzRCLEdBQTlCO0FBMENBOztBQUVEO0FBQ0EsS0FBSyxDQUFDbmEsUUFBUTRuQixhQUFkLEVBQThCOztBQUU3QjFuQixTQUFPaWQsS0FBUCxDQUFha0YsT0FBYixDQUFxQmYsTUFBckIsR0FBOEI7O0FBRTdCNkIsVUFBTyxpQkFBVzs7QUFFakIsUUFBSzNCLFdBQVd2VyxJQUFYLENBQWlCLEtBQUtqRyxRQUF0QixDQUFMLEVBQXdDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQUssS0FBS2YsSUFBTCxLQUFjLFVBQWQsSUFBNEIsS0FBS0EsSUFBTCxLQUFjLE9BQS9DLEVBQXlEO0FBQ3hEL0QsYUFBT2lkLEtBQVAsQ0FBYTdFLEdBQWIsQ0FBa0IsSUFBbEIsRUFBd0Isd0JBQXhCLEVBQWtELFVBQVU2RSxLQUFWLEVBQWtCO0FBQ25FLFdBQUtBLE1BQU02SCxhQUFOLENBQW9CNkMsWUFBcEIsS0FBcUMsU0FBMUMsRUFBc0Q7QUFDckQsYUFBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUNBO0FBQ0QsT0FKRDtBQUtBNW5CLGFBQU9pZCxLQUFQLENBQWE3RSxHQUFiLENBQWtCLElBQWxCLEVBQXdCLGVBQXhCLEVBQXlDLFVBQVU2RSxLQUFWLEVBQWtCO0FBQzFELFdBQUssS0FBSzJLLGFBQUwsSUFBc0IsQ0FBQzNLLE1BQU0wRyxTQUFsQyxFQUE4QztBQUM3QyxhQUFLaUUsYUFBTCxHQUFxQixLQUFyQjtBQUNBO0FBQ0Q7QUFDQTVuQixjQUFPaWQsS0FBUCxDQUFhMEosUUFBYixDQUF1QixRQUF2QixFQUFpQyxJQUFqQyxFQUF1QzFKLEtBQXZDLEVBQThDLElBQTlDO0FBQ0EsT0FORDtBQU9BO0FBQ0QsWUFBTyxLQUFQO0FBQ0E7QUFDRDtBQUNBamQsV0FBT2lkLEtBQVAsQ0FBYTdFLEdBQWIsQ0FBa0IsSUFBbEIsRUFBd0Isd0JBQXhCLEVBQWtELFVBQVU3VCxDQUFWLEVBQWM7QUFDL0QsU0FBSTFDLE9BQU8wQyxFQUFFdkIsTUFBYjs7QUFFQSxTQUFLc2UsV0FBV3ZXLElBQVgsQ0FBaUJsSixLQUFLaUQsUUFBdEIsS0FBb0MsQ0FBQzlFLE9BQU84ZSxLQUFQLENBQWNqZCxJQUFkLEVBQW9CLGVBQXBCLENBQTFDLEVBQWtGO0FBQ2pGN0IsYUFBT2lkLEtBQVAsQ0FBYTdFLEdBQWIsQ0FBa0J2VyxJQUFsQixFQUF3QixnQkFBeEIsRUFBMEMsVUFBVW9iLEtBQVYsRUFBa0I7QUFDM0QsV0FBSyxLQUFLdlMsVUFBTCxJQUFtQixDQUFDdVMsTUFBTTRKLFdBQTFCLElBQXlDLENBQUM1SixNQUFNMEcsU0FBckQsRUFBaUU7QUFDaEUzakIsZUFBT2lkLEtBQVAsQ0FBYTBKLFFBQWIsQ0FBdUIsUUFBdkIsRUFBaUMsS0FBS2pjLFVBQXRDLEVBQWtEdVMsS0FBbEQsRUFBeUQsSUFBekQ7QUFDQTtBQUNELE9BSkQ7QUFLQWpkLGFBQU84ZSxLQUFQLENBQWNqZCxJQUFkLEVBQW9CLGVBQXBCLEVBQXFDLElBQXJDO0FBQ0E7QUFDRCxLQVhEO0FBWUEsSUFyQzRCOztBQXVDN0I2Z0IsV0FBUSxnQkFBVXpGLEtBQVYsRUFBa0I7QUFDekIsUUFBSXBiLE9BQU9vYixNQUFNamEsTUFBakI7O0FBRUE7QUFDQSxRQUFLLFNBQVNuQixJQUFULElBQWlCb2IsTUFBTTRKLFdBQXZCLElBQXNDNUosTUFBTTBHLFNBQTVDLElBQTBEOWhCLEtBQUtrQyxJQUFMLEtBQWMsT0FBZCxJQUF5QmxDLEtBQUtrQyxJQUFMLEtBQWMsVUFBdEcsRUFBb0g7QUFDbkgsWUFBT2taLE1BQU1vRixTQUFOLENBQWdCaFcsT0FBaEIsQ0FBd0J0SyxLQUF4QixDQUErQixJQUEvQixFQUFxQ0MsU0FBckMsQ0FBUDtBQUNBO0FBQ0QsSUE5QzRCOztBQWdEN0JvaEIsYUFBVSxvQkFBVztBQUNwQnBqQixXQUFPaWQsS0FBUCxDQUFhaEQsTUFBYixDQUFxQixJQUFyQixFQUEyQixVQUEzQjs7QUFFQSxXQUFPLENBQUNxSCxXQUFXdlcsSUFBWCxDQUFpQixLQUFLakcsUUFBdEIsQ0FBUjtBQUNBO0FBcEQ0QixHQUE5QjtBQXNEQTs7QUFFRDtBQUNBLEtBQUssQ0FBQ2hGLFFBQVErbkIsY0FBZCxFQUErQjtBQUM5QjduQixTQUFPeUIsSUFBUCxDQUFZLEVBQUU4a0IsT0FBTyxTQUFULEVBQW9CQyxNQUFNLFVBQTFCLEVBQVosRUFBb0QsVUFBVWEsSUFBVixFQUFnQmxELEdBQWhCLEVBQXNCOztBQUV6RTtBQUNBLE9BQUk5WCxVQUFVLFNBQVZBLE9BQVUsQ0FBVTRRLEtBQVYsRUFBa0I7QUFDOUJqZCxXQUFPaWQsS0FBUCxDQUFhMEosUUFBYixDQUF1QnhDLEdBQXZCLEVBQTRCbEgsTUFBTWphLE1BQWxDLEVBQTBDaEQsT0FBT2lkLEtBQVAsQ0FBYWtILEdBQWIsQ0FBa0JsSCxLQUFsQixDQUExQyxFQUFxRSxJQUFyRTtBQUNBLElBRkY7O0FBSUFqZCxVQUFPaWQsS0FBUCxDQUFha0YsT0FBYixDQUFzQmdDLEdBQXRCLElBQThCO0FBQzdCbEIsV0FBTyxpQkFBVztBQUNqQixTQUFJN1YsTUFBTSxLQUFLN0MsYUFBTCxJQUFzQixJQUFoQztBQUFBLFNBQ0N1ZCxXQUFXOW5CLE9BQU84ZSxLQUFQLENBQWMxUixHQUFkLEVBQW1CK1csR0FBbkIsQ0FEWjs7QUFHQSxTQUFLLENBQUMyRCxRQUFOLEVBQWlCO0FBQ2hCMWEsVUFBSUksZ0JBQUosQ0FBc0I2WixJQUF0QixFQUE0QmhiLE9BQTVCLEVBQXFDLElBQXJDO0FBQ0E7QUFDRHJNLFlBQU84ZSxLQUFQLENBQWMxUixHQUFkLEVBQW1CK1csR0FBbkIsRUFBd0IsQ0FBRTJELFlBQVksQ0FBZCxJQUFvQixDQUE1QztBQUNBLEtBVDRCO0FBVTdCMUUsY0FBVSxvQkFBVztBQUNwQixTQUFJaFcsTUFBTSxLQUFLN0MsYUFBTCxJQUFzQixJQUFoQztBQUFBLFNBQ0N1ZCxXQUFXOW5CLE9BQU84ZSxLQUFQLENBQWMxUixHQUFkLEVBQW1CK1csR0FBbkIsSUFBMkIsQ0FEdkM7O0FBR0EsU0FBSyxDQUFDMkQsUUFBTixFQUFpQjtBQUNoQjFhLFVBQUkwUCxtQkFBSixDQUF5QnVLLElBQXpCLEVBQStCaGIsT0FBL0IsRUFBd0MsSUFBeEM7QUFDQXJNLGFBQU8rZSxXQUFQLENBQW9CM1IsR0FBcEIsRUFBeUIrVyxHQUF6QjtBQUNBLE1BSEQsTUFHTztBQUNObmtCLGFBQU84ZSxLQUFQLENBQWMxUixHQUFkLEVBQW1CK1csR0FBbkIsRUFBd0IyRCxRQUF4QjtBQUNBO0FBQ0Q7QUFwQjRCLElBQTlCO0FBc0JBLEdBN0JEO0FBOEJBOztBQUVEOW5CLFFBQU9HLEVBQVAsQ0FBVXNDLE1BQVYsQ0FBaUI7O0FBRWhCc2xCLE1BQUksWUFBVWhHLEtBQVYsRUFBaUI5aEIsUUFBakIsRUFBMkJ5RSxJQUEzQixFQUFpQ3ZFLEVBQWpDLEVBQXFDLFlBQWE2bkIsR0FBbEQsRUFBd0Q7QUFDM0QsT0FBSWprQixJQUFKLEVBQVVra0IsTUFBVjs7QUFFQTtBQUNBLE9BQUssUUFBT2xHLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBdEIsRUFBaUM7QUFDaEM7QUFDQSxRQUFLLE9BQU85aEIsUUFBUCxLQUFvQixRQUF6QixFQUFvQztBQUNuQztBQUNBeUUsWUFBT0EsUUFBUXpFLFFBQWY7QUFDQUEsZ0JBQVdvRCxTQUFYO0FBQ0E7QUFDRCxTQUFNVSxJQUFOLElBQWNnZSxLQUFkLEVBQXNCO0FBQ3JCLFVBQUtnRyxFQUFMLENBQVNoa0IsSUFBVCxFQUFlOUQsUUFBZixFQUF5QnlFLElBQXpCLEVBQStCcWQsTUFBT2hlLElBQVAsQ0FBL0IsRUFBOENpa0IsR0FBOUM7QUFDQTtBQUNELFdBQU8sSUFBUDtBQUNBOztBQUVELE9BQUt0akIsUUFBUSxJQUFSLElBQWdCdkUsTUFBTSxJQUEzQixFQUFrQztBQUNqQztBQUNBQSxTQUFLRixRQUFMO0FBQ0F5RSxXQUFPekUsV0FBV29ELFNBQWxCO0FBQ0EsSUFKRCxNQUlPLElBQUtsRCxNQUFNLElBQVgsRUFBa0I7QUFDeEIsUUFBSyxPQUFPRixRQUFQLEtBQW9CLFFBQXpCLEVBQW9DO0FBQ25DO0FBQ0FFLFVBQUt1RSxJQUFMO0FBQ0FBLFlBQU9yQixTQUFQO0FBQ0EsS0FKRCxNQUlPO0FBQ047QUFDQWxELFVBQUt1RSxJQUFMO0FBQ0FBLFlBQU96RSxRQUFQO0FBQ0FBLGdCQUFXb0QsU0FBWDtBQUNBO0FBQ0Q7QUFDRCxPQUFLbEQsT0FBTyxLQUFaLEVBQW9CO0FBQ25CQSxTQUFLeWhCLFdBQUw7QUFDQSxJQUZELE1BRU8sSUFBSyxDQUFDemhCLEVBQU4sRUFBVztBQUNqQixXQUFPLElBQVA7QUFDQTs7QUFFRCxPQUFLNm5CLFFBQVEsQ0FBYixFQUFpQjtBQUNoQkMsYUFBUzluQixFQUFUO0FBQ0FBLFNBQUssWUFBVThjLEtBQVYsRUFBa0I7QUFDdEI7QUFDQWpkLGNBQVM0YyxHQUFULENBQWNLLEtBQWQ7QUFDQSxZQUFPZ0wsT0FBT2xtQixLQUFQLENBQWMsSUFBZCxFQUFvQkMsU0FBcEIsQ0FBUDtBQUNBLEtBSkQ7QUFLQTtBQUNBN0IsT0FBRzZGLElBQUgsR0FBVWlpQixPQUFPamlCLElBQVAsS0FBaUJpaUIsT0FBT2ppQixJQUFQLEdBQWNoRyxPQUFPZ0csSUFBUCxFQUEvQixDQUFWO0FBQ0E7QUFDRCxVQUFPLEtBQUt2RSxJQUFMLENBQVcsWUFBVztBQUM1QnpCLFdBQU9pZCxLQUFQLENBQWE3RSxHQUFiLENBQWtCLElBQWxCLEVBQXdCMkosS0FBeEIsRUFBK0I1aEIsRUFBL0IsRUFBbUN1RSxJQUFuQyxFQUF5Q3pFLFFBQXpDO0FBQ0EsSUFGTSxDQUFQO0FBR0EsR0F0RGU7QUF1RGhCK25CLE9BQUssYUFBVWpHLEtBQVYsRUFBaUI5aEIsUUFBakIsRUFBMkJ5RSxJQUEzQixFQUFpQ3ZFLEVBQWpDLEVBQXNDO0FBQzFDLFVBQU8sS0FBSzRuQixFQUFMLENBQVNoRyxLQUFULEVBQWdCOWhCLFFBQWhCLEVBQTBCeUUsSUFBMUIsRUFBZ0N2RSxFQUFoQyxFQUFvQyxDQUFwQyxDQUFQO0FBQ0EsR0F6RGU7QUEwRGhCeWMsT0FBSyxhQUFVbUYsS0FBVixFQUFpQjloQixRQUFqQixFQUEyQkUsRUFBM0IsRUFBZ0M7QUFDcEMsT0FBSWtpQixTQUFKLEVBQWV0ZSxJQUFmO0FBQ0EsT0FBS2dlLFNBQVNBLE1BQU1pQyxjQUFmLElBQWlDakMsTUFBTU0sU0FBNUMsRUFBd0Q7QUFDdkQ7QUFDQUEsZ0JBQVlOLE1BQU1NLFNBQWxCO0FBQ0FyaUIsV0FBUStoQixNQUFNc0MsY0FBZCxFQUErQnpILEdBQS9CLENBQ0N5RixVQUFVVSxTQUFWLEdBQXNCVixVQUFVRyxRQUFWLEdBQXFCLEdBQXJCLEdBQTJCSCxVQUFVVSxTQUEzRCxHQUF1RVYsVUFBVUcsUUFEbEYsRUFFQ0gsVUFBVXBpQixRQUZYLEVBR0NvaUIsVUFBVWhXLE9BSFg7QUFLQSxXQUFPLElBQVA7QUFDQTtBQUNELE9BQUssUUFBTzBWLEtBQVAseUNBQU9BLEtBQVAsT0FBaUIsUUFBdEIsRUFBaUM7QUFDaEM7QUFDQSxTQUFNaGUsSUFBTixJQUFjZ2UsS0FBZCxFQUFzQjtBQUNyQixVQUFLbkYsR0FBTCxDQUFVN1ksSUFBVixFQUFnQjlELFFBQWhCLEVBQTBCOGhCLE1BQU9oZSxJQUFQLENBQTFCO0FBQ0E7QUFDRCxXQUFPLElBQVA7QUFDQTtBQUNELE9BQUs5RCxhQUFhLEtBQWIsSUFBc0IsT0FBT0EsUUFBUCxLQUFvQixVQUEvQyxFQUE0RDtBQUMzRDtBQUNBRSxTQUFLRixRQUFMO0FBQ0FBLGVBQVdvRCxTQUFYO0FBQ0E7QUFDRCxPQUFLbEQsT0FBTyxLQUFaLEVBQW9CO0FBQ25CQSxTQUFLeWhCLFdBQUw7QUFDQTtBQUNELFVBQU8sS0FBS25nQixJQUFMLENBQVUsWUFBVztBQUMzQnpCLFdBQU9pZCxLQUFQLENBQWFoRCxNQUFiLENBQXFCLElBQXJCLEVBQTJCOEgsS0FBM0IsRUFBa0M1aEIsRUFBbEMsRUFBc0NGLFFBQXRDO0FBQ0EsSUFGTSxDQUFQO0FBR0EsR0F4RmU7O0FBMEZoQjBjLFdBQVMsaUJBQVU1WSxJQUFWLEVBQWdCVyxJQUFoQixFQUF1QjtBQUMvQixVQUFPLEtBQUtqRCxJQUFMLENBQVUsWUFBVztBQUMzQnpCLFdBQU9pZCxLQUFQLENBQWFOLE9BQWIsQ0FBc0I1WSxJQUF0QixFQUE0QlcsSUFBNUIsRUFBa0MsSUFBbEM7QUFDQSxJQUZNLENBQVA7QUFHQSxHQTlGZTtBQStGaEJ3akIsa0JBQWdCLHdCQUFVbmtCLElBQVYsRUFBZ0JXLElBQWhCLEVBQXVCO0FBQ3RDLE9BQUk3QyxPQUFPLEtBQUssQ0FBTCxDQUFYO0FBQ0EsT0FBS0EsSUFBTCxFQUFZO0FBQ1gsV0FBTzdCLE9BQU9pZCxLQUFQLENBQWFOLE9BQWIsQ0FBc0I1WSxJQUF0QixFQUE0QlcsSUFBNUIsRUFBa0M3QyxJQUFsQyxFQUF3QyxJQUF4QyxDQUFQO0FBQ0E7QUFDRDtBQXBHZSxFQUFqQjs7QUF3R0EsVUFBU3NtQixrQkFBVCxDQUE2QnBwQixRQUE3QixFQUF3QztBQUN2QyxNQUFJNGEsT0FBT3lPLFVBQVUvaEIsS0FBVixDQUFpQixHQUFqQixDQUFYO0FBQUEsTUFDQ2dpQixXQUFXdHBCLFNBQVN3aEIsc0JBQVQsRUFEWjs7QUFHQSxNQUFLOEgsU0FBU3BjLGFBQWQsRUFBOEI7QUFDN0IsVUFBUTBOLEtBQUs1WSxNQUFiLEVBQXNCO0FBQ3JCc25CLGFBQVNwYyxhQUFULENBQ0MwTixLQUFLM1IsR0FBTCxFQUREO0FBR0E7QUFDRDtBQUNELFNBQU9xZ0IsUUFBUDtBQUNBOztBQUVELEtBQUlELFlBQVksd0ZBQ2QseUVBREY7QUFBQSxLQUVDRSxnQkFBZ0IsNEJBRmpCO0FBQUEsS0FHQ0MsZUFBZSxJQUFJL2YsTUFBSixDQUFXLFNBQVM0ZixTQUFULEdBQXFCLFVBQWhDLEVBQTRDLEdBQTVDLENBSGhCO0FBQUEsS0FJQ0kscUJBQXFCLE1BSnRCO0FBQUEsS0FLQ0MsWUFBWSx5RUFMYjtBQUFBLEtBTUNDLFdBQVcsV0FOWjtBQUFBLEtBT0NDLFNBQVMsU0FQVjtBQUFBLEtBUUNDLFFBQVEsV0FSVDtBQUFBLEtBU0NDLGVBQWUseUJBVGhCOztBQVVDO0FBQ0FDLFlBQVcsbUNBWFo7QUFBQSxLQVlDQyxjQUFjLDJCQVpmO0FBQUEsS0FhQ0Msb0JBQW9CLGFBYnJCO0FBQUEsS0FjQ0MsZUFBZSwwQ0FkaEI7OztBQWdCQztBQUNBQyxXQUFVO0FBQ1RDLFVBQVEsQ0FBRSxDQUFGLEVBQUssOEJBQUwsRUFBcUMsV0FBckMsQ0FEQztBQUVUQyxVQUFRLENBQUUsQ0FBRixFQUFLLFlBQUwsRUFBbUIsYUFBbkIsQ0FGQztBQUdUQyxRQUFNLENBQUUsQ0FBRixFQUFLLE9BQUwsRUFBYyxRQUFkLENBSEc7QUFJVEMsU0FBTyxDQUFFLENBQUYsRUFBSyxVQUFMLEVBQWlCLFdBQWpCLENBSkU7QUFLVEMsU0FBTyxDQUFFLENBQUYsRUFBSyxTQUFMLEVBQWdCLFVBQWhCLENBTEU7QUFNVEMsTUFBSSxDQUFFLENBQUYsRUFBSyxnQkFBTCxFQUF1QixrQkFBdkIsQ0FOSztBQU9UQyxPQUFLLENBQUUsQ0FBRixFQUFLLGtDQUFMLEVBQXlDLHFCQUF6QyxDQVBJO0FBUVRDLE1BQUksQ0FBRSxDQUFGLEVBQUssb0JBQUwsRUFBMkIsdUJBQTNCLENBUks7O0FBVVQ7QUFDQTtBQUNBeEYsWUFBVXBrQixRQUFRNGdCLGFBQVIsR0FBd0IsQ0FBRSxDQUFGLEVBQUssRUFBTCxFQUFTLEVBQVQsQ0FBeEIsR0FBd0MsQ0FBRSxDQUFGLEVBQUssUUFBTCxFQUFlLFFBQWY7QUFaekMsRUFqQlg7QUFBQSxLQStCQ2lKLGVBQWV4QixtQkFBb0JwcEIsUUFBcEIsQ0EvQmhCO0FBQUEsS0FnQ0M2cUIsY0FBY0QsYUFBYWhjLFdBQWIsQ0FBMEI1TyxTQUFTa04sYUFBVCxDQUF1QixLQUF2QixDQUExQixDQWhDZjs7QUFrQ0FpZCxTQUFRVyxRQUFSLEdBQW1CWCxRQUFRQyxNQUEzQjtBQUNBRCxTQUFRekksS0FBUixHQUFnQnlJLFFBQVFZLEtBQVIsR0FBZ0JaLFFBQVFhLFFBQVIsR0FBbUJiLFFBQVFjLE9BQVIsR0FBa0JkLFFBQVFLLEtBQTdFO0FBQ0FMLFNBQVFlLEVBQVIsR0FBYWYsUUFBUVEsRUFBckI7O0FBRUEsVUFBU1EsTUFBVCxDQUFpQmhxQixPQUFqQixFQUEwQm1PLEdBQTFCLEVBQWdDO0FBQy9CLE1BQUloTixLQUFKO0FBQUEsTUFBV1EsSUFBWDtBQUFBLE1BQ0NDLElBQUksQ0FETDtBQUFBLE1BRUNxb0IsUUFBUSxRQUFPanFCLFFBQVEwSyxvQkFBZixNQUF3QzlDLFlBQXhDLEdBQXVENUgsUUFBUTBLLG9CQUFSLENBQThCeUQsT0FBTyxHQUFyQyxDQUF2RCxHQUNQLFFBQU9uTyxRQUFRb0wsZ0JBQWYsTUFBb0N4RCxZQUFwQyxHQUFtRDVILFFBQVFvTCxnQkFBUixDQUEwQitDLE9BQU8sR0FBakMsQ0FBbkQsR0FDQWhMLFNBSkY7O0FBTUEsTUFBSyxDQUFDOG1CLEtBQU4sRUFBYztBQUNiLFFBQU1BLFFBQVEsRUFBUixFQUFZOW9CLFFBQVFuQixRQUFRMkosVUFBUixJQUFzQjNKLE9BQWhELEVBQXlELENBQUMyQixPQUFPUixNQUFNUyxDQUFOLENBQVIsS0FBcUIsSUFBOUUsRUFBb0ZBLEdBQXBGLEVBQTBGO0FBQ3pGLFFBQUssQ0FBQ3VNLEdBQUQsSUFBUXJPLE9BQU84RSxRQUFQLENBQWlCakQsSUFBakIsRUFBdUJ3TSxHQUF2QixDQUFiLEVBQTRDO0FBQzNDOGIsV0FBTTVxQixJQUFOLENBQVlzQyxJQUFaO0FBQ0EsS0FGRCxNQUVPO0FBQ043QixZQUFPdUIsS0FBUCxDQUFjNG9CLEtBQWQsRUFBcUJELE9BQVFyb0IsSUFBUixFQUFjd00sR0FBZCxDQUFyQjtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxTQUFPQSxRQUFRaEwsU0FBUixJQUFxQmdMLE9BQU9yTyxPQUFPOEUsUUFBUCxDQUFpQjVFLE9BQWpCLEVBQTBCbU8sR0FBMUIsQ0FBNUIsR0FDTnJPLE9BQU91QixLQUFQLENBQWMsQ0FBRXJCLE9BQUYsQ0FBZCxFQUEyQmlxQixLQUEzQixDQURNLEdBRU5BLEtBRkQ7QUFHQTs7QUFFRDtBQUNBLFVBQVNDLGlCQUFULENBQTRCdm9CLElBQTVCLEVBQW1DO0FBQ2xDLE1BQUt3ZSxlQUFldFYsSUFBZixDQUFxQmxKLEtBQUtrQyxJQUExQixDQUFMLEVBQXdDO0FBQ3ZDbEMsUUFBS3dvQixjQUFMLEdBQXNCeG9CLEtBQUswUSxPQUEzQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQVMrWCxrQkFBVCxDQUE2QnpvQixJQUE3QixFQUFtQzBvQixPQUFuQyxFQUE2QztBQUM1QyxTQUFPdnFCLE9BQU84RSxRQUFQLENBQWlCakQsSUFBakIsRUFBdUIsT0FBdkIsS0FDTjdCLE9BQU84RSxRQUFQLENBQWlCeWxCLFFBQVFqbUIsUUFBUixLQUFxQixFQUFyQixHQUEwQmltQixPQUExQixHQUFvQ0EsUUFBUXpjLFVBQTdELEVBQXlFLElBQXpFLENBRE0sR0FHTmpNLEtBQUsrSSxvQkFBTCxDQUEwQixPQUExQixFQUFtQyxDQUFuQyxLQUNDL0ksS0FBSzhMLFdBQUwsQ0FBa0I5TCxLQUFLMEksYUFBTCxDQUFtQjBCLGFBQW5CLENBQWlDLE9BQWpDLENBQWxCLENBSkssR0FLTnBLLElBTEQ7QUFNQTs7QUFFRDtBQUNBLFVBQVMyb0IsYUFBVCxDQUF3QjNvQixJQUF4QixFQUErQjtBQUM5QkEsT0FBS2tDLElBQUwsR0FBWSxDQUFDL0QsT0FBT2lPLElBQVAsQ0FBWXVCLElBQVosQ0FBa0IzTixJQUFsQixFQUF3QixNQUF4QixNQUFxQyxJQUF0QyxJQUE4QyxHQUE5QyxHQUFvREEsS0FBS2tDLElBQXJFO0FBQ0EsU0FBT2xDLElBQVA7QUFDQTtBQUNELFVBQVM0b0IsYUFBVCxDQUF3QjVvQixJQUF4QixFQUErQjtBQUM5QixNQUFJbUksUUFBUWdmLGtCQUFrQnhlLElBQWxCLENBQXdCM0ksS0FBS2tDLElBQTdCLENBQVo7QUFDQSxNQUFLaUcsS0FBTCxFQUFhO0FBQ1puSSxRQUFLa0MsSUFBTCxHQUFZaUcsTUFBTSxDQUFOLENBQVo7QUFDQSxHQUZELE1BRU87QUFDTm5JLFFBQUsySixlQUFMLENBQXFCLE1BQXJCO0FBQ0E7QUFDRCxTQUFPM0osSUFBUDtBQUNBOztBQUVEO0FBQ0EsVUFBUzZvQixhQUFULENBQXdCcnBCLEtBQXhCLEVBQStCc3BCLFdBQS9CLEVBQTZDO0FBQzVDLE1BQUk5b0IsSUFBSjtBQUFBLE1BQ0NDLElBQUksQ0FETDtBQUVBLFNBQVEsQ0FBQ0QsT0FBT1IsTUFBTVMsQ0FBTixDQUFSLEtBQXFCLElBQTdCLEVBQW1DQSxHQUFuQyxFQUF5QztBQUN4QzlCLFVBQU84ZSxLQUFQLENBQWNqZCxJQUFkLEVBQW9CLFlBQXBCLEVBQWtDLENBQUM4b0IsV0FBRCxJQUFnQjNxQixPQUFPOGUsS0FBUCxDQUFjNkwsWUFBWTdvQixDQUFaLENBQWQsRUFBOEIsWUFBOUIsQ0FBbEQ7QUFDQTtBQUNEOztBQUVELFVBQVM4b0IsY0FBVCxDQUF5QmxvQixHQUF6QixFQUE4Qm1vQixJQUE5QixFQUFxQzs7QUFFcEMsTUFBS0EsS0FBS3ZtQixRQUFMLEtBQWtCLENBQWxCLElBQXVCLENBQUN0RSxPQUFPNGUsT0FBUCxDQUFnQmxjLEdBQWhCLENBQTdCLEVBQXFEO0FBQ3BEO0FBQ0E7O0FBRUQsTUFBSXFCLElBQUo7QUFBQSxNQUFVakMsQ0FBVjtBQUFBLE1BQWFrVyxDQUFiO0FBQUEsTUFDQzhTLFVBQVU5cUIsT0FBTzhlLEtBQVAsQ0FBY3BjLEdBQWQsQ0FEWDtBQUFBLE1BRUNxb0IsVUFBVS9xQixPQUFPOGUsS0FBUCxDQUFjK0wsSUFBZCxFQUFvQkMsT0FBcEIsQ0FGWDtBQUFBLE1BR0M5SSxTQUFTOEksUUFBUTlJLE1BSGxCOztBQUtBLE1BQUtBLE1BQUwsRUFBYztBQUNiLFVBQU8rSSxRQUFRckksTUFBZjtBQUNBcUksV0FBUS9JLE1BQVIsR0FBaUIsRUFBakI7O0FBRUEsUUFBTWplLElBQU4sSUFBY2llLE1BQWQsRUFBdUI7QUFDdEIsU0FBTWxnQixJQUFJLENBQUosRUFBT2tXLElBQUlnSyxPQUFRamUsSUFBUixFQUFlaEQsTUFBaEMsRUFBd0NlLElBQUlrVyxDQUE1QyxFQUErQ2xXLEdBQS9DLEVBQXFEO0FBQ3BEOUIsWUFBT2lkLEtBQVAsQ0FBYTdFLEdBQWIsQ0FBa0J5UyxJQUFsQixFQUF3QjltQixJQUF4QixFQUE4QmllLE9BQVFqZSxJQUFSLEVBQWdCakMsQ0FBaEIsQ0FBOUI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFLaXBCLFFBQVFybUIsSUFBYixFQUFvQjtBQUNuQnFtQixXQUFRcm1CLElBQVIsR0FBZTFFLE9BQU95QyxNQUFQLENBQWUsRUFBZixFQUFtQnNvQixRQUFRcm1CLElBQTNCLENBQWY7QUFDQTtBQUNEOztBQUVELFVBQVNzbUIsa0JBQVQsQ0FBNkJ0b0IsR0FBN0IsRUFBa0Ntb0IsSUFBbEMsRUFBeUM7QUFDeEMsTUFBSS9sQixRQUFKLEVBQWNQLENBQWQsRUFBaUJHLElBQWpCOztBQUVBO0FBQ0EsTUFBS21tQixLQUFLdm1CLFFBQUwsS0FBa0IsQ0FBdkIsRUFBMkI7QUFDMUI7QUFDQTs7QUFFRFEsYUFBVytsQixLQUFLL2xCLFFBQUwsQ0FBY0MsV0FBZCxFQUFYOztBQUVBO0FBQ0EsTUFBSyxDQUFDakYsUUFBUW1oQixZQUFULElBQXlCNEosS0FBTTdxQixPQUFPc0QsT0FBYixDQUE5QixFQUF1RDtBQUN0RG9CLFVBQU8xRSxPQUFPOGUsS0FBUCxDQUFjK0wsSUFBZCxDQUFQOztBQUVBLFFBQU10bUIsQ0FBTixJQUFXRyxLQUFLc2QsTUFBaEIsRUFBeUI7QUFDeEJoaUIsV0FBT3FqQixXQUFQLENBQW9Cd0gsSUFBcEIsRUFBMEJ0bUIsQ0FBMUIsRUFBNkJHLEtBQUtnZSxNQUFsQztBQUNBOztBQUVEO0FBQ0FtSSxRQUFLcmYsZUFBTCxDQUFzQnhMLE9BQU9zRCxPQUE3QjtBQUNBOztBQUVEO0FBQ0EsTUFBS3dCLGFBQWEsUUFBYixJQUF5QitsQixLQUFLM2xCLElBQUwsS0FBY3hDLElBQUl3QyxJQUFoRCxFQUF1RDtBQUN0RHNsQixpQkFBZUssSUFBZixFQUFzQjNsQixJQUF0QixHQUE2QnhDLElBQUl3QyxJQUFqQztBQUNBdWxCLGlCQUFlSSxJQUFmOztBQUVEO0FBQ0E7QUFDQyxHQU5ELE1BTU8sSUFBSy9sQixhQUFhLFFBQWxCLEVBQTZCO0FBQ25DLE9BQUsrbEIsS0FBS25nQixVQUFWLEVBQXVCO0FBQ3RCbWdCLFNBQUtoSyxTQUFMLEdBQWlCbmUsSUFBSW1lLFNBQXJCO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFLL2dCLFFBQVE2Z0IsVUFBUixJQUF3QmplLElBQUltTCxTQUFKLElBQWlCLENBQUM3TixPQUFPSCxJQUFQLENBQVlnckIsS0FBS2hkLFNBQWpCLENBQS9DLEVBQStFO0FBQzlFZ2QsU0FBS2hkLFNBQUwsR0FBaUJuTCxJQUFJbUwsU0FBckI7QUFDQTtBQUVELEdBYk0sTUFhQSxJQUFLL0ksYUFBYSxPQUFiLElBQXdCdWIsZUFBZXRWLElBQWYsQ0FBcUJySSxJQUFJcUIsSUFBekIsQ0FBN0IsRUFBK0Q7QUFDckU7QUFDQTtBQUNBOztBQUVBOG1CLFFBQUtSLGNBQUwsR0FBc0JRLEtBQUt0WSxPQUFMLEdBQWU3UCxJQUFJNlAsT0FBekM7O0FBRUE7QUFDQTtBQUNBLE9BQUtzWSxLQUFLN2xCLEtBQUwsS0FBZXRDLElBQUlzQyxLQUF4QixFQUFnQztBQUMvQjZsQixTQUFLN2xCLEtBQUwsR0FBYXRDLElBQUlzQyxLQUFqQjtBQUNBOztBQUVGO0FBQ0E7QUFDQyxHQWZNLE1BZUEsSUFBS0YsYUFBYSxRQUFsQixFQUE2QjtBQUNuQytsQixRQUFLSSxlQUFMLEdBQXVCSixLQUFLclksUUFBTCxHQUFnQjlQLElBQUl1b0IsZUFBM0M7O0FBRUQ7QUFDQTtBQUNDLEdBTE0sTUFLQSxJQUFLbm1CLGFBQWEsT0FBYixJQUF3QkEsYUFBYSxVQUExQyxFQUF1RDtBQUM3RCtsQixRQUFLMVUsWUFBTCxHQUFvQnpULElBQUl5VCxZQUF4QjtBQUNBO0FBQ0Q7O0FBRURuVyxRQUFPeUMsTUFBUCxDQUFjO0FBQ2JNLFNBQU8sZUFBVWxCLElBQVYsRUFBZ0JxcEIsYUFBaEIsRUFBK0JDLGlCQUEvQixFQUFtRDtBQUN6RCxPQUFJQyxZQUFKO0FBQUEsT0FBa0JsZSxJQUFsQjtBQUFBLE9BQXdCbkssS0FBeEI7QUFBQSxPQUErQmpCLENBQS9CO0FBQUEsT0FBa0N1cEIsV0FBbEM7QUFBQSxPQUNDQyxTQUFTdHJCLE9BQU9tSCxRQUFQLENBQWlCdEYsS0FBSzBJLGFBQXRCLEVBQXFDMUksSUFBckMsQ0FEVjs7QUFHQSxPQUFLL0IsUUFBUTZnQixVQUFSLElBQXNCM2dCLE9BQU9xVyxRQUFQLENBQWdCeFUsSUFBaEIsQ0FBdEIsSUFBK0MsQ0FBQzBtQixhQUFheGQsSUFBYixDQUFtQixNQUFNbEosS0FBS2lELFFBQVgsR0FBc0IsR0FBekMsQ0FBckQsRUFBc0c7QUFDckcvQixZQUFRbEIsS0FBSytlLFNBQUwsQ0FBZ0IsSUFBaEIsQ0FBUjs7QUFFRDtBQUNDLElBSkQsTUFJTztBQUNOZ0osZ0JBQVkvYixTQUFaLEdBQXdCaE0sS0FBS2dmLFNBQTdCO0FBQ0ErSSxnQkFBWTFkLFdBQVosQ0FBeUJuSixRQUFRNm1CLFlBQVk5YixVQUE3QztBQUNBOztBQUVELE9BQUssQ0FBQyxDQUFDaE8sUUFBUW1oQixZQUFULElBQXlCLENBQUNuaEIsUUFBUWloQixjQUFuQyxNQUNGbGYsS0FBS3lDLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUJ6QyxLQUFLeUMsUUFBTCxLQUFrQixFQUR2QyxLQUM4QyxDQUFDdEUsT0FBT3FXLFFBQVAsQ0FBZ0J4VSxJQUFoQixDQURwRCxFQUM0RTs7QUFFM0U7QUFDQXVwQixtQkFBZWxCLE9BQVFubkIsS0FBUixDQUFmO0FBQ0Fzb0Isa0JBQWNuQixPQUFRcm9CLElBQVIsQ0FBZDs7QUFFQTtBQUNBLFNBQU1DLElBQUksQ0FBVixFQUFhLENBQUNvTCxPQUFPbWUsWUFBWXZwQixDQUFaLENBQVIsS0FBMkIsSUFBeEMsRUFBOEMsRUFBRUEsQ0FBaEQsRUFBb0Q7QUFDbkQ7QUFDQSxTQUFLc3BCLGFBQWF0cEIsQ0FBYixDQUFMLEVBQXVCO0FBQ3RCa3BCLHlCQUFvQjlkLElBQXBCLEVBQTBCa2UsYUFBYXRwQixDQUFiLENBQTFCO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0EsT0FBS29wQixhQUFMLEVBQXFCO0FBQ3BCLFFBQUtDLGlCQUFMLEVBQXlCO0FBQ3hCRSxtQkFBY0EsZUFBZW5CLE9BQVFyb0IsSUFBUixDQUE3QjtBQUNBdXBCLG9CQUFlQSxnQkFBZ0JsQixPQUFRbm5CLEtBQVIsQ0FBL0I7O0FBRUEsVUFBTWpCLElBQUksQ0FBVixFQUFhLENBQUNvTCxPQUFPbWUsWUFBWXZwQixDQUFaLENBQVIsS0FBMkIsSUFBeEMsRUFBOENBLEdBQTlDLEVBQW9EO0FBQ25EOG9CLHFCQUFnQjFkLElBQWhCLEVBQXNCa2UsYUFBYXRwQixDQUFiLENBQXRCO0FBQ0E7QUFDRCxLQVBELE1BT087QUFDTjhvQixvQkFBZ0Ivb0IsSUFBaEIsRUFBc0JrQixLQUF0QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQXFvQixrQkFBZWxCLE9BQVFubkIsS0FBUixFQUFlLFFBQWYsQ0FBZjtBQUNBLE9BQUtxb0IsYUFBYXJxQixNQUFiLEdBQXNCLENBQTNCLEVBQStCO0FBQzlCMnBCLGtCQUFlVSxZQUFmLEVBQTZCLENBQUNFLE1BQUQsSUFBV3BCLE9BQVFyb0IsSUFBUixFQUFjLFFBQWQsQ0FBeEM7QUFDQTs7QUFFRHVwQixrQkFBZUMsY0FBY25lLE9BQU8sSUFBcEM7O0FBRUE7QUFDQSxVQUFPbkssS0FBUDtBQUNBLEdBdERZOztBQXdEYndvQixpQkFBZSx1QkFBVWxxQixLQUFWLEVBQWlCbkIsT0FBakIsRUFBMEJzckIsT0FBMUIsRUFBbUNDLFNBQW5DLEVBQStDO0FBQzdELE9BQUlwcEIsQ0FBSjtBQUFBLE9BQU9SLElBQVA7QUFBQSxPQUFhc0YsUUFBYjtBQUFBLE9BQ0NqQixHQUREO0FBQUEsT0FDTW1JLEdBRE47QUFBQSxPQUNXb1MsS0FEWDtBQUFBLE9BQ2tCaUwsSUFEbEI7QUFBQSxPQUVDMVQsSUFBSTNXLE1BQU1OLE1BRlg7OztBQUlDO0FBQ0E0cUIsVUFBT3hELG1CQUFvQmpvQixPQUFwQixDQUxSO0FBQUEsT0FPQzByQixRQUFRLEVBUFQ7QUFBQSxPQVFDOXBCLElBQUksQ0FSTDs7QUFVQSxVQUFRQSxJQUFJa1csQ0FBWixFQUFlbFcsR0FBZixFQUFxQjtBQUNwQkQsV0FBT1IsTUFBT1MsQ0FBUCxDQUFQOztBQUVBLFFBQUtELFFBQVFBLFNBQVMsQ0FBdEIsRUFBMEI7O0FBRXpCO0FBQ0EsU0FBSzdCLE9BQU8rRCxJQUFQLENBQWFsQyxJQUFiLE1BQXdCLFFBQTdCLEVBQXdDO0FBQ3ZDN0IsYUFBT3VCLEtBQVAsQ0FBY3FxQixLQUFkLEVBQXFCL3BCLEtBQUt5QyxRQUFMLEdBQWdCLENBQUV6QyxJQUFGLENBQWhCLEdBQTJCQSxJQUFoRDs7QUFFRDtBQUNDLE1BSkQsTUFJTyxJQUFLLENBQUMrbUIsTUFBTTdkLElBQU4sQ0FBWWxKLElBQVosQ0FBTixFQUEyQjtBQUNqQytwQixZQUFNcnNCLElBQU4sQ0FBWVcsUUFBUTJyQixjQUFSLENBQXdCaHFCLElBQXhCLENBQVo7O0FBRUQ7QUFDQyxNQUpNLE1BSUE7QUFDTnFFLFlBQU1BLE9BQU95bEIsS0FBS2hlLFdBQUwsQ0FBa0J6TixRQUFRK0wsYUFBUixDQUFzQixLQUF0QixDQUFsQixDQUFiOztBQUVBO0FBQ0FvQyxZQUFNLENBQUNxYSxTQUFTbGUsSUFBVCxDQUFlM0ksSUFBZixLQUF5QixDQUFFLEVBQUYsRUFBTSxFQUFOLENBQTFCLEVBQXVDLENBQXZDLEVBQTJDa0QsV0FBM0MsRUFBTjtBQUNBMm1CLGFBQU94QyxRQUFTN2EsR0FBVCxLQUFrQjZhLFFBQVFoRixRQUFqQzs7QUFFQWhlLFVBQUkySCxTQUFKLEdBQWdCNmQsS0FBSyxDQUFMLElBQVU3cEIsS0FBSzRCLE9BQUwsQ0FBY2dsQixTQUFkLEVBQXlCLFdBQXpCLENBQVYsR0FBbURpRCxLQUFLLENBQUwsQ0FBbkU7O0FBRUE7QUFDQXJwQixVQUFJcXBCLEtBQUssQ0FBTCxDQUFKO0FBQ0EsYUFBUXJwQixHQUFSLEVBQWM7QUFDYjZELGFBQU1BLElBQUlvTCxTQUFWO0FBQ0E7O0FBRUQ7QUFDQSxVQUFLLENBQUN4UixRQUFRMGdCLGlCQUFULElBQThCZ0ksbUJBQW1CemQsSUFBbkIsQ0FBeUJsSixJQUF6QixDQUFuQyxFQUFxRTtBQUNwRStwQixhQUFNcnNCLElBQU4sQ0FBWVcsUUFBUTJyQixjQUFSLENBQXdCckQsbUJBQW1CaGUsSUFBbkIsQ0FBeUIzSSxJQUF6QixFQUFnQyxDQUFoQyxDQUF4QixDQUFaO0FBQ0E7O0FBRUQ7QUFDQSxVQUFLLENBQUMvQixRQUFRMmdCLEtBQWQsRUFBc0I7O0FBRXJCO0FBQ0E1ZSxjQUFPd00sUUFBUSxPQUFSLElBQW1CLENBQUNzYSxPQUFPNWQsSUFBUCxDQUFhbEosSUFBYixDQUFwQixHQUNOcUUsSUFBSTRILFVBREU7O0FBR047QUFDQTRkLFlBQUssQ0FBTCxNQUFZLFNBQVosSUFBeUIsQ0FBQy9DLE9BQU81ZCxJQUFQLENBQWFsSixJQUFiLENBQTFCLEdBQ0NxRSxHQURELEdBRUMsQ0FORjs7QUFRQTdELFdBQUlSLFFBQVFBLEtBQUtnSSxVQUFMLENBQWdCOUksTUFBNUI7QUFDQSxjQUFRc0IsR0FBUixFQUFjO0FBQ2IsWUFBS3JDLE9BQU84RSxRQUFQLENBQWtCMmIsUUFBUTVlLEtBQUtnSSxVQUFMLENBQWdCeEgsQ0FBaEIsQ0FBMUIsRUFBK0MsT0FBL0MsS0FBNEQsQ0FBQ29lLE1BQU01VyxVQUFOLENBQWlCOUksTUFBbkYsRUFBNEY7QUFDM0ZjLGNBQUtxSyxXQUFMLENBQWtCdVUsS0FBbEI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUR6Z0IsYUFBT3VCLEtBQVAsQ0FBY3FxQixLQUFkLEVBQXFCMWxCLElBQUkyRCxVQUF6Qjs7QUFFQTtBQUNBM0QsVUFBSTZKLFdBQUosR0FBa0IsRUFBbEI7O0FBRUE7QUFDQSxhQUFRN0osSUFBSTRILFVBQVosRUFBeUI7QUFDeEI1SCxXQUFJZ0csV0FBSixDQUFpQmhHLElBQUk0SCxVQUFyQjtBQUNBOztBQUVEO0FBQ0E1SCxZQUFNeWxCLEtBQUtyYSxTQUFYO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0EsT0FBS3BMLEdBQUwsRUFBVztBQUNWeWxCLFNBQUt6ZixXQUFMLENBQWtCaEcsR0FBbEI7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsT0FBSyxDQUFDcEcsUUFBUWdoQixhQUFkLEVBQThCO0FBQzdCOWdCLFdBQU8wRixJQUFQLENBQWF3a0IsT0FBUTBCLEtBQVIsRUFBZSxPQUFmLENBQWIsRUFBdUN4QixpQkFBdkM7QUFDQTs7QUFFRHRvQixPQUFJLENBQUo7QUFDQSxVQUFTRCxPQUFPK3BCLE1BQU85cEIsR0FBUCxDQUFoQixFQUFnQzs7QUFFL0I7QUFDQTtBQUNBLFFBQUsycEIsYUFBYXpyQixPQUFPdUYsT0FBUCxDQUFnQjFELElBQWhCLEVBQXNCNHBCLFNBQXRCLE1BQXNDLENBQUMsQ0FBekQsRUFBNkQ7QUFDNUQ7QUFDQTs7QUFFRHRrQixlQUFXbkgsT0FBT21ILFFBQVAsQ0FBaUJ0RixLQUFLMEksYUFBdEIsRUFBcUMxSSxJQUFyQyxDQUFYOztBQUVBO0FBQ0FxRSxVQUFNZ2tCLE9BQVF5QixLQUFLaGUsV0FBTCxDQUFrQjlMLElBQWxCLENBQVIsRUFBa0MsUUFBbEMsQ0FBTjs7QUFFQTtBQUNBLFFBQUtzRixRQUFMLEVBQWdCO0FBQ2Z1akIsbUJBQWV4a0IsR0FBZjtBQUNBOztBQUVEO0FBQ0EsUUFBS3NsQixPQUFMLEVBQWU7QUFDZG5wQixTQUFJLENBQUo7QUFDQSxZQUFTUixPQUFPcUUsSUFBSzdELEdBQUwsQ0FBaEIsRUFBOEI7QUFDN0IsVUFBSzBtQixZQUFZaGUsSUFBWixDQUFrQmxKLEtBQUtrQyxJQUFMLElBQWEsRUFBL0IsQ0FBTCxFQUEyQztBQUMxQ3luQixlQUFRanNCLElBQVIsQ0FBY3NDLElBQWQ7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRHFFLFNBQU0sSUFBTjs7QUFFQSxVQUFPeWxCLElBQVA7QUFDQSxHQXJMWTs7QUF1TGJoTixhQUFXLG1CQUFVdGQsS0FBVixFQUFpQixjQUFld2MsVUFBaEMsRUFBNkM7QUFDdkQsT0FBSWhjLElBQUo7QUFBQSxPQUFVa0MsSUFBVjtBQUFBLE9BQWdCNEcsRUFBaEI7QUFBQSxPQUFvQmpHLElBQXBCO0FBQUEsT0FDQzVDLElBQUksQ0FETDtBQUFBLE9BRUN5YyxjQUFjdmUsT0FBT3NELE9BRnRCO0FBQUEsT0FHQ3FJLFFBQVEzTCxPQUFPMkwsS0FIaEI7QUFBQSxPQUlDaVMsZ0JBQWdCOWQsUUFBUThkLGFBSnpCO0FBQUEsT0FLQ3VFLFVBQVVuaUIsT0FBT2lkLEtBQVAsQ0FBYWtGLE9BTHhCOztBQU9BLFVBQVEsQ0FBQ3RnQixPQUFPUixNQUFNUyxDQUFOLENBQVIsS0FBcUIsSUFBN0IsRUFBbUNBLEdBQW5DLEVBQXlDO0FBQ3hDLFFBQUsrYixjQUFjN2QsT0FBTzZkLFVBQVAsQ0FBbUJoYyxJQUFuQixDQUFuQixFQUErQzs7QUFFOUM4SSxVQUFLOUksS0FBTTBjLFdBQU4sQ0FBTDtBQUNBN1osWUFBT2lHLE1BQU1nQixNQUFPaEIsRUFBUCxDQUFiOztBQUVBLFNBQUtqRyxJQUFMLEVBQVk7QUFDWCxVQUFLQSxLQUFLc2QsTUFBVixFQUFtQjtBQUNsQixZQUFNamUsSUFBTixJQUFjVyxLQUFLc2QsTUFBbkIsRUFBNEI7QUFDM0IsWUFBS0csUUFBU3BlLElBQVQsQ0FBTCxFQUF1QjtBQUN0Qi9ELGdCQUFPaWQsS0FBUCxDQUFhaEQsTUFBYixDQUFxQnBZLElBQXJCLEVBQTJCa0MsSUFBM0I7O0FBRUQ7QUFDQyxTQUpELE1BSU87QUFDTi9ELGdCQUFPcWpCLFdBQVAsQ0FBb0J4aEIsSUFBcEIsRUFBMEJrQyxJQUExQixFQUFnQ1csS0FBS2dlLE1BQXJDO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0EsVUFBSy9XLE1BQU9oQixFQUFQLENBQUwsRUFBbUI7O0FBRWxCLGNBQU9nQixNQUFPaEIsRUFBUCxDQUFQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQUtpVCxhQUFMLEVBQXFCO0FBQ3BCLGVBQU8vYixLQUFNMGMsV0FBTixDQUFQO0FBRUEsUUFIRCxNQUdPLElBQUssUUFBTzFjLEtBQUsySixlQUFaLE1BQWdDMUQsWUFBckMsRUFBb0Q7QUFDMURqRyxhQUFLMkosZUFBTCxDQUFzQitTLFdBQXRCO0FBRUEsUUFITSxNQUdBO0FBQ04xYyxhQUFNMGMsV0FBTixJQUFzQixJQUF0QjtBQUNBOztBQUVEbmYsa0JBQVdHLElBQVgsQ0FBaUJvTCxFQUFqQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUF6T1ksRUFBZDs7QUE0T0EzSyxRQUFPRyxFQUFQLENBQVVzQyxNQUFWLENBQWlCO0FBQ2hCeUMsUUFBTSxjQUFVRixLQUFWLEVBQWtCO0FBQ3ZCLFVBQU9nYixPQUFRLElBQVIsRUFBYyxVQUFVaGIsS0FBVixFQUFrQjtBQUN0QyxXQUFPQSxVQUFVM0IsU0FBVixHQUNOckQsT0FBT2tGLElBQVAsQ0FBYSxJQUFiLENBRE0sR0FFTixLQUFLZ1YsS0FBTCxHQUFhNFIsTUFBYixDQUFxQixDQUFFLEtBQUssQ0FBTCxLQUFXLEtBQUssQ0FBTCxFQUFRdmhCLGFBQW5CLElBQW9DeEwsUUFBdEMsRUFBaUQ4c0IsY0FBakQsQ0FBaUU3bUIsS0FBakUsQ0FBckIsQ0FGRDtBQUdBLElBSk0sRUFJSixJQUpJLEVBSUVBLEtBSkYsRUFJU2hELFVBQVVqQixNQUpuQixDQUFQO0FBS0EsR0FQZTs7QUFTaEIrcUIsVUFBUSxrQkFBVztBQUNsQixVQUFPLEtBQUtDLFFBQUwsQ0FBZS9wQixTQUFmLEVBQTBCLFVBQVVILElBQVYsRUFBaUI7QUFDakQsUUFBSyxLQUFLeUMsUUFBTCxLQUFrQixDQUFsQixJQUF1QixLQUFLQSxRQUFMLEtBQWtCLEVBQXpDLElBQStDLEtBQUtBLFFBQUwsS0FBa0IsQ0FBdEUsRUFBMEU7QUFDekUsU0FBSXRCLFNBQVNzbkIsbUJBQW9CLElBQXBCLEVBQTBCem9CLElBQTFCLENBQWI7QUFDQW1CLFlBQU8ySyxXQUFQLENBQW9COUwsSUFBcEI7QUFDQTtBQUNELElBTE0sQ0FBUDtBQU1BLEdBaEJlOztBQWtCaEJtcUIsV0FBUyxtQkFBVztBQUNuQixVQUFPLEtBQUtELFFBQUwsQ0FBZS9wQixTQUFmLEVBQTBCLFVBQVVILElBQVYsRUFBaUI7QUFDakQsUUFBSyxLQUFLeUMsUUFBTCxLQUFrQixDQUFsQixJQUF1QixLQUFLQSxRQUFMLEtBQWtCLEVBQXpDLElBQStDLEtBQUtBLFFBQUwsS0FBa0IsQ0FBdEUsRUFBMEU7QUFDekUsU0FBSXRCLFNBQVNzbkIsbUJBQW9CLElBQXBCLEVBQTBCem9CLElBQTFCLENBQWI7QUFDQW1CLFlBQU9pcEIsWUFBUCxDQUFxQnBxQixJQUFyQixFQUEyQm1CLE9BQU84SyxVQUFsQztBQUNBO0FBQ0QsSUFMTSxDQUFQO0FBTUEsR0F6QmU7O0FBMkJoQm9lLFVBQVEsa0JBQVc7QUFDbEIsVUFBTyxLQUFLSCxRQUFMLENBQWUvcEIsU0FBZixFQUEwQixVQUFVSCxJQUFWLEVBQWlCO0FBQ2pELFFBQUssS0FBSzZJLFVBQVYsRUFBdUI7QUFDdEIsVUFBS0EsVUFBTCxDQUFnQnVoQixZQUFoQixDQUE4QnBxQixJQUE5QixFQUFvQyxJQUFwQztBQUNBO0FBQ0QsSUFKTSxDQUFQO0FBS0EsR0FqQ2U7O0FBbUNoQnNxQixTQUFPLGlCQUFXO0FBQ2pCLFVBQU8sS0FBS0osUUFBTCxDQUFlL3BCLFNBQWYsRUFBMEIsVUFBVUgsSUFBVixFQUFpQjtBQUNqRCxRQUFLLEtBQUs2SSxVQUFWLEVBQXVCO0FBQ3RCLFVBQUtBLFVBQUwsQ0FBZ0J1aEIsWUFBaEIsQ0FBOEJwcUIsSUFBOUIsRUFBb0MsS0FBSzhLLFdBQXpDO0FBQ0E7QUFDRCxJQUpNLENBQVA7QUFLQSxHQXpDZTs7QUEyQ2hCc04sVUFBUSxnQkFBVWhhLFFBQVYsRUFBb0Jtc0IsUUFBcEIsQ0FBNkIsdUJBQTdCLEVBQXVEO0FBQzlELE9BQUl2cUIsSUFBSjtBQUFBLE9BQ0NSLFFBQVFwQixXQUFXRCxPQUFPa08sTUFBUCxDQUFlak8sUUFBZixFQUF5QixJQUF6QixDQUFYLEdBQTZDLElBRHREO0FBQUEsT0FFQzZCLElBQUksQ0FGTDs7QUFJQSxVQUFRLENBQUNELE9BQU9SLE1BQU1TLENBQU4sQ0FBUixLQUFxQixJQUE3QixFQUFtQ0EsR0FBbkMsRUFBeUM7O0FBRXhDLFFBQUssQ0FBQ3NxQixRQUFELElBQWF2cUIsS0FBS3lDLFFBQUwsS0FBa0IsQ0FBcEMsRUFBd0M7QUFDdkN0RSxZQUFPMmUsU0FBUCxDQUFrQnVMLE9BQVFyb0IsSUFBUixDQUFsQjtBQUNBOztBQUVELFFBQUtBLEtBQUs2SSxVQUFWLEVBQXVCO0FBQ3RCLFNBQUswaEIsWUFBWXBzQixPQUFPbUgsUUFBUCxDQUFpQnRGLEtBQUswSSxhQUF0QixFQUFxQzFJLElBQXJDLENBQWpCLEVBQStEO0FBQzlENm9CLG9CQUFlUixPQUFRcm9CLElBQVIsRUFBYyxRQUFkLENBQWY7QUFDQTtBQUNEQSxVQUFLNkksVUFBTCxDQUFnQndCLFdBQWhCLENBQTZCckssSUFBN0I7QUFDQTtBQUNEOztBQUVELFVBQU8sSUFBUDtBQUNBLEdBL0RlOztBQWlFaEJxWSxTQUFPLGlCQUFXO0FBQ2pCLE9BQUlyWSxJQUFKO0FBQUEsT0FDQ0MsSUFBSSxDQURMOztBQUdBLFVBQVEsQ0FBQ0QsT0FBTyxLQUFLQyxDQUFMLENBQVIsS0FBb0IsSUFBNUIsRUFBa0NBLEdBQWxDLEVBQXdDO0FBQ3ZDO0FBQ0EsUUFBS0QsS0FBS3lDLFFBQUwsS0FBa0IsQ0FBdkIsRUFBMkI7QUFDMUJ0RSxZQUFPMmUsU0FBUCxDQUFrQnVMLE9BQVFyb0IsSUFBUixFQUFjLEtBQWQsQ0FBbEI7QUFDQTs7QUFFRDtBQUNBLFdBQVFBLEtBQUtpTSxVQUFiLEVBQTBCO0FBQ3pCak0sVUFBS3FLLFdBQUwsQ0FBa0JySyxLQUFLaU0sVUFBdkI7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsUUFBS2pNLEtBQUtpQixPQUFMLElBQWdCOUMsT0FBTzhFLFFBQVAsQ0FBaUJqRCxJQUFqQixFQUF1QixRQUF2QixDQUFyQixFQUF5RDtBQUN4REEsVUFBS2lCLE9BQUwsQ0FBYS9CLE1BQWIsR0FBc0IsQ0FBdEI7QUFDQTtBQUNEOztBQUVELFVBQU8sSUFBUDtBQUNBLEdBeEZlOztBQTBGaEJnQyxTQUFPLGVBQVVtb0IsYUFBVixFQUF5QkMsaUJBQXpCLEVBQTZDO0FBQ25ERCxtQkFBZ0JBLGlCQUFpQixJQUFqQixHQUF3QixLQUF4QixHQUFnQ0EsYUFBaEQ7QUFDQUMsdUJBQW9CQSxxQkFBcUIsSUFBckIsR0FBNEJELGFBQTVCLEdBQTRDQyxpQkFBaEU7O0FBRUEsVUFBTyxLQUFLdnBCLEdBQUwsQ0FBUyxZQUFXO0FBQzFCLFdBQU81QixPQUFPK0MsS0FBUCxDQUFjLElBQWQsRUFBb0Jtb0IsYUFBcEIsRUFBbUNDLGlCQUFuQyxDQUFQO0FBQ0EsSUFGTSxDQUFQO0FBR0EsR0FqR2U7O0FBbUdoQmtCLFFBQU0sY0FBVXJuQixLQUFWLEVBQWtCO0FBQ3ZCLFVBQU9nYixPQUFRLElBQVIsRUFBYyxVQUFVaGIsS0FBVixFQUFrQjtBQUN0QyxRQUFJbkQsT0FBTyxLQUFNLENBQU4sS0FBYSxFQUF4QjtBQUFBLFFBQ0NDLElBQUksQ0FETDtBQUFBLFFBRUNrVyxJQUFJLEtBQUtqWCxNQUZWOztBQUlBLFFBQUtpRSxVQUFVM0IsU0FBZixFQUEyQjtBQUMxQixZQUFPeEIsS0FBS3lDLFFBQUwsS0FBa0IsQ0FBbEIsR0FDTnpDLEtBQUtnTSxTQUFMLENBQWVwSyxPQUFmLENBQXdCNmtCLGFBQXhCLEVBQXVDLEVBQXZDLENBRE0sR0FFTmpsQixTQUZEO0FBR0E7O0FBRUQ7QUFDQSxRQUFLLE9BQU8yQixLQUFQLEtBQWlCLFFBQWpCLElBQTZCLENBQUM2akIsYUFBYTlkLElBQWIsQ0FBbUIvRixLQUFuQixDQUE5QixLQUNGbEYsUUFBUTRnQixhQUFSLElBQXlCLENBQUM2SCxhQUFheGQsSUFBYixDQUFtQi9GLEtBQW5CLENBRHhCLE1BRUZsRixRQUFRMGdCLGlCQUFSLElBQTZCLENBQUNnSSxtQkFBbUJ6ZCxJQUFuQixDQUF5Qi9GLEtBQXpCLENBRjVCLEtBR0osQ0FBQ2trQixRQUFTLENBQUNSLFNBQVNsZSxJQUFULENBQWV4RixLQUFmLEtBQTBCLENBQUUsRUFBRixFQUFNLEVBQU4sQ0FBM0IsRUFBd0MsQ0FBeEMsRUFBNENELFdBQTVDLEVBQVQsQ0FIRixFQUd5RTs7QUFFeEVDLGFBQVFBLE1BQU12QixPQUFOLENBQWVnbEIsU0FBZixFQUEwQixXQUExQixDQUFSOztBQUVBLFNBQUk7QUFDSCxhQUFPM21CLElBQUlrVyxDQUFYLEVBQWNsVyxHQUFkLEVBQW9CO0FBQ25CO0FBQ0FELGNBQU8sS0FBS0MsQ0FBTCxLQUFXLEVBQWxCO0FBQ0EsV0FBS0QsS0FBS3lDLFFBQUwsS0FBa0IsQ0FBdkIsRUFBMkI7QUFDMUJ0RSxlQUFPMmUsU0FBUCxDQUFrQnVMLE9BQVFyb0IsSUFBUixFQUFjLEtBQWQsQ0FBbEI7QUFDQUEsYUFBS2dNLFNBQUwsR0FBaUI3SSxLQUFqQjtBQUNBO0FBQ0Q7O0FBRURuRCxhQUFPLENBQVA7O0FBRUQ7QUFDQyxNQWJELENBYUUsT0FBTTBDLENBQU4sRUFBUyxDQUFFO0FBQ2I7O0FBRUQsUUFBSzFDLElBQUwsRUFBWTtBQUNYLFVBQUtxWSxLQUFMLEdBQWE0UixNQUFiLENBQXFCOW1CLEtBQXJCO0FBQ0E7QUFDRCxJQXRDTSxFQXNDSixJQXRDSSxFQXNDRUEsS0F0Q0YsRUFzQ1NoRCxVQUFVakIsTUF0Q25CLENBQVA7QUF1Q0EsR0EzSWU7O0FBNkloQnVyQixlQUFhLHVCQUFXO0FBQ3ZCLE9BQUl2bUIsTUFBTS9ELFVBQVcsQ0FBWCxDQUFWOztBQUVBO0FBQ0EsUUFBSytwQixRQUFMLENBQWUvcEIsU0FBZixFQUEwQixVQUFVSCxJQUFWLEVBQWlCO0FBQzFDa0UsVUFBTSxLQUFLMkUsVUFBWDs7QUFFQTFLLFdBQU8yZSxTQUFQLENBQWtCdUwsT0FBUSxJQUFSLENBQWxCOztBQUVBLFFBQUtua0IsR0FBTCxFQUFXO0FBQ1ZBLFNBQUl3bUIsWUFBSixDQUFrQjFxQixJQUFsQixFQUF3QixJQUF4QjtBQUNBO0FBQ0QsSUFSRDs7QUFVQTtBQUNBLFVBQU9rRSxRQUFRQSxJQUFJaEYsTUFBSixJQUFjZ0YsSUFBSXpCLFFBQTFCLElBQXNDLElBQXRDLEdBQTZDLEtBQUsyVixNQUFMLEVBQXBEO0FBQ0EsR0E3SmU7O0FBK0poQjRDLFVBQVEsZ0JBQVU1YyxRQUFWLEVBQXFCO0FBQzVCLFVBQU8sS0FBS2dhLE1BQUwsQ0FBYWhhLFFBQWIsRUFBdUIsSUFBdkIsQ0FBUDtBQUNBLEdBaktlOztBQW1LaEI4ckIsWUFBVSxrQkFBVXBxQixJQUFWLEVBQWdCRCxRQUFoQixFQUEyQjs7QUFFcEM7QUFDQUMsVUFBT3JDLE9BQU95QyxLQUFQLENBQWMsRUFBZCxFQUFrQkosSUFBbEIsQ0FBUDs7QUFFQSxPQUFJTSxLQUFKO0FBQUEsT0FBV2lMLElBQVg7QUFBQSxPQUFpQnNmLFVBQWpCO0FBQUEsT0FDQ2hCLE9BREQ7QUFBQSxPQUNVcGUsR0FEVjtBQUFBLE9BQ2VrVCxRQURmO0FBQUEsT0FFQ3hlLElBQUksQ0FGTDtBQUFBLE9BR0NrVyxJQUFJLEtBQUtqWCxNQUhWO0FBQUEsT0FJQzByQixNQUFNLElBSlA7QUFBQSxPQUtDQyxXQUFXMVUsSUFBSSxDQUxoQjtBQUFBLE9BTUNoVCxRQUFRckQsS0FBSyxDQUFMLENBTlQ7QUFBQSxPQU9DdUIsYUFBYWxELE9BQU9rRCxVQUFQLENBQW1COEIsS0FBbkIsQ0FQZDs7QUFTQTtBQUNBLE9BQUs5QixjQUNEOFUsSUFBSSxDQUFKLElBQVMsT0FBT2hULEtBQVAsS0FBaUIsUUFBMUIsSUFDRCxDQUFDbEYsUUFBUWtoQixVQURSLElBQ3NCOEgsU0FBUy9kLElBQVQsQ0FBZS9GLEtBQWYsQ0FGMUIsRUFFcUQ7QUFDcEQsV0FBTyxLQUFLdkQsSUFBTCxDQUFVLFVBQVV5VyxLQUFWLEVBQWtCO0FBQ2xDLFNBQUlyQixPQUFPNFYsSUFBSXZxQixFQUFKLENBQVFnVyxLQUFSLENBQVg7QUFDQSxTQUFLaFYsVUFBTCxFQUFrQjtBQUNqQnZCLFdBQUssQ0FBTCxJQUFVcUQsTUFBTS9ELElBQU4sQ0FBWSxJQUFaLEVBQWtCaVgsS0FBbEIsRUFBeUJyQixLQUFLd1YsSUFBTCxFQUF6QixDQUFWO0FBQ0E7QUFDRHhWLFVBQUtrVixRQUFMLENBQWVwcUIsSUFBZixFQUFxQkQsUUFBckI7QUFDQSxLQU5NLENBQVA7QUFPQTs7QUFFRCxPQUFLc1csQ0FBTCxFQUFTO0FBQ1JzSSxlQUFXdGdCLE9BQU91ckIsYUFBUCxDQUFzQjVwQixJQUF0QixFQUE0QixLQUFNLENBQU4sRUFBVTRJLGFBQXRDLEVBQXFELEtBQXJELEVBQTRELElBQTVELENBQVg7QUFDQXRJLFlBQVFxZSxTQUFTeFMsVUFBakI7O0FBRUEsUUFBS3dTLFNBQVN6VyxVQUFULENBQW9COUksTUFBcEIsS0FBK0IsQ0FBcEMsRUFBd0M7QUFDdkN1ZixnQkFBV3JlLEtBQVg7QUFDQTs7QUFFRCxRQUFLQSxLQUFMLEVBQWE7QUFDWnVwQixlQUFVeHJCLE9BQU80QixHQUFQLENBQVlzb0IsT0FBUTVKLFFBQVIsRUFBa0IsUUFBbEIsQ0FBWixFQUEwQ2tLLGFBQTFDLENBQVY7QUFDQWdDLGtCQUFhaEIsUUFBUXpxQixNQUFyQjs7QUFFQTtBQUNBO0FBQ0EsWUFBUWUsSUFBSWtXLENBQVosRUFBZWxXLEdBQWYsRUFBcUI7QUFDcEJvTCxhQUFPb1QsUUFBUDs7QUFFQSxVQUFLeGUsTUFBTTRxQixRQUFYLEVBQXNCO0FBQ3JCeGYsY0FBT2xOLE9BQU8rQyxLQUFQLENBQWNtSyxJQUFkLEVBQW9CLElBQXBCLEVBQTBCLElBQTFCLENBQVA7O0FBRUE7QUFDQSxXQUFLc2YsVUFBTCxFQUFrQjtBQUNqQnhzQixlQUFPdUIsS0FBUCxDQUFjaXFCLE9BQWQsRUFBdUJ0QixPQUFRaGQsSUFBUixFQUFjLFFBQWQsQ0FBdkI7QUFDQTtBQUNEOztBQUVEeEwsZUFBU1QsSUFBVCxDQUFlLEtBQUthLENBQUwsQ0FBZixFQUF3Qm9MLElBQXhCLEVBQThCcEwsQ0FBOUI7QUFDQTs7QUFFRCxTQUFLMHFCLFVBQUwsRUFBa0I7QUFDakJwZixZQUFNb2UsUUFBU0EsUUFBUXpxQixNQUFSLEdBQWlCLENBQTFCLEVBQThCd0osYUFBcEM7O0FBRUE7QUFDQXZLLGFBQU80QixHQUFQLENBQVk0cEIsT0FBWixFQUFxQmYsYUFBckI7O0FBRUE7QUFDQSxXQUFNM29CLElBQUksQ0FBVixFQUFhQSxJQUFJMHFCLFVBQWpCLEVBQTZCMXFCLEdBQTdCLEVBQW1DO0FBQ2xDb0wsY0FBT3NlLFFBQVMxcEIsQ0FBVCxDQUFQO0FBQ0EsV0FBS2luQixZQUFZaGUsSUFBWixDQUFrQm1DLEtBQUtuSixJQUFMLElBQWEsRUFBL0IsS0FDSixDQUFDL0QsT0FBTzhlLEtBQVAsQ0FBYzVSLElBQWQsRUFBb0IsWUFBcEIsQ0FERyxJQUNtQ2xOLE9BQU9tSCxRQUFQLENBQWlCaUcsR0FBakIsRUFBc0JGLElBQXRCLENBRHhDLEVBQ3VFOztBQUV0RSxZQUFLQSxLQUFLeEssR0FBVixFQUFnQjtBQUNmO0FBQ0EsYUFBSzFDLE9BQU8yc0IsUUFBWixFQUF1QjtBQUN0QjNzQixpQkFBTzJzQixRQUFQLENBQWlCemYsS0FBS3hLLEdBQXRCO0FBQ0E7QUFDRCxTQUxELE1BS087QUFDTjFDLGdCQUFPeUUsVUFBUCxDQUFtQixDQUFFeUksS0FBS2hJLElBQUwsSUFBYWdJLEtBQUs2QyxXQUFsQixJQUFpQzdDLEtBQUtXLFNBQXRDLElBQW1ELEVBQXJELEVBQTBEcEssT0FBMUQsQ0FBbUV3bEIsWUFBbkUsRUFBaUYsRUFBakYsQ0FBbkI7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBM0ksZ0JBQVdyZSxRQUFRLElBQW5CO0FBQ0E7QUFDRDs7QUFFRCxVQUFPLElBQVA7QUFDQTtBQXpQZSxFQUFqQjs7QUE0UEFqQyxRQUFPeUIsSUFBUCxDQUFZO0FBQ1htckIsWUFBVSxRQURDO0FBRVhDLGFBQVcsU0FGQTtBQUdYWixnQkFBYyxRQUhIO0FBSVhhLGVBQWEsT0FKRjtBQUtYQyxjQUFZO0FBTEQsRUFBWixFQU1HLFVBQVVscUIsSUFBVixFQUFnQnlpQixRQUFoQixFQUEyQjtBQUM3QnRsQixTQUFPRyxFQUFQLENBQVcwQyxJQUFYLElBQW9CLFVBQVU1QyxRQUFWLEVBQXFCO0FBQ3hDLE9BQUlvQixLQUFKO0FBQUEsT0FDQ1MsSUFBSSxDQURMO0FBQUEsT0FFQ1IsTUFBTSxFQUZQO0FBQUEsT0FHQzByQixTQUFTaHRCLE9BQVFDLFFBQVIsQ0FIVjtBQUFBLE9BSUNrQyxPQUFPNnFCLE9BQU9qc0IsTUFBUCxHQUFnQixDQUp4Qjs7QUFNQSxVQUFRZSxLQUFLSyxJQUFiLEVBQW1CTCxHQUFuQixFQUF5QjtBQUN4QlQsWUFBUVMsTUFBTUssSUFBTixHQUFhLElBQWIsR0FBb0IsS0FBS1ksS0FBTCxDQUFXLElBQVgsQ0FBNUI7QUFDQS9DLFdBQVFndEIsT0FBT2xyQixDQUFQLENBQVIsRUFBcUJ3akIsUUFBckIsRUFBaUNqa0IsS0FBakM7O0FBRUE7QUFDQTlCLFNBQUt3QyxLQUFMLENBQVlULEdBQVosRUFBaUJELE1BQU1ILEdBQU4sRUFBakI7QUFDQTs7QUFFRCxVQUFPLEtBQUtFLFNBQUwsQ0FBZ0JFLEdBQWhCLENBQVA7QUFDQSxHQWhCRDtBQWlCQSxFQXhCRDs7QUEyQkEsS0FBSTJyQixNQUFKO0FBQUEsS0FDQ0MsY0FBYyxFQURmOztBQUdBOzs7OztBQUtBO0FBQ0EsVUFBU0MsYUFBVCxDQUF3QnRxQixJQUF4QixFQUE4QnVLLEdBQTlCLEVBQW9DO0FBQ25DLE1BQUl2TCxPQUFPN0IsT0FBUW9OLElBQUluQixhQUFKLENBQW1CcEosSUFBbkIsQ0FBUixFQUFvQytwQixRQUFwQyxDQUE4Q3hmLElBQUlxUCxJQUFsRCxDQUFYOzs7QUFFQztBQUNBMlEsWUFBVWx1QixPQUFPbXVCLHVCQUFQOztBQUVUO0FBQ0E7QUFDQW51QixTQUFPbXVCLHVCQUFQLENBQWdDeHJCLEtBQU0sQ0FBTixDQUFoQyxFQUE0Q3VyQixPQUpuQyxHQUk2Q3B0QixPQUFPK2YsR0FBUCxDQUFZbGUsS0FBTSxDQUFOLENBQVosRUFBdUIsU0FBdkIsQ0FQeEQ7O0FBU0E7QUFDQTtBQUNBQSxPQUFLZ2IsTUFBTDs7QUFFQSxTQUFPdVEsT0FBUDtBQUNBOztBQUVEOzs7O0FBSUEsVUFBU0UsY0FBVCxDQUF5QnhvQixRQUF6QixFQUFvQztBQUNuQyxNQUFJc0ksTUFBTXJPLFFBQVY7QUFBQSxNQUNDcXVCLFVBQVVGLFlBQWFwb0IsUUFBYixDQURYOztBQUdBLE1BQUssQ0FBQ3NvQixPQUFOLEVBQWdCO0FBQ2ZBLGFBQVVELGNBQWVyb0IsUUFBZixFQUF5QnNJLEdBQXpCLENBQVY7O0FBRUE7QUFDQSxPQUFLZ2dCLFlBQVksTUFBWixJQUFzQixDQUFDQSxPQUE1QixFQUFzQzs7QUFFckM7QUFDQUgsYUFBUyxDQUFDQSxVQUFVanRCLE9BQVEsZ0RBQVIsQ0FBWCxFQUF1RTRzQixRQUF2RSxDQUFpRnhmLElBQUlILGVBQXJGLENBQVQ7O0FBRUE7QUFDQUcsVUFBTSxDQUFFNmYsT0FBUSxDQUFSLEVBQVlwVSxhQUFaLElBQTZCb1UsT0FBUSxDQUFSLEVBQVlyVSxlQUEzQyxFQUE2RDdaLFFBQW5FOztBQUVBO0FBQ0FxTyxRQUFJbWdCLEtBQUo7QUFDQW5nQixRQUFJb2dCLEtBQUo7O0FBRUFKLGNBQVVELGNBQWVyb0IsUUFBZixFQUF5QnNJLEdBQXpCLENBQVY7QUFDQTZmLFdBQU9wUSxNQUFQO0FBQ0E7O0FBRUQ7QUFDQXFRLGVBQWFwb0IsUUFBYixJQUEwQnNvQixPQUExQjtBQUNBOztBQUVELFNBQU9BLE9BQVA7QUFDQTs7QUFHRCxFQUFDLFlBQVc7QUFDWCxNQUFJeGxCLENBQUo7QUFBQSxNQUFPNmxCLG1CQUFQO0FBQUEsTUFDQ3poQixNQUFNak4sU0FBU2tOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FEUDtBQUFBLE1BRUN5aEIsV0FDQyx1RkFDQSwyQ0FKRjs7QUFNQTtBQUNBMWhCLE1BQUk2QixTQUFKLEdBQWdCLG9FQUFoQjtBQUNBakcsTUFBSW9FLElBQUlwQixvQkFBSixDQUEwQixHQUExQixFQUFpQyxDQUFqQyxDQUFKOztBQUVBaEQsSUFBRTRWLEtBQUYsQ0FBUUMsT0FBUixHQUFrQix1QkFBbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EzZCxVQUFRNnRCLE9BQVIsR0FBa0IsT0FBTzVpQixJQUFQLENBQWFuRCxFQUFFNFYsS0FBRixDQUFRbVEsT0FBckIsQ0FBbEI7O0FBRUE7QUFDQTtBQUNBN3RCLFVBQVE4dEIsUUFBUixHQUFtQixDQUFDLENBQUNobUIsRUFBRTRWLEtBQUYsQ0FBUW9RLFFBQTdCOztBQUVBNWhCLE1BQUl3UixLQUFKLENBQVVxUSxjQUFWLEdBQTJCLGFBQTNCO0FBQ0E3aEIsTUFBSTRVLFNBQUosQ0FBZSxJQUFmLEVBQXNCcEQsS0FBdEIsQ0FBNEJxUSxjQUE1QixHQUE2QyxFQUE3QztBQUNBL3RCLFVBQVFndUIsZUFBUixHQUEwQjloQixJQUFJd1IsS0FBSixDQUFVcVEsY0FBVixLQUE2QixhQUF2RDs7QUFFQTtBQUNBam1CLE1BQUlvRSxNQUFNLElBQVY7O0FBRUFsTSxVQUFRaXVCLGdCQUFSLEdBQTJCLFlBQVc7QUFDckMsT0FBSXRSLElBQUosRUFBVWMsU0FBVixFQUFxQnZSLEdBQXJCLEVBQTBCZ2lCLGVBQTFCOztBQUVBLE9BQUtQLHVCQUF1QixJQUE1QixFQUFtQztBQUNsQ2hSLFdBQU8xZCxTQUFTNkwsb0JBQVQsQ0FBK0IsTUFBL0IsRUFBeUMsQ0FBekMsQ0FBUDtBQUNBLFFBQUssQ0FBQzZSLElBQU4sRUFBYTtBQUNaO0FBQ0E7QUFDQTs7QUFFRHVSLHNCQUFrQixnRUFBbEI7QUFDQXpRLGdCQUFZeGUsU0FBU2tOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBWjtBQUNBRCxVQUFNak4sU0FBU2tOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBTjs7QUFFQXdRLFNBQUs5TyxXQUFMLENBQWtCNFAsU0FBbEIsRUFBOEI1UCxXQUE5QixDQUEyQzNCLEdBQTNDOztBQUVBO0FBQ0F5aEIsMEJBQXNCLEtBQXRCOztBQUVBLFFBQUssUUFBT3poQixJQUFJd1IsS0FBSixDQUFVRSxJQUFqQixNQUEwQjVWLFlBQS9CLEVBQThDO0FBQzdDO0FBQ0E7QUFDQWtFLFNBQUl3UixLQUFKLENBQVVDLE9BQVYsR0FBb0JpUSxXQUFXLCtCQUEvQjtBQUNBMWhCLFNBQUk2QixTQUFKLEdBQWdCLGFBQWhCO0FBQ0E3QixTQUFJOEIsVUFBSixDQUFlMFAsS0FBZixDQUFxQnlRLEtBQXJCLEdBQTZCLEtBQTdCO0FBQ0FSLDJCQUFzQnpoQixJQUFJMlIsV0FBSixLQUFvQixDQUExQztBQUNBOztBQUVEbEIsU0FBS3ZRLFdBQUwsQ0FBa0JxUixTQUFsQjs7QUFFQTtBQUNBZCxXQUFPYyxZQUFZdlIsTUFBTSxJQUF6QjtBQUNBOztBQUVELFVBQU95aEIsbUJBQVA7QUFDQSxHQW5DRDtBQXFDQSxFQWxFRDtBQW1FQSxLQUFJUyxVQUFXLFNBQWY7O0FBRUEsS0FBSUMsWUFBWSxJQUFJM2xCLE1BQUosQ0FBWSxPQUFPa1gsSUFBUCxHQUFjLGlCQUExQixFQUE2QyxHQUE3QyxDQUFoQjs7QUFJQSxLQUFJME8sU0FBSjtBQUFBLEtBQWVDLE1BQWY7QUFBQSxLQUNDQyxZQUFZLDJCQURiOztBQUdBLEtBQUtwdkIsT0FBT3F2QixnQkFBWixFQUErQjtBQUM5QkgsY0FBWSxtQkFBVXZzQixJQUFWLEVBQWlCO0FBQzVCLFVBQU9BLEtBQUswSSxhQUFMLENBQW1CK0MsV0FBbkIsQ0FBK0JpaEIsZ0JBQS9CLENBQWlEMXNCLElBQWpELEVBQXVELElBQXZELENBQVA7QUFDQSxHQUZEOztBQUlBd3NCLFdBQVMsZ0JBQVV4c0IsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCMnJCLFFBQXRCLEVBQWlDO0FBQ3pDLE9BQUlQLEtBQUo7QUFBQSxPQUFXUSxRQUFYO0FBQUEsT0FBcUJDLFFBQXJCO0FBQUEsT0FBK0JwdEIsR0FBL0I7QUFBQSxPQUNDa2MsUUFBUTNiLEtBQUsyYixLQURkOztBQUdBZ1IsY0FBV0EsWUFBWUosVUFBV3ZzQixJQUFYLENBQXZCOztBQUVBO0FBQ0FQLFNBQU1rdEIsV0FBV0EsU0FBU0csZ0JBQVQsQ0FBMkI5ckIsSUFBM0IsS0FBcUMyckIsU0FBVTNyQixJQUFWLENBQWhELEdBQW1FUSxTQUF6RTs7QUFFQSxPQUFLbXJCLFFBQUwsRUFBZ0I7O0FBRWYsUUFBS2x0QixRQUFRLEVBQVIsSUFBYyxDQUFDdEIsT0FBT21ILFFBQVAsQ0FBaUJ0RixLQUFLMEksYUFBdEIsRUFBcUMxSSxJQUFyQyxDQUFwQixFQUFrRTtBQUNqRVAsV0FBTXRCLE9BQU93ZCxLQUFQLENBQWMzYixJQUFkLEVBQW9CZ0IsSUFBcEIsQ0FBTjtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBS3NyQixVQUFVcGpCLElBQVYsQ0FBZ0J6SixHQUFoQixLQUF5QjRzQixRQUFRbmpCLElBQVIsQ0FBY2xJLElBQWQsQ0FBOUIsRUFBcUQ7O0FBRXBEO0FBQ0FvckIsYUFBUXpRLE1BQU15USxLQUFkO0FBQ0FRLGdCQUFXalIsTUFBTWlSLFFBQWpCO0FBQ0FDLGdCQUFXbFIsTUFBTWtSLFFBQWpCOztBQUVBO0FBQ0FsUixXQUFNaVIsUUFBTixHQUFpQmpSLE1BQU1rUixRQUFOLEdBQWlCbFIsTUFBTXlRLEtBQU4sR0FBYzNzQixHQUFoRDtBQUNBQSxXQUFNa3RCLFNBQVNQLEtBQWY7O0FBRUE7QUFDQXpRLFdBQU15USxLQUFOLEdBQWNBLEtBQWQ7QUFDQXpRLFdBQU1pUixRQUFOLEdBQWlCQSxRQUFqQjtBQUNBalIsV0FBTWtSLFFBQU4sR0FBaUJBLFFBQWpCO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsVUFBT3B0QixRQUFRK0IsU0FBUixHQUNOL0IsR0FETSxHQUVOQSxNQUFNLEVBRlA7QUFHQSxHQTFDRDtBQTJDQSxFQWhERCxNQWdETyxJQUFLdkMsU0FBU2tPLGVBQVQsQ0FBeUIyaEIsWUFBOUIsRUFBNkM7QUFDbkRSLGNBQVksbUJBQVV2c0IsSUFBVixFQUFpQjtBQUM1QixVQUFPQSxLQUFLK3NCLFlBQVo7QUFDQSxHQUZEOztBQUlBUCxXQUFTLGdCQUFVeHNCLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQjJyQixRQUF0QixFQUFpQztBQUN6QyxPQUFJSyxJQUFKO0FBQUEsT0FBVUMsRUFBVjtBQUFBLE9BQWNDLE1BQWQ7QUFBQSxPQUFzQnp0QixHQUF0QjtBQUFBLE9BQ0NrYyxRQUFRM2IsS0FBSzJiLEtBRGQ7O0FBR0FnUixjQUFXQSxZQUFZSixVQUFXdnNCLElBQVgsQ0FBdkI7QUFDQVAsU0FBTWt0QixXQUFXQSxTQUFVM3JCLElBQVYsQ0FBWCxHQUE4QlEsU0FBcEM7O0FBRUE7QUFDQTtBQUNBLE9BQUsvQixPQUFPLElBQVAsSUFBZWtjLEtBQWYsSUFBd0JBLE1BQU8zYSxJQUFQLENBQTdCLEVBQTZDO0FBQzVDdkIsVUFBTWtjLE1BQU8zYSxJQUFQLENBQU47QUFDQTs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBS3NyQixVQUFVcGpCLElBQVYsQ0FBZ0J6SixHQUFoQixLQUF5QixDQUFDZ3RCLFVBQVV2akIsSUFBVixDQUFnQmxJLElBQWhCLENBQS9CLEVBQXdEOztBQUV2RDtBQUNBZ3NCLFdBQU9yUixNQUFNcVIsSUFBYjtBQUNBQyxTQUFLanRCLEtBQUttdEIsWUFBVjtBQUNBRCxhQUFTRCxNQUFNQSxHQUFHRCxJQUFsQjs7QUFFQTtBQUNBLFFBQUtFLE1BQUwsRUFBYztBQUNiRCxRQUFHRCxJQUFILEdBQVVodEIsS0FBSytzQixZQUFMLENBQWtCQyxJQUE1QjtBQUNBO0FBQ0RyUixVQUFNcVIsSUFBTixHQUFhaHNCLFNBQVMsVUFBVCxHQUFzQixLQUF0QixHQUE4QnZCLEdBQTNDO0FBQ0FBLFVBQU1rYyxNQUFNeVIsU0FBTixHQUFrQixJQUF4Qjs7QUFFQTtBQUNBelIsVUFBTXFSLElBQU4sR0FBYUEsSUFBYjtBQUNBLFFBQUtFLE1BQUwsRUFBYztBQUNiRCxRQUFHRCxJQUFILEdBQVVFLE1BQVY7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQSxVQUFPenRCLFFBQVErQixTQUFSLEdBQ04vQixHQURNLEdBRU5BLE1BQU0sRUFBTixJQUFZLE1BRmI7QUFHQSxHQTlDRDtBQStDQTs7QUFLRCxVQUFTNHRCLFlBQVQsQ0FBdUJDLFdBQXZCLEVBQW9DQyxNQUFwQyxFQUE2QztBQUM1QztBQUNBLFNBQU87QUFDTmx1QixRQUFLLGVBQVc7QUFDZixRQUFJbXVCLFlBQVlGLGFBQWhCOztBQUVBLFFBQUtFLGFBQWEsSUFBbEIsRUFBeUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUQsUUFBS0EsU0FBTCxFQUFpQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFPLEtBQUtudUIsR0FBWjtBQUNBO0FBQ0E7O0FBRUQ7O0FBRUEsV0FBTyxDQUFDLEtBQUtBLEdBQUwsR0FBV2t1QixNQUFaLEVBQW9CcnRCLEtBQXBCLENBQTJCLElBQTNCLEVBQWlDQyxTQUFqQyxDQUFQO0FBQ0E7QUFyQkssR0FBUDtBQXVCQTs7QUFHRCxFQUFDLFlBQVc7QUFDWCxNQUFJNEYsQ0FBSjtBQUFBLE1BQU8wbkIsd0JBQVA7QUFBQSxNQUFpQ0MsWUFBakM7QUFBQSxNQUErQ0Msb0JBQS9DO0FBQUEsTUFDQ0MsZ0JBREQ7QUFBQSxNQUNtQkMsc0JBRG5CO0FBQUEsTUFFQzFqQixNQUFNak4sU0FBU2tOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FGUDtBQUFBLE1BR0MraEIsa0JBQWtCLGdFQUhuQjtBQUFBLE1BSUNOLFdBQ0MsdUZBQ0EsMkNBTkY7O0FBUUE7QUFDQTFoQixNQUFJNkIsU0FBSixHQUFnQixvRUFBaEI7QUFDQWpHLE1BQUlvRSxJQUFJcEIsb0JBQUosQ0FBMEIsR0FBMUIsRUFBaUMsQ0FBakMsQ0FBSjs7QUFFQWhELElBQUU0VixLQUFGLENBQVFDLE9BQVIsR0FBa0IsdUJBQWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBM2QsVUFBUTZ0QixPQUFSLEdBQWtCLE9BQU81aUIsSUFBUCxDQUFhbkQsRUFBRTRWLEtBQUYsQ0FBUW1RLE9BQXJCLENBQWxCOztBQUVBO0FBQ0E7QUFDQTd0QixVQUFROHRCLFFBQVIsR0FBbUIsQ0FBQyxDQUFDaG1CLEVBQUU0VixLQUFGLENBQVFvUSxRQUE3Qjs7QUFFQTVoQixNQUFJd1IsS0FBSixDQUFVcVEsY0FBVixHQUEyQixhQUEzQjtBQUNBN2hCLE1BQUk0VSxTQUFKLENBQWUsSUFBZixFQUFzQnBELEtBQXRCLENBQTRCcVEsY0FBNUIsR0FBNkMsRUFBN0M7QUFDQS90QixVQUFRZ3VCLGVBQVIsR0FBMEI5aEIsSUFBSXdSLEtBQUosQ0FBVXFRLGNBQVYsS0FBNkIsYUFBdkQ7O0FBRUE7QUFDQWptQixNQUFJb0UsTUFBTSxJQUFWOztBQUVBaE0sU0FBT3lDLE1BQVAsQ0FBYzNDLE9BQWQsRUFBdUI7QUFDdEI2dkIsMEJBQXVCLGlDQUFXO0FBQ2pDLFFBQUtMLDRCQUE0QixJQUFqQyxFQUF3QztBQUN2QyxZQUFPQSx3QkFBUDtBQUNBOztBQUVELFFBQUkvUixTQUFKO0FBQUEsUUFBZXFTLEdBQWY7QUFBQSxRQUFvQkMsV0FBcEI7QUFBQSxRQUNDN2pCLE1BQU1qTixTQUFTa04sYUFBVCxDQUF3QixLQUF4QixDQURQO0FBQUEsUUFFQ3dRLE9BQU8xZCxTQUFTNkwsb0JBQVQsQ0FBK0IsTUFBL0IsRUFBeUMsQ0FBekMsQ0FGUjs7QUFJQSxRQUFLLENBQUM2UixJQUFOLEVBQWE7QUFDWjtBQUNBO0FBQ0E7O0FBRUQ7QUFDQXpRLFFBQUlkLFlBQUosQ0FBa0IsV0FBbEIsRUFBK0IsR0FBL0I7QUFDQWMsUUFBSTZCLFNBQUosR0FBZ0Isb0VBQWhCOztBQUVBMFAsZ0JBQVl4ZSxTQUFTa04sYUFBVCxDQUF3QixLQUF4QixDQUFaO0FBQ0FzUixjQUFVQyxLQUFWLENBQWdCQyxPQUFoQixHQUEwQnVRLGVBQTFCOztBQUVBdlIsU0FBSzlPLFdBQUwsQ0FBa0I0UCxTQUFsQixFQUE4QjVQLFdBQTlCLENBQTJDM0IsR0FBM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsUUFBSTZCLFNBQUosR0FBZ0IsNkNBQWhCO0FBQ0EraEIsVUFBTTVqQixJQUFJcEIsb0JBQUosQ0FBMEIsSUFBMUIsQ0FBTjtBQUNBZ2xCLFFBQUssQ0FBTCxFQUFTcFMsS0FBVCxDQUFlQyxPQUFmLEdBQXlCLDBDQUF6QjtBQUNBb1Msa0JBQWdCRCxJQUFLLENBQUwsRUFBU0UsWUFBVCxLQUEwQixDQUExQzs7QUFFQUYsUUFBSyxDQUFMLEVBQVNwUyxLQUFULENBQWU0UCxPQUFmLEdBQXlCLEVBQXpCO0FBQ0F3QyxRQUFLLENBQUwsRUFBU3BTLEtBQVQsQ0FBZTRQLE9BQWYsR0FBeUIsTUFBekI7O0FBRUE7QUFDQTtBQUNBa0MsK0JBQTJCTyxlQUFpQkQsSUFBSyxDQUFMLEVBQVNFLFlBQVQsS0FBMEIsQ0FBdEU7O0FBRUFyVCxTQUFLdlEsV0FBTCxDQUFrQnFSLFNBQWxCOztBQUVBO0FBQ0F2UixVQUFNeVEsT0FBTyxJQUFiOztBQUVBLFdBQU82Uyx3QkFBUDtBQUNBLElBakRxQjs7QUFtRHRCUyxjQUFXLHFCQUFXO0FBQ3JCLFFBQUtSLGdCQUFnQixJQUFyQixFQUE0QjtBQUMzQlM7QUFDQTtBQUNELFdBQU9ULFlBQVA7QUFDQSxJQXhEcUI7O0FBMER0QlUsc0JBQW1CLDZCQUFXO0FBQzdCLFFBQUtULHdCQUF3QixJQUE3QixFQUFvQztBQUNuQ1E7QUFDQTtBQUNELFdBQU9SLG9CQUFQO0FBQ0EsSUEvRHFCOztBQWlFdEJVLGtCQUFlLHlCQUFXO0FBQ3pCLFFBQUtULG9CQUFvQixJQUF6QixFQUFnQztBQUMvQk87QUFDQTtBQUNELFdBQU9QLGdCQUFQO0FBQ0EsSUF0RXFCOztBQXdFdEJVLHdCQUFxQiwrQkFBVztBQUMvQixRQUFJMVQsSUFBSixFQUFVYyxTQUFWLEVBQXFCdlIsR0FBckIsRUFBMEJva0IsU0FBMUI7O0FBRUE7QUFDQSxRQUFLViwwQkFBMEIsSUFBMUIsSUFBa0N4d0IsT0FBT3F2QixnQkFBOUMsRUFBaUU7QUFDaEU5UixZQUFPMWQsU0FBUzZMLG9CQUFULENBQStCLE1BQS9CLEVBQXlDLENBQXpDLENBQVA7QUFDQSxTQUFLLENBQUM2UixJQUFOLEVBQWE7QUFDWjtBQUNBO0FBQ0E7O0FBRURjLGlCQUFZeGUsU0FBU2tOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBWjtBQUNBRCxXQUFNak4sU0FBU2tOLGFBQVQsQ0FBd0IsS0FBeEIsQ0FBTjtBQUNBc1IsZUFBVUMsS0FBVixDQUFnQkMsT0FBaEIsR0FBMEJ1USxlQUExQjs7QUFFQXZSLFVBQUs5TyxXQUFMLENBQWtCNFAsU0FBbEIsRUFBOEI1UCxXQUE5QixDQUEyQzNCLEdBQTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Fva0IsaUJBQVlwa0IsSUFBSTJCLFdBQUosQ0FBaUI1TyxTQUFTa04sYUFBVCxDQUF3QixLQUF4QixDQUFqQixDQUFaO0FBQ0Fta0IsZUFBVTVTLEtBQVYsQ0FBZ0JDLE9BQWhCLEdBQTBCelIsSUFBSXdSLEtBQUosQ0FBVUMsT0FBVixHQUFvQmlRLFFBQTlDO0FBQ0EwQyxlQUFVNVMsS0FBVixDQUFnQjZTLFdBQWhCLEdBQThCRCxVQUFVNVMsS0FBVixDQUFnQnlRLEtBQWhCLEdBQXdCLEdBQXREO0FBQ0FqaUIsU0FBSXdSLEtBQUosQ0FBVXlRLEtBQVYsR0FBa0IsS0FBbEI7O0FBRUF5Qiw4QkFDQyxDQUFDdnJCLFdBQVksQ0FBRWpGLE9BQU9xdkIsZ0JBQVAsQ0FBeUI2QixTQUF6QixFQUFvQyxJQUFwQyxLQUE4QyxFQUFoRCxFQUFxREMsV0FBakUsQ0FERjs7QUFHQTVULFVBQUt2USxXQUFMLENBQWtCcVIsU0FBbEI7QUFDQTs7QUFFRCxXQUFPbVMsc0JBQVA7QUFDQTtBQXpHcUIsR0FBdkI7O0FBNEdBLFdBQVNNLGlCQUFULEdBQTZCO0FBQzVCLE9BQUl6UyxTQUFKO0FBQUEsT0FBZXZSLEdBQWY7QUFBQSxPQUNDeVEsT0FBTzFkLFNBQVM2TCxvQkFBVCxDQUErQixNQUEvQixFQUF5QyxDQUF6QyxDQURSOztBQUdBLE9BQUssQ0FBQzZSLElBQU4sRUFBYTtBQUNaO0FBQ0E7QUFDQTs7QUFFRGMsZUFBWXhlLFNBQVNrTixhQUFULENBQXdCLEtBQXhCLENBQVo7QUFDQUQsU0FBTWpOLFNBQVNrTixhQUFULENBQXdCLEtBQXhCLENBQU47QUFDQXNSLGFBQVVDLEtBQVYsQ0FBZ0JDLE9BQWhCLEdBQTBCdVEsZUFBMUI7O0FBRUF2UixRQUFLOU8sV0FBTCxDQUFrQjRQLFNBQWxCLEVBQThCNVAsV0FBOUIsQ0FBMkMzQixHQUEzQzs7QUFFQUEsT0FBSXdSLEtBQUosQ0FBVUMsT0FBVixHQUNDLG9GQUNDLG1FQURELEdBRUMsc0JBSEY7O0FBS0E7QUFDQTtBQUNBemQsVUFBT3N3QixJQUFQLENBQWE3VCxJQUFiLEVBQW1CQSxLQUFLZSxLQUFMLENBQVdFLElBQVgsSUFBbUIsSUFBbkIsR0FBMEIsRUFBRUEsTUFBTSxDQUFSLEVBQTFCLEdBQXdDLEVBQTNELEVBQStELFlBQVc7QUFDekU2UixtQkFBZXZqQixJQUFJMlIsV0FBSixLQUFvQixDQUFuQztBQUNBLElBRkQ7O0FBSUE7QUFDQTZSLDBCQUF1QixJQUF2QjtBQUNBQyxzQkFBbUIsS0FBbkI7QUFDQUMsNEJBQXlCLElBQXpCOztBQUVBO0FBQ0EsT0FBS3h3QixPQUFPcXZCLGdCQUFaLEVBQStCO0FBQzlCa0IsdUJBQW1CLENBQUV2d0IsT0FBT3F2QixnQkFBUCxDQUF5QnZpQixHQUF6QixFQUE4QixJQUE5QixLQUF3QyxFQUExQyxFQUErQ3VCLEdBQS9DLEtBQXVELElBQTFFO0FBQ0FpaUIsMkJBQ0MsQ0FBRXR3QixPQUFPcXZCLGdCQUFQLENBQXlCdmlCLEdBQXpCLEVBQThCLElBQTlCLEtBQXdDLEVBQUVpaUIsT0FBTyxLQUFULEVBQTFDLEVBQTZEQSxLQUE3RCxLQUF1RSxLQUR4RTtBQUVBOztBQUVEeFIsUUFBS3ZRLFdBQUwsQ0FBa0JxUixTQUFsQjs7QUFFQTtBQUNBdlIsU0FBTXlRLE9BQU8sSUFBYjtBQUNBO0FBRUQsRUF2TEQ7O0FBMExBO0FBQ0F6YyxRQUFPc3dCLElBQVAsR0FBYyxVQUFVenVCLElBQVYsRUFBZ0JpQixPQUFoQixFQUF5QnBCLFFBQXpCLEVBQW1DQyxJQUFuQyxFQUEwQztBQUN2RCxNQUFJTCxHQUFKO0FBQUEsTUFBU3VCLElBQVQ7QUFBQSxNQUNDc0gsTUFBTSxFQURQOztBQUdBO0FBQ0EsT0FBTXRILElBQU4sSUFBY0MsT0FBZCxFQUF3QjtBQUN2QnFILE9BQUt0SCxJQUFMLElBQWNoQixLQUFLMmIsS0FBTCxDQUFZM2EsSUFBWixDQUFkO0FBQ0FoQixRQUFLMmIsS0FBTCxDQUFZM2EsSUFBWixJQUFxQkMsUUFBU0QsSUFBVCxDQUFyQjtBQUNBOztBQUVEdkIsUUFBTUksU0FBU0ssS0FBVCxDQUFnQkYsSUFBaEIsRUFBc0JGLFFBQVEsRUFBOUIsQ0FBTjs7QUFFQTtBQUNBLE9BQU1rQixJQUFOLElBQWNDLE9BQWQsRUFBd0I7QUFDdkJqQixRQUFLMmIsS0FBTCxDQUFZM2EsSUFBWixJQUFxQnNILElBQUt0SCxJQUFMLENBQXJCO0FBQ0E7O0FBRUQsU0FBT3ZCLEdBQVA7QUFDQSxFQWxCRDs7QUFxQkEsS0FDRWl2QixTQUFTLGlCQURYO0FBQUEsS0FFQ0MsV0FBVyx1QkFGWjs7O0FBSUM7QUFDQTtBQUNBQyxnQkFBZSwyQkFOaEI7QUFBQSxLQU9DQyxZQUFZLElBQUlsb0IsTUFBSixDQUFZLE9BQU9rWCxJQUFQLEdBQWMsUUFBMUIsRUFBb0MsR0FBcEMsQ0FQYjtBQUFBLEtBUUNpUixVQUFVLElBQUlub0IsTUFBSixDQUFZLGNBQWNrWCxJQUFkLEdBQXFCLEdBQWpDLEVBQXNDLEdBQXRDLENBUlg7QUFBQSxLQVVDa1IsVUFBVSxFQUFFQyxVQUFVLFVBQVosRUFBd0JDLFlBQVksUUFBcEMsRUFBOEMxRCxTQUFTLE9BQXZELEVBVlg7QUFBQSxLQVdDMkQscUJBQXFCO0FBQ3BCQyxpQkFBZSxDQURLO0FBRXBCQyxjQUFZO0FBRlEsRUFYdEI7QUFBQSxLQWdCQ0MsY0FBYyxDQUFFLFFBQUYsRUFBWSxHQUFaLEVBQWlCLEtBQWpCLEVBQXdCLElBQXhCLENBaEJmOztBQW1CQTtBQUNBLFVBQVNDLGNBQVQsQ0FBeUIzVCxLQUF6QixFQUFnQzNhLElBQWhDLEVBQXVDOztBQUV0QztBQUNBLE1BQUtBLFFBQVEyYSxLQUFiLEVBQXFCO0FBQ3BCLFVBQU8zYSxJQUFQO0FBQ0E7O0FBRUQ7QUFDQSxNQUFJdXVCLFVBQVV2dUIsS0FBS21VLE1BQUwsQ0FBWSxDQUFaLEVBQWVyVyxXQUFmLEtBQStCa0MsS0FBS3hELEtBQUwsQ0FBVyxDQUFYLENBQTdDO0FBQUEsTUFDQ2d5QixXQUFXeHVCLElBRFo7QUFBQSxNQUVDZixJQUFJb3ZCLFlBQVlud0IsTUFGakI7O0FBSUEsU0FBUWUsR0FBUixFQUFjO0FBQ2JlLFVBQU9xdUIsWUFBYXB2QixDQUFiLElBQW1Cc3ZCLE9BQTFCO0FBQ0EsT0FBS3Z1QixRQUFRMmEsS0FBYixFQUFxQjtBQUNwQixXQUFPM2EsSUFBUDtBQUNBO0FBQ0Q7O0FBRUQsU0FBT3d1QixRQUFQO0FBQ0E7O0FBRUQsVUFBU0MsUUFBVCxDQUFtQi9oQixRQUFuQixFQUE2QmdpQixJQUE3QixFQUFvQztBQUNuQyxNQUFJbkUsT0FBSjtBQUFBLE1BQWF2ckIsSUFBYjtBQUFBLE1BQW1CMnZCLE1BQW5CO0FBQUEsTUFDQzFWLFNBQVMsRUFEVjtBQUFBLE1BRUM1RCxRQUFRLENBRlQ7QUFBQSxNQUdDblgsU0FBU3dPLFNBQVN4TyxNQUhuQjs7QUFLQSxTQUFRbVgsUUFBUW5YLE1BQWhCLEVBQXdCbVgsT0FBeEIsRUFBa0M7QUFDakNyVyxVQUFPME4sU0FBVTJJLEtBQVYsQ0FBUDtBQUNBLE9BQUssQ0FBQ3JXLEtBQUsyYixLQUFYLEVBQW1CO0FBQ2xCO0FBQ0E7O0FBRUQxQixVQUFRNUQsS0FBUixJQUFrQmxZLE9BQU84ZSxLQUFQLENBQWNqZCxJQUFkLEVBQW9CLFlBQXBCLENBQWxCO0FBQ0F1ckIsYUFBVXZyQixLQUFLMmIsS0FBTCxDQUFXNFAsT0FBckI7QUFDQSxPQUFLbUUsSUFBTCxFQUFZO0FBQ1g7QUFDQTtBQUNBLFFBQUssQ0FBQ3pWLE9BQVE1RCxLQUFSLENBQUQsSUFBb0JrVixZQUFZLE1BQXJDLEVBQThDO0FBQzdDdnJCLFVBQUsyYixLQUFMLENBQVc0UCxPQUFYLEdBQXFCLEVBQXJCO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsUUFBS3ZyQixLQUFLMmIsS0FBTCxDQUFXNFAsT0FBWCxLQUF1QixFQUF2QixJQUE2QnZOLFNBQVVoZSxJQUFWLENBQWxDLEVBQXFEO0FBQ3BEaWEsWUFBUTVELEtBQVIsSUFBa0JsWSxPQUFPOGUsS0FBUCxDQUFjamQsSUFBZCxFQUFvQixZQUFwQixFQUFrQ3lyQixlQUFlenJCLEtBQUtpRCxRQUFwQixDQUFsQyxDQUFsQjtBQUNBO0FBQ0QsSUFiRCxNQWFPOztBQUVOLFFBQUssQ0FBQ2dYLE9BQVE1RCxLQUFSLENBQU4sRUFBd0I7QUFDdkJzWixjQUFTM1IsU0FBVWhlLElBQVYsQ0FBVDs7QUFFQSxTQUFLdXJCLFdBQVdBLFlBQVksTUFBdkIsSUFBaUMsQ0FBQ29FLE1BQXZDLEVBQWdEO0FBQy9DeHhCLGFBQU84ZSxLQUFQLENBQWNqZCxJQUFkLEVBQW9CLFlBQXBCLEVBQWtDMnZCLFNBQVNwRSxPQUFULEdBQW1CcHRCLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFNBQWxCLENBQXJEO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE9BQU1xVyxRQUFRLENBQWQsRUFBaUJBLFFBQVFuWCxNQUF6QixFQUFpQ21YLE9BQWpDLEVBQTJDO0FBQzFDclcsVUFBTzBOLFNBQVUySSxLQUFWLENBQVA7QUFDQSxPQUFLLENBQUNyVyxLQUFLMmIsS0FBWCxFQUFtQjtBQUNsQjtBQUNBO0FBQ0QsT0FBSyxDQUFDK1QsSUFBRCxJQUFTMXZCLEtBQUsyYixLQUFMLENBQVc0UCxPQUFYLEtBQXVCLE1BQWhDLElBQTBDdnJCLEtBQUsyYixLQUFMLENBQVc0UCxPQUFYLEtBQXVCLEVBQXRFLEVBQTJFO0FBQzFFdnJCLFNBQUsyYixLQUFMLENBQVc0UCxPQUFYLEdBQXFCbUUsT0FBT3pWLE9BQVE1RCxLQUFSLEtBQW1CLEVBQTFCLEdBQStCLE1BQXBEO0FBQ0E7QUFDRDs7QUFFRCxTQUFPM0ksUUFBUDtBQUNBOztBQUVELFVBQVNraUIsaUJBQVQsQ0FBNEI1dkIsSUFBNUIsRUFBa0NtRCxLQUFsQyxFQUF5QzBzQixRQUF6QyxFQUFvRDtBQUNuRCxNQUFJN3JCLFVBQVU2cUIsVUFBVWxtQixJQUFWLENBQWdCeEYsS0FBaEIsQ0FBZDtBQUNBLFNBQU9hO0FBQ047QUFDQXRDLE9BQUtpQyxHQUFMLENBQVUsQ0FBVixFQUFhSyxRQUFTLENBQVQsS0FBaUI2ckIsWUFBWSxDQUE3QixDQUFiLEtBQW9EN3JCLFFBQVMsQ0FBVCxLQUFnQixJQUFwRSxDQUZNLEdBR05iLEtBSEQ7QUFJQTs7QUFFRCxVQUFTMnNCLG9CQUFULENBQStCOXZCLElBQS9CLEVBQXFDZ0IsSUFBckMsRUFBMkMrdUIsS0FBM0MsRUFBa0RDLFdBQWxELEVBQStEQyxNQUEvRCxFQUF3RTtBQUN2RSxNQUFJaHdCLElBQUk4dkIsV0FBWUMsY0FBYyxRQUFkLEdBQXlCLFNBQXJDO0FBQ1A7QUFDQSxHQUZPO0FBR1A7QUFDQWh2QixXQUFTLE9BQVQsR0FBbUIsQ0FBbkIsR0FBdUIsQ0FKeEI7QUFBQSxNQU1DNE0sTUFBTSxDQU5QOztBQVFBLFNBQVEzTixJQUFJLENBQVosRUFBZUEsS0FBSyxDQUFwQixFQUF3QjtBQUN2QjtBQUNBLE9BQUs4dkIsVUFBVSxRQUFmLEVBQTBCO0FBQ3pCbmlCLFdBQU96UCxPQUFPK2YsR0FBUCxDQUFZbGUsSUFBWixFQUFrQit2QixRQUFRaFMsVUFBVzlkLENBQVgsQ0FBMUIsRUFBMEMsSUFBMUMsRUFBZ0Rnd0IsTUFBaEQsQ0FBUDtBQUNBOztBQUVELE9BQUtELFdBQUwsRUFBbUI7QUFDbEI7QUFDQSxRQUFLRCxVQUFVLFNBQWYsRUFBMkI7QUFDMUJuaUIsWUFBT3pQLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFlBQVkrZCxVQUFXOWQsQ0FBWCxDQUE5QixFQUE4QyxJQUE5QyxFQUFvRGd3QixNQUFwRCxDQUFQO0FBQ0E7O0FBRUQ7QUFDQSxRQUFLRixVQUFVLFFBQWYsRUFBMEI7QUFDekJuaUIsWUFBT3pQLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFdBQVcrZCxVQUFXOWQsQ0FBWCxDQUFYLEdBQTRCLE9BQTlDLEVBQXVELElBQXZELEVBQTZEZ3dCLE1BQTdELENBQVA7QUFDQTtBQUNELElBVkQsTUFVTztBQUNOO0FBQ0FyaUIsV0FBT3pQLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFlBQVkrZCxVQUFXOWQsQ0FBWCxDQUE5QixFQUE4QyxJQUE5QyxFQUFvRGd3QixNQUFwRCxDQUFQOztBQUVBO0FBQ0EsUUFBS0YsVUFBVSxTQUFmLEVBQTJCO0FBQzFCbmlCLFlBQU96UCxPQUFPK2YsR0FBUCxDQUFZbGUsSUFBWixFQUFrQixXQUFXK2QsVUFBVzlkLENBQVgsQ0FBWCxHQUE0QixPQUE5QyxFQUF1RCxJQUF2RCxFQUE2RGd3QixNQUE3RCxDQUFQO0FBQ0E7QUFDRDtBQUNEOztBQUVELFNBQU9yaUIsR0FBUDtBQUNBOztBQUVELFVBQVNzaUIsZ0JBQVQsQ0FBMkJsd0IsSUFBM0IsRUFBaUNnQixJQUFqQyxFQUF1Qyt1QixLQUF2QyxFQUErQzs7QUFFOUM7QUFDQSxNQUFJSSxtQkFBbUIsSUFBdkI7QUFBQSxNQUNDdmlCLE1BQU01TSxTQUFTLE9BQVQsR0FBbUJoQixLQUFLOGIsV0FBeEIsR0FBc0M5YixLQUFLaXVCLFlBRGxEO0FBQUEsTUFFQ2dDLFNBQVMxRCxVQUFXdnNCLElBQVgsQ0FGVjtBQUFBLE1BR0Nnd0IsY0FBYy94QixRQUFRaXdCLFNBQVIsTUFBdUIvdkIsT0FBTytmLEdBQVAsQ0FBWWxlLElBQVosRUFBa0IsV0FBbEIsRUFBK0IsS0FBL0IsRUFBc0Npd0IsTUFBdEMsTUFBbUQsWUFIekY7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsTUFBS3JpQixPQUFPLENBQVAsSUFBWUEsT0FBTyxJQUF4QixFQUErQjtBQUM5QjtBQUNBQSxTQUFNNGUsT0FBUXhzQixJQUFSLEVBQWNnQixJQUFkLEVBQW9CaXZCLE1BQXBCLENBQU47QUFDQSxPQUFLcmlCLE1BQU0sQ0FBTixJQUFXQSxPQUFPLElBQXZCLEVBQThCO0FBQzdCQSxVQUFNNU4sS0FBSzJiLEtBQUwsQ0FBWTNhLElBQVosQ0FBTjtBQUNBOztBQUVEO0FBQ0EsT0FBS3NyQixVQUFVcGpCLElBQVYsQ0FBZTBFLEdBQWYsQ0FBTCxFQUEyQjtBQUMxQixXQUFPQSxHQUFQO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBdWlCLHNCQUFtQkgsZ0JBQWlCL3hCLFFBQVFtd0IsaUJBQVIsTUFBK0J4Z0IsUUFBUTVOLEtBQUsyYixLQUFMLENBQVkzYSxJQUFaLENBQXhELENBQW5COztBQUVBO0FBQ0E0TSxTQUFNdEwsV0FBWXNMLEdBQVosS0FBcUIsQ0FBM0I7QUFDQTs7QUFFRDtBQUNBLFNBQVNBLE1BQ1JraUIscUJBQ0M5dkIsSUFERCxFQUVDZ0IsSUFGRCxFQUdDK3VCLFVBQVdDLGNBQWMsUUFBZCxHQUF5QixTQUFwQyxDQUhELEVBSUNHLGdCQUpELEVBS0NGLE1BTEQsQ0FETSxHQVFILElBUko7QUFTQTs7QUFFRDl4QixRQUFPeUMsTUFBUCxDQUFjO0FBQ2I7QUFDQTtBQUNBd3ZCLFlBQVU7QUFDVHRFLFlBQVM7QUFDUnpzQixTQUFLLGFBQVVXLElBQVYsRUFBZ0Iyc0IsUUFBaEIsRUFBMkI7QUFDL0IsU0FBS0EsUUFBTCxFQUFnQjtBQUNmO0FBQ0EsVUFBSWx0QixNQUFNK3NCLE9BQVF4c0IsSUFBUixFQUFjLFNBQWQsQ0FBVjtBQUNBLGFBQU9QLFFBQVEsRUFBUixHQUFhLEdBQWIsR0FBbUJBLEdBQTFCO0FBQ0E7QUFDRDtBQVBPO0FBREEsR0FIRzs7QUFlYjtBQUNBNHdCLGFBQVc7QUFDVixrQkFBZSxJQURMO0FBRVYsa0JBQWUsSUFGTDtBQUdWLGlCQUFjLElBSEo7QUFJVixpQkFBYyxJQUpKO0FBS1YsY0FBVyxJQUxEO0FBTVYsWUFBUyxJQU5DO0FBT1YsY0FBVyxJQVBEO0FBUVYsYUFBVSxJQVJBO0FBU1YsYUFBVSxJQVRBO0FBVVYsV0FBUTtBQVZFLEdBaEJFOztBQTZCYjtBQUNBO0FBQ0FDLFlBQVU7QUFDVDtBQUNBLFlBQVNyeUIsUUFBUTh0QixRQUFSLEdBQW1CLFVBQW5CLEdBQWdDO0FBRmhDLEdBL0JHOztBQW9DYjtBQUNBcFEsU0FBTyxlQUFVM2IsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCbUMsS0FBdEIsRUFBNkI0c0IsS0FBN0IsRUFBcUM7QUFDM0M7QUFDQSxPQUFLLENBQUMvdkIsSUFBRCxJQUFTQSxLQUFLeUMsUUFBTCxLQUFrQixDQUEzQixJQUFnQ3pDLEtBQUt5QyxRQUFMLEtBQWtCLENBQWxELElBQXVELENBQUN6QyxLQUFLMmIsS0FBbEUsRUFBMEU7QUFDekU7QUFDQTs7QUFFRDtBQUNBLE9BQUlsYyxHQUFKO0FBQUEsT0FBU3lDLElBQVQ7QUFBQSxPQUFlb2IsS0FBZjtBQUFBLE9BQ0NrUyxXQUFXcnhCLE9BQU80RSxTQUFQLENBQWtCL0IsSUFBbEIsQ0FEWjtBQUFBLE9BRUMyYSxRQUFRM2IsS0FBSzJiLEtBRmQ7O0FBSUEzYSxVQUFPN0MsT0FBT215QixRQUFQLENBQWlCZCxRQUFqQixNQUFpQ3J4QixPQUFPbXlCLFFBQVAsQ0FBaUJkLFFBQWpCLElBQThCRixlQUFnQjNULEtBQWhCLEVBQXVCNlQsUUFBdkIsQ0FBL0QsQ0FBUDs7QUFFQTtBQUNBO0FBQ0FsUyxXQUFRbmYsT0FBT2l5QixRQUFQLENBQWlCcHZCLElBQWpCLEtBQTJCN0MsT0FBT2l5QixRQUFQLENBQWlCWixRQUFqQixDQUFuQzs7QUFFQTtBQUNBLE9BQUtyc0IsVUFBVTNCLFNBQWYsRUFBMkI7QUFDMUJVLGtCQUFjaUIsS0FBZCx5Q0FBY0EsS0FBZDs7QUFFQTtBQUNBLFFBQUtqQixTQUFTLFFBQVQsS0FBc0J6QyxNQUFNcXZCLFFBQVFubUIsSUFBUixDQUFjeEYsS0FBZCxDQUE1QixDQUFMLEVBQTBEO0FBQ3pEQSxhQUFRLENBQUUxRCxJQUFJLENBQUosSUFBUyxDQUFYLElBQWlCQSxJQUFJLENBQUosQ0FBakIsR0FBMEI2QyxXQUFZbkUsT0FBTytmLEdBQVAsQ0FBWWxlLElBQVosRUFBa0JnQixJQUFsQixDQUFaLENBQWxDO0FBQ0E7QUFDQWtCLFlBQU8sUUFBUDtBQUNBOztBQUVEO0FBQ0EsUUFBS2lCLFNBQVMsSUFBVCxJQUFpQkEsVUFBVUEsS0FBaEMsRUFBd0M7QUFDdkM7QUFDQTs7QUFFRDtBQUNBLFFBQUtqQixTQUFTLFFBQVQsSUFBcUIsQ0FBQy9ELE9BQU9reUIsU0FBUCxDQUFrQmIsUUFBbEIsQ0FBM0IsRUFBMEQ7QUFDekRyc0IsY0FBUyxJQUFUO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLFFBQUssQ0FBQ2xGLFFBQVFndUIsZUFBVCxJQUE0QjlvQixVQUFVLEVBQXRDLElBQTRDbkMsS0FBS3JELE9BQUwsQ0FBYSxZQUFiLE1BQStCLENBQWhGLEVBQW9GO0FBQ25GZ2UsV0FBTzNhLElBQVAsSUFBZ0IsU0FBaEI7QUFDQTs7QUFFRDtBQUNBLFFBQUssQ0FBQ3NjLEtBQUQsSUFBVSxFQUFFLFNBQVNBLEtBQVgsQ0FBVixJQUErQixDQUFDbmEsUUFBUW1hLE1BQU1zTixHQUFOLENBQVc1cUIsSUFBWCxFQUFpQm1ELEtBQWpCLEVBQXdCNHNCLEtBQXhCLENBQVQsTUFBOEN2dUIsU0FBbEYsRUFBOEY7O0FBRTdGO0FBQ0E7QUFDQSxTQUFJO0FBQ0g7QUFDQTtBQUNBbWEsWUFBTzNhLElBQVAsSUFBZ0IsRUFBaEI7QUFDQTJhLFlBQU8zYSxJQUFQLElBQWdCbUMsS0FBaEI7QUFDQSxNQUxELENBS0UsT0FBTVQsQ0FBTixFQUFTLENBQUU7QUFDYjtBQUVELElBdkNELE1BdUNPO0FBQ047QUFDQSxRQUFLNGEsU0FBUyxTQUFTQSxLQUFsQixJQUEyQixDQUFDN2QsTUFBTTZkLE1BQU1qZSxHQUFOLENBQVdXLElBQVgsRUFBaUIsS0FBakIsRUFBd0IrdkIsS0FBeEIsQ0FBUCxNQUE0Q3Z1QixTQUE1RSxFQUF3RjtBQUN2RixZQUFPL0IsR0FBUDtBQUNBOztBQUVEO0FBQ0EsV0FBT2tjLE1BQU8zYSxJQUFQLENBQVA7QUFDQTtBQUNELEdBdkdZOztBQXlHYmtkLE9BQUssYUFBVWxlLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQit1QixLQUF0QixFQUE2QkUsTUFBN0IsRUFBc0M7QUFDMUMsT0FBSTN3QixHQUFKO0FBQUEsT0FBU3NPLEdBQVQ7QUFBQSxPQUFjMFAsS0FBZDtBQUFBLE9BQ0NrUyxXQUFXcnhCLE9BQU80RSxTQUFQLENBQWtCL0IsSUFBbEIsQ0FEWjs7QUFHQTtBQUNBQSxVQUFPN0MsT0FBT215QixRQUFQLENBQWlCZCxRQUFqQixNQUFpQ3J4QixPQUFPbXlCLFFBQVAsQ0FBaUJkLFFBQWpCLElBQThCRixlQUFnQnR2QixLQUFLMmIsS0FBckIsRUFBNEI2VCxRQUE1QixDQUEvRCxDQUFQOztBQUVBO0FBQ0E7QUFDQWxTLFdBQVFuZixPQUFPaXlCLFFBQVAsQ0FBaUJwdkIsSUFBakIsS0FBMkI3QyxPQUFPaXlCLFFBQVAsQ0FBaUJaLFFBQWpCLENBQW5DOztBQUVBO0FBQ0EsT0FBS2xTLFNBQVMsU0FBU0EsS0FBdkIsRUFBK0I7QUFDOUIxUCxVQUFNMFAsTUFBTWplLEdBQU4sQ0FBV1csSUFBWCxFQUFpQixJQUFqQixFQUF1Qit2QixLQUF2QixDQUFOO0FBQ0E7O0FBRUQ7QUFDQSxPQUFLbmlCLFFBQVFwTSxTQUFiLEVBQXlCO0FBQ3hCb00sVUFBTTRlLE9BQVF4c0IsSUFBUixFQUFjZ0IsSUFBZCxFQUFvQml2QixNQUFwQixDQUFOO0FBQ0E7O0FBRUQ7QUFDQSxPQUFLcmlCLFFBQVEsUUFBUixJQUFvQjVNLFFBQVFrdUIsa0JBQWpDLEVBQXNEO0FBQ3JEdGhCLFVBQU1zaEIsbUJBQW9CbHVCLElBQXBCLENBQU47QUFDQTs7QUFFRDtBQUNBLE9BQUsrdUIsVUFBVSxFQUFWLElBQWdCQSxLQUFyQixFQUE2QjtBQUM1Qnp3QixVQUFNZ0QsV0FBWXNMLEdBQVosQ0FBTjtBQUNBLFdBQU9taUIsVUFBVSxJQUFWLElBQWtCNXhCLE9BQU9rRSxTQUFQLENBQWtCL0MsR0FBbEIsQ0FBbEIsR0FBNENBLE9BQU8sQ0FBbkQsR0FBdURzTyxHQUE5RDtBQUNBO0FBQ0QsVUFBT0EsR0FBUDtBQUNBO0FBeklZLEVBQWQ7O0FBNElBelAsUUFBT3lCLElBQVAsQ0FBWSxDQUFFLFFBQUYsRUFBWSxPQUFaLENBQVosRUFBbUMsVUFBVUssQ0FBVixFQUFhZSxJQUFiLEVBQW9CO0FBQ3REN0MsU0FBT2l5QixRQUFQLENBQWlCcHZCLElBQWpCLElBQTBCO0FBQ3pCM0IsUUFBSyxhQUFVVyxJQUFWLEVBQWdCMnNCLFFBQWhCLEVBQTBCb0QsS0FBMUIsRUFBa0M7QUFDdEMsUUFBS3BELFFBQUwsRUFBZ0I7QUFDZjtBQUNBO0FBQ0EsWUFBTzNzQixLQUFLOGIsV0FBTCxLQUFxQixDQUFyQixJQUEwQjhTLGFBQWExbEIsSUFBYixDQUFtQi9LLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFNBQWxCLENBQW5CLENBQTFCLEdBQ043QixPQUFPc3dCLElBQVAsQ0FBYXp1QixJQUFiLEVBQW1CK3VCLE9BQW5CLEVBQTRCLFlBQVc7QUFDdEMsYUFBT21CLGlCQUFrQmx3QixJQUFsQixFQUF3QmdCLElBQXhCLEVBQThCK3VCLEtBQTlCLENBQVA7QUFDQSxNQUZELENBRE0sR0FJTkcsaUJBQWtCbHdCLElBQWxCLEVBQXdCZ0IsSUFBeEIsRUFBOEIrdUIsS0FBOUIsQ0FKRDtBQUtBO0FBQ0QsSUFYd0I7O0FBYXpCbkYsUUFBSyxhQUFVNXFCLElBQVYsRUFBZ0JtRCxLQUFoQixFQUF1QjRzQixLQUF2QixFQUErQjtBQUNuQyxRQUFJRSxTQUFTRixTQUFTeEQsVUFBV3ZzQixJQUFYLENBQXRCO0FBQ0EsV0FBTzR2QixrQkFBbUI1dkIsSUFBbkIsRUFBeUJtRCxLQUF6QixFQUFnQzRzQixRQUN0Q0QscUJBQ0M5dkIsSUFERCxFQUVDZ0IsSUFGRCxFQUdDK3VCLEtBSEQsRUFJQzl4QixRQUFRaXdCLFNBQVIsTUFBdUIvdkIsT0FBTytmLEdBQVAsQ0FBWWxlLElBQVosRUFBa0IsV0FBbEIsRUFBK0IsS0FBL0IsRUFBc0Npd0IsTUFBdEMsTUFBbUQsWUFKM0UsRUFLQ0EsTUFMRCxDQURzQyxHQU9sQyxDQVBFLENBQVA7QUFTQTtBQXhCd0IsR0FBMUI7QUEwQkEsRUEzQkQ7O0FBNkJBLEtBQUssQ0FBQ2h5QixRQUFRNnRCLE9BQWQsRUFBd0I7QUFDdkIzdEIsU0FBT2l5QixRQUFQLENBQWdCdEUsT0FBaEIsR0FBMEI7QUFDekJ6c0IsUUFBSyxhQUFVVyxJQUFWLEVBQWdCMnNCLFFBQWhCLEVBQTJCO0FBQy9CO0FBQ0EsV0FBT2dDLFNBQVN6bEIsSUFBVCxDQUFlLENBQUN5akIsWUFBWTNzQixLQUFLK3NCLFlBQWpCLEdBQWdDL3NCLEtBQUsrc0IsWUFBTCxDQUFrQjFnQixNQUFsRCxHQUEyRHJNLEtBQUsyYixLQUFMLENBQVd0UCxNQUF2RSxLQUFrRixFQUFqRyxJQUNKLE9BQU8vSixXQUFZcUUsT0FBTzRwQixFQUFuQixDQUFULEdBQXFDLEVBRC9CLEdBRU41RCxXQUFXLEdBQVgsR0FBaUIsRUFGbEI7QUFHQSxJQU53Qjs7QUFRekIvQixRQUFLLGFBQVU1cUIsSUFBVixFQUFnQm1ELEtBQWhCLEVBQXdCO0FBQzVCLFFBQUl3WSxRQUFRM2IsS0FBSzJiLEtBQWpCO0FBQUEsUUFDQ29SLGVBQWUvc0IsS0FBSytzQixZQURyQjtBQUFBLFFBRUNqQixVQUFVM3RCLE9BQU9rRSxTQUFQLENBQWtCYyxLQUFsQixJQUE0QixtQkFBbUJBLFFBQVEsR0FBM0IsR0FBaUMsR0FBN0QsR0FBbUUsRUFGOUU7QUFBQSxRQUdDa0osU0FBUzBnQixnQkFBZ0JBLGFBQWExZ0IsTUFBN0IsSUFBdUNzUCxNQUFNdFAsTUFBN0MsSUFBdUQsRUFIakU7O0FBS0E7QUFDQTtBQUNBc1AsVUFBTUUsSUFBTixHQUFhLENBQWI7O0FBRUE7QUFDQTtBQUNBLFFBQUssQ0FBRTFZLFNBQVMsQ0FBVCxJQUFjQSxVQUFVLEVBQTFCLEtBQ0hoRixPQUFPSCxJQUFQLENBQWFxTyxPQUFPekssT0FBUCxDQUFnQjhzQixNQUFoQixFQUF3QixFQUF4QixDQUFiLE1BQWdELEVBRDdDLElBRUgvUyxNQUFNaFMsZUFGUixFQUUwQjs7QUFFekI7QUFDQTtBQUNBO0FBQ0FnUyxXQUFNaFMsZUFBTixDQUF1QixRQUF2Qjs7QUFFQTtBQUNBLFNBQUt4RyxVQUFVLEVBQVYsSUFBZ0I0cEIsZ0JBQWdCLENBQUNBLGFBQWExZ0IsTUFBbkQsRUFBNEQ7QUFDM0Q7QUFDQTtBQUNEOztBQUVEO0FBQ0FzUCxVQUFNdFAsTUFBTixHQUFlcWlCLE9BQU94bEIsSUFBUCxDQUFhbUQsTUFBYixJQUNkQSxPQUFPekssT0FBUCxDQUFnQjhzQixNQUFoQixFQUF3QjVDLE9BQXhCLENBRGMsR0FFZHpmLFNBQVMsR0FBVCxHQUFleWYsT0FGaEI7QUFHQTtBQXZDd0IsR0FBMUI7QUF5Q0E7O0FBRUQzdEIsUUFBT2l5QixRQUFQLENBQWdCNUIsV0FBaEIsR0FBOEJuQixhQUFjcHZCLFFBQVFxd0IsbUJBQXRCLEVBQzdCLFVBQVV0dUIsSUFBVixFQUFnQjJzQixRQUFoQixFQUEyQjtBQUMxQixNQUFLQSxRQUFMLEVBQWdCO0FBQ2Y7QUFDQTtBQUNBLFVBQU94dUIsT0FBT3N3QixJQUFQLENBQWF6dUIsSUFBYixFQUFtQixFQUFFLFdBQVcsY0FBYixFQUFuQixFQUNOd3NCLE1BRE0sRUFDRSxDQUFFeHNCLElBQUYsRUFBUSxhQUFSLENBREYsQ0FBUDtBQUVBO0FBQ0QsRUFSNEIsQ0FBOUI7O0FBV0E7QUFDQTdCLFFBQU95QixJQUFQLENBQVk7QUFDWDR3QixVQUFRLEVBREc7QUFFWEMsV0FBUyxFQUZFO0FBR1hDLFVBQVE7QUFIRyxFQUFaLEVBSUcsVUFBVUMsTUFBVixFQUFrQkMsTUFBbEIsRUFBMkI7QUFDN0J6eUIsU0FBT2l5QixRQUFQLENBQWlCTyxTQUFTQyxNQUExQixJQUFxQztBQUNwQ0MsV0FBUSxnQkFBVTF0QixLQUFWLEVBQWtCO0FBQ3pCLFFBQUlsRCxJQUFJLENBQVI7QUFBQSxRQUNDNndCLFdBQVcsRUFEWjs7O0FBR0M7QUFDQUMsWUFBUSxPQUFPNXRCLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLE1BQU1xQixLQUFOLENBQVksR0FBWixDQUE1QixHQUErQyxDQUFFckIsS0FBRixDQUp4RDs7QUFNQSxXQUFRbEQsSUFBSSxDQUFaLEVBQWVBLEdBQWYsRUFBcUI7QUFDcEI2d0IsY0FBVUgsU0FBUzVTLFVBQVc5ZCxDQUFYLENBQVQsR0FBMEIyd0IsTUFBcEMsSUFDQ0csTUFBTzl3QixDQUFQLEtBQWM4d0IsTUFBTzl3QixJQUFJLENBQVgsQ0FBZCxJQUFnQzh3QixNQUFPLENBQVAsQ0FEakM7QUFFQTs7QUFFRCxXQUFPRCxRQUFQO0FBQ0E7QUFkbUMsR0FBckM7O0FBaUJBLE1BQUssQ0FBQ3pFLFFBQVFuakIsSUFBUixDQUFjeW5CLE1BQWQsQ0FBTixFQUErQjtBQUM5Qnh5QixVQUFPaXlCLFFBQVAsQ0FBaUJPLFNBQVNDLE1BQTFCLEVBQW1DaEcsR0FBbkMsR0FBeUNnRixpQkFBekM7QUFDQTtBQUNELEVBekJEOztBQTJCQXp4QixRQUFPRyxFQUFQLENBQVVzQyxNQUFWLENBQWlCO0FBQ2hCc2QsT0FBSyxhQUFVbGQsSUFBVixFQUFnQm1DLEtBQWhCLEVBQXdCO0FBQzVCLFVBQU9nYixPQUFRLElBQVIsRUFBYyxVQUFVbmUsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCbUMsS0FBdEIsRUFBOEI7QUFDbEQsUUFBSThzQixNQUFKO0FBQUEsUUFBWTF2QixHQUFaO0FBQUEsUUFDQ1IsTUFBTSxFQURQO0FBQUEsUUFFQ0UsSUFBSSxDQUZMOztBQUlBLFFBQUs5QixPQUFPb0QsT0FBUCxDQUFnQlAsSUFBaEIsQ0FBTCxFQUE4QjtBQUM3Qml2QixjQUFTMUQsVUFBV3ZzQixJQUFYLENBQVQ7QUFDQU8sV0FBTVMsS0FBSzlCLE1BQVg7O0FBRUEsWUFBUWUsSUFBSU0sR0FBWixFQUFpQk4sR0FBakIsRUFBdUI7QUFDdEJGLFVBQUtpQixLQUFNZixDQUFOLENBQUwsSUFBbUI5QixPQUFPK2YsR0FBUCxDQUFZbGUsSUFBWixFQUFrQmdCLEtBQU1mLENBQU4sQ0FBbEIsRUFBNkIsS0FBN0IsRUFBb0Nnd0IsTUFBcEMsQ0FBbkI7QUFDQTs7QUFFRCxZQUFPbHdCLEdBQVA7QUFDQTs7QUFFRCxXQUFPb0QsVUFBVTNCLFNBQVYsR0FDTnJELE9BQU93ZCxLQUFQLENBQWMzYixJQUFkLEVBQW9CZ0IsSUFBcEIsRUFBMEJtQyxLQUExQixDQURNLEdBRU5oRixPQUFPK2YsR0FBUCxDQUFZbGUsSUFBWixFQUFrQmdCLElBQWxCLENBRkQ7QUFHQSxJQW5CTSxFQW1CSkEsSUFuQkksRUFtQkVtQyxLQW5CRixFQW1CU2hELFVBQVVqQixNQUFWLEdBQW1CLENBbkI1QixDQUFQO0FBb0JBLEdBdEJlO0FBdUJoQnd3QixRQUFNLGdCQUFXO0FBQ2hCLFVBQU9ELFNBQVUsSUFBVixFQUFnQixJQUFoQixDQUFQO0FBQ0EsR0F6QmU7QUEwQmhCdUIsUUFBTSxnQkFBVztBQUNoQixVQUFPdkIsU0FBVSxJQUFWLENBQVA7QUFDQSxHQTVCZTtBQTZCaEJ3QixVQUFRLGdCQUFVclksS0FBVixFQUFrQjtBQUN6QixPQUFLLE9BQU9BLEtBQVAsS0FBaUIsU0FBdEIsRUFBa0M7QUFDakMsV0FBT0EsUUFBUSxLQUFLOFcsSUFBTCxFQUFSLEdBQXNCLEtBQUtzQixJQUFMLEVBQTdCO0FBQ0E7O0FBRUQsVUFBTyxLQUFLcHhCLElBQUwsQ0FBVSxZQUFXO0FBQzNCLFFBQUtvZSxTQUFVLElBQVYsQ0FBTCxFQUF3QjtBQUN2QjdmLFlBQVEsSUFBUixFQUFldXhCLElBQWY7QUFDQSxLQUZELE1BRU87QUFDTnZ4QixZQUFRLElBQVIsRUFBZTZ5QixJQUFmO0FBQ0E7QUFDRCxJQU5NLENBQVA7QUFPQTtBQXpDZSxFQUFqQjs7QUE2Q0EsVUFBU0UsS0FBVCxDQUFnQmx4QixJQUFoQixFQUFzQmlCLE9BQXRCLEVBQStCK2hCLElBQS9CLEVBQXFDdmlCLEdBQXJDLEVBQTBDMHdCLE1BQTFDLEVBQW1EO0FBQ2xELFNBQU8sSUFBSUQsTUFBTW55QixTQUFOLENBQWdCUixJQUFwQixDQUEwQnlCLElBQTFCLEVBQWdDaUIsT0FBaEMsRUFBeUMraEIsSUFBekMsRUFBK0N2aUIsR0FBL0MsRUFBb0Qwd0IsTUFBcEQsQ0FBUDtBQUNBO0FBQ0RoekIsUUFBTyt5QixLQUFQLEdBQWVBLEtBQWY7O0FBRUFBLE9BQU1ueUIsU0FBTixHQUFrQjtBQUNqQkUsZUFBYWl5QixLQURJO0FBRWpCM3lCLFFBQU0sY0FBVXlCLElBQVYsRUFBZ0JpQixPQUFoQixFQUF5QitoQixJQUF6QixFQUErQnZpQixHQUEvQixFQUFvQzB3QixNQUFwQyxFQUE0Q0MsSUFBNUMsRUFBbUQ7QUFDeEQsUUFBS3B4QixJQUFMLEdBQVlBLElBQVo7QUFDQSxRQUFLZ2pCLElBQUwsR0FBWUEsSUFBWjtBQUNBLFFBQUttTyxNQUFMLEdBQWNBLFVBQVUsT0FBeEI7QUFDQSxRQUFLbHdCLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFFBQUtzTyxLQUFMLEdBQWEsS0FBS2pMLEdBQUwsR0FBVyxLQUFLcUcsR0FBTCxFQUF4QjtBQUNBLFFBQUtsSyxHQUFMLEdBQVdBLEdBQVg7QUFDQSxRQUFLMndCLElBQUwsR0FBWUEsU0FBVWp6QixPQUFPa3lCLFNBQVAsQ0FBa0JyTixJQUFsQixJQUEyQixFQUEzQixHQUFnQyxJQUExQyxDQUFaO0FBQ0EsR0FWZ0I7QUFXakJyWSxPQUFLLGVBQVc7QUFDZixPQUFJMlMsUUFBUTRULE1BQU1HLFNBQU4sQ0FBaUIsS0FBS3JPLElBQXRCLENBQVo7O0FBRUEsVUFBTzFGLFNBQVNBLE1BQU1qZSxHQUFmLEdBQ05pZSxNQUFNamUsR0FBTixDQUFXLElBQVgsQ0FETSxHQUVONnhCLE1BQU1HLFNBQU4sQ0FBZ0JoUCxRQUFoQixDQUF5QmhqQixHQUF6QixDQUE4QixJQUE5QixDQUZEO0FBR0EsR0FqQmdCO0FBa0JqQml5QixPQUFLLGFBQVVDLE9BQVYsRUFBb0I7QUFDeEIsT0FBSUMsS0FBSjtBQUFBLE9BQ0NsVSxRQUFRNFQsTUFBTUcsU0FBTixDQUFpQixLQUFLck8sSUFBdEIsQ0FEVDs7QUFHQSxPQUFLLEtBQUsvaEIsT0FBTCxDQUFhd3dCLFFBQWxCLEVBQTZCO0FBQzVCLFNBQUtyYixHQUFMLEdBQVdvYixRQUFRcnpCLE9BQU9nekIsTUFBUCxDQUFlLEtBQUtBLE1BQXBCLEVBQ2xCSSxPQURrQixFQUNULEtBQUt0d0IsT0FBTCxDQUFhd3dCLFFBQWIsR0FBd0JGLE9BRGYsRUFDd0IsQ0FEeEIsRUFDMkIsQ0FEM0IsRUFDOEIsS0FBS3R3QixPQUFMLENBQWF3d0IsUUFEM0MsQ0FBbkI7QUFHQSxJQUpELE1BSU87QUFDTixTQUFLcmIsR0FBTCxHQUFXb2IsUUFBUUQsT0FBbkI7QUFDQTtBQUNELFFBQUtqdEIsR0FBTCxHQUFXLENBQUUsS0FBSzdELEdBQUwsR0FBVyxLQUFLOE8sS0FBbEIsSUFBNEJpaUIsS0FBNUIsR0FBb0MsS0FBS2ppQixLQUFwRDs7QUFFQSxPQUFLLEtBQUt0TyxPQUFMLENBQWF5d0IsSUFBbEIsRUFBeUI7QUFDeEIsU0FBS3p3QixPQUFMLENBQWF5d0IsSUFBYixDQUFrQnR5QixJQUFsQixDQUF3QixLQUFLWSxJQUE3QixFQUFtQyxLQUFLc0UsR0FBeEMsRUFBNkMsSUFBN0M7QUFDQTs7QUFFRCxPQUFLZ1osU0FBU0EsTUFBTXNOLEdBQXBCLEVBQTBCO0FBQ3pCdE4sVUFBTXNOLEdBQU4sQ0FBVyxJQUFYO0FBQ0EsSUFGRCxNQUVPO0FBQ05zRyxVQUFNRyxTQUFOLENBQWdCaFAsUUFBaEIsQ0FBeUJ1SSxHQUF6QixDQUE4QixJQUE5QjtBQUNBO0FBQ0QsVUFBTyxJQUFQO0FBQ0E7QUF6Q2dCLEVBQWxCOztBQTRDQXNHLE9BQU1ueUIsU0FBTixDQUFnQlIsSUFBaEIsQ0FBcUJRLFNBQXJCLEdBQWlDbXlCLE1BQU1ueUIsU0FBdkM7O0FBRUFteUIsT0FBTUcsU0FBTixHQUFrQjtBQUNqQmhQLFlBQVU7QUFDVGhqQixRQUFLLGFBQVVzeUIsS0FBVixFQUFrQjtBQUN0QixRQUFJNWlCLE1BQUo7O0FBRUEsUUFBSzRpQixNQUFNM3hCLElBQU4sQ0FBWTJ4QixNQUFNM08sSUFBbEIsS0FBNEIsSUFBNUIsS0FDSCxDQUFDMk8sTUFBTTN4QixJQUFOLENBQVcyYixLQUFaLElBQXFCZ1csTUFBTTN4QixJQUFOLENBQVcyYixLQUFYLENBQWtCZ1csTUFBTTNPLElBQXhCLEtBQWtDLElBRHBELENBQUwsRUFDaUU7QUFDaEUsWUFBTzJPLE1BQU0zeEIsSUFBTixDQUFZMnhCLE1BQU0zTyxJQUFsQixDQUFQO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQWpVLGFBQVM1USxPQUFPK2YsR0FBUCxDQUFZeVQsTUFBTTN4QixJQUFsQixFQUF3QjJ4QixNQUFNM08sSUFBOUIsRUFBb0MsRUFBcEMsQ0FBVDtBQUNBO0FBQ0EsV0FBTyxDQUFDalUsTUFBRCxJQUFXQSxXQUFXLE1BQXRCLEdBQStCLENBQS9CLEdBQW1DQSxNQUExQztBQUNBLElBaEJRO0FBaUJUNmIsUUFBSyxhQUFVK0csS0FBVixFQUFrQjtBQUN0QjtBQUNBO0FBQ0EsUUFBS3h6QixPQUFPeXpCLEVBQVAsQ0FBVUYsSUFBVixDQUFnQkMsTUFBTTNPLElBQXRCLENBQUwsRUFBb0M7QUFDbkM3a0IsWUFBT3l6QixFQUFQLENBQVVGLElBQVYsQ0FBZ0JDLE1BQU0zTyxJQUF0QixFQUE4QjJPLEtBQTlCO0FBQ0EsS0FGRCxNQUVPLElBQUtBLE1BQU0zeEIsSUFBTixDQUFXMmIsS0FBWCxLQUFzQmdXLE1BQU0zeEIsSUFBTixDQUFXMmIsS0FBWCxDQUFrQnhkLE9BQU9teUIsUUFBUCxDQUFpQnFCLE1BQU0zTyxJQUF2QixDQUFsQixLQUFxRCxJQUFyRCxJQUE2RDdrQixPQUFPaXlCLFFBQVAsQ0FBaUJ1QixNQUFNM08sSUFBdkIsQ0FBbkYsQ0FBTCxFQUEwSDtBQUNoSTdrQixZQUFPd2QsS0FBUCxDQUFjZ1csTUFBTTN4QixJQUFwQixFQUEwQjJ4QixNQUFNM08sSUFBaEMsRUFBc0MyTyxNQUFNcnRCLEdBQU4sR0FBWXF0QixNQUFNUCxJQUF4RDtBQUNBLEtBRk0sTUFFQTtBQUNOTyxXQUFNM3hCLElBQU4sQ0FBWTJ4QixNQUFNM08sSUFBbEIsSUFBMkIyTyxNQUFNcnRCLEdBQWpDO0FBQ0E7QUFDRDtBQTNCUTtBQURPLEVBQWxCOztBQWdDQTtBQUNBOztBQUVBNHNCLE9BQU1HLFNBQU4sQ0FBZ0JoTixTQUFoQixHQUE0QjZNLE1BQU1HLFNBQU4sQ0FBZ0JwTixVQUFoQixHQUE2QjtBQUN4RDJHLE9BQUssYUFBVStHLEtBQVYsRUFBa0I7QUFDdEIsT0FBS0EsTUFBTTN4QixJQUFOLENBQVd5QyxRQUFYLElBQXVCa3ZCLE1BQU0zeEIsSUFBTixDQUFXNkksVUFBdkMsRUFBb0Q7QUFDbkQ4b0IsVUFBTTN4QixJQUFOLENBQVkyeEIsTUFBTTNPLElBQWxCLElBQTJCMk8sTUFBTXJ0QixHQUFqQztBQUNBO0FBQ0Q7QUFMdUQsRUFBekQ7O0FBUUFuRyxRQUFPZ3pCLE1BQVAsR0FBZ0I7QUFDZlUsVUFBUSxnQkFBVUMsQ0FBVixFQUFjO0FBQ3JCLFVBQU9BLENBQVA7QUFDQSxHQUhjO0FBSWZDLFNBQU8sZUFBVUQsQ0FBVixFQUFjO0FBQ3BCLFVBQU8sTUFBTXB3QixLQUFLc3dCLEdBQUwsQ0FBVUYsSUFBSXB3QixLQUFLdXdCLEVBQW5CLElBQTBCLENBQXZDO0FBQ0E7QUFOYyxFQUFoQjs7QUFTQTl6QixRQUFPeXpCLEVBQVAsR0FBWVYsTUFBTW55QixTQUFOLENBQWdCUixJQUE1Qjs7QUFFQTtBQUNBSixRQUFPeXpCLEVBQVAsQ0FBVUYsSUFBVixHQUFpQixFQUFqQjs7QUFLQSxLQUNDUSxLQUREO0FBQUEsS0FDUUMsT0FEUjtBQUFBLEtBRUNDLFdBQVcsd0JBRlo7QUFBQSxLQUdDQyxTQUFTLElBQUkxckIsTUFBSixDQUFZLG1CQUFtQmtYLElBQW5CLEdBQTBCLGFBQXRDLEVBQXFELEdBQXJELENBSFY7QUFBQSxLQUlDeVUsT0FBTyxhQUpSO0FBQUEsS0FLQ0Msc0JBQXNCLENBQUVDLGdCQUFGLENBTHZCO0FBQUEsS0FNQ0MsV0FBVztBQUNWLE9BQUssQ0FBRSxVQUFVelAsSUFBVixFQUFnQjdmLEtBQWhCLEVBQXdCO0FBQzlCLE9BQUl3dUIsUUFBUSxLQUFLZSxXQUFMLENBQWtCMVAsSUFBbEIsRUFBd0I3ZixLQUF4QixDQUFaO0FBQUEsT0FDQ2hDLFNBQVN3d0IsTUFBTWhuQixHQUFOLEVBRFY7QUFBQSxPQUVDb21CLFFBQVFzQixPQUFPMXBCLElBQVAsQ0FBYXhGLEtBQWIsQ0FGVDtBQUFBLE9BR0NpdUIsT0FBT0wsU0FBU0EsTUFBTyxDQUFQLENBQVQsS0FBeUI1eUIsT0FBT2t5QixTQUFQLENBQWtCck4sSUFBbEIsSUFBMkIsRUFBM0IsR0FBZ0MsSUFBekQsQ0FIUjs7O0FBS0M7QUFDQXpULFdBQVEsQ0FBRXBSLE9BQU9reUIsU0FBUCxDQUFrQnJOLElBQWxCLEtBQTRCb08sU0FBUyxJQUFULElBQWlCLENBQUNqd0IsTUFBaEQsS0FDUGt4QixPQUFPMXBCLElBQVAsQ0FBYXhLLE9BQU8rZixHQUFQLENBQVl5VCxNQUFNM3hCLElBQWxCLEVBQXdCZ2pCLElBQXhCLENBQWIsQ0FQRjtBQUFBLE9BUUMyUCxRQUFRLENBUlQ7QUFBQSxPQVNDQyxnQkFBZ0IsRUFUakI7O0FBV0EsT0FBS3JqQixTQUFTQSxNQUFPLENBQVAsTUFBZTZoQixJQUE3QixFQUFvQztBQUNuQztBQUNBQSxXQUFPQSxRQUFRN2hCLE1BQU8sQ0FBUCxDQUFmOztBQUVBO0FBQ0F3aEIsWUFBUUEsU0FBUyxFQUFqQjs7QUFFQTtBQUNBeGhCLFlBQVEsQ0FBQ3BPLE1BQUQsSUFBVyxDQUFuQjs7QUFFQSxPQUFHO0FBQ0Y7QUFDQTtBQUNBd3hCLGFBQVFBLFNBQVMsSUFBakI7O0FBRUE7QUFDQXBqQixhQUFRQSxRQUFRb2pCLEtBQWhCO0FBQ0F4MEIsWUFBT3dkLEtBQVAsQ0FBY2dXLE1BQU0zeEIsSUFBcEIsRUFBMEJnakIsSUFBMUIsRUFBZ0N6VCxRQUFRNmhCLElBQXhDOztBQUVEO0FBQ0E7QUFDQyxLQVhELFFBV1V1QixXQUFXQSxRQUFRaEIsTUFBTWhuQixHQUFOLEtBQWN4SixNQUFqQyxLQUE0Q3d4QixVQUFVLENBQXRELElBQTJELEVBQUVDLGFBWHZFO0FBWUE7O0FBRUQ7QUFDQSxPQUFLN0IsS0FBTCxFQUFhO0FBQ1p4aEIsWUFBUW9pQixNQUFNcGlCLEtBQU4sR0FBYyxDQUFDQSxLQUFELElBQVUsQ0FBQ3BPLE1BQVgsSUFBcUIsQ0FBM0M7QUFDQXd3QixVQUFNUCxJQUFOLEdBQWFBLElBQWI7QUFDQTtBQUNBTyxVQUFNbHhCLEdBQU4sR0FBWXN3QixNQUFPLENBQVAsSUFDWHhoQixRQUFRLENBQUV3aEIsTUFBTyxDQUFQLElBQWEsQ0FBZixJQUFxQkEsTUFBTyxDQUFQLENBRGxCLEdBRVgsQ0FBQ0EsTUFBTyxDQUFQLENBRkY7QUFHQTs7QUFFRCxVQUFPWSxLQUFQO0FBQ0EsR0EvQ0k7QUFESyxFQU5aOztBQXlEQTtBQUNBLFVBQVNrQixXQUFULEdBQXVCO0FBQ3RCaFksYUFBVyxZQUFXO0FBQ3JCcVgsV0FBUTF3QixTQUFSO0FBQ0EsR0FGRDtBQUdBLFNBQVMwd0IsUUFBUS96QixPQUFPbUcsR0FBUCxFQUFqQjtBQUNBOztBQUVEO0FBQ0EsVUFBU3d1QixLQUFULENBQWdCNXdCLElBQWhCLEVBQXNCNndCLFlBQXRCLEVBQXFDO0FBQ3BDLE1BQUlyUCxLQUFKO0FBQUEsTUFDQ25aLFFBQVEsRUFBRXlvQixRQUFROXdCLElBQVYsRUFEVDtBQUFBLE1BRUNqQyxJQUFJLENBRkw7O0FBSUE7QUFDQTtBQUNBOHlCLGlCQUFlQSxlQUFlLENBQWYsR0FBbUIsQ0FBbEM7QUFDQSxTQUFROXlCLElBQUksQ0FBWixFQUFnQkEsS0FBSyxJQUFJOHlCLFlBQXpCLEVBQXdDO0FBQ3ZDclAsV0FBUTNGLFVBQVc5ZCxDQUFYLENBQVI7QUFDQXNLLFNBQU8sV0FBV21aLEtBQWxCLElBQTRCblosTUFBTyxZQUFZbVosS0FBbkIsSUFBNkJ4aEIsSUFBekQ7QUFDQTs7QUFFRCxNQUFLNndCLFlBQUwsRUFBb0I7QUFDbkJ4b0IsU0FBTXVoQixPQUFOLEdBQWdCdmhCLE1BQU02aEIsS0FBTixHQUFjbHFCLElBQTlCO0FBQ0E7O0FBRUQsU0FBT3FJLEtBQVA7QUFDQTs7QUFFRCxVQUFTbW9CLFdBQVQsQ0FBc0J2dkIsS0FBdEIsRUFBNkI2ZixJQUE3QixFQUFtQ2lRLFNBQW5DLEVBQStDO0FBQzlDLE1BQUl0QixLQUFKO0FBQUEsTUFDQ3VCLGFBQWEsQ0FBRVQsU0FBVXpQLElBQVYsS0FBb0IsRUFBdEIsRUFBMkJ2bEIsTUFBM0IsQ0FBbUNnMUIsU0FBVSxHQUFWLENBQW5DLENBRGQ7QUFBQSxNQUVDcGMsUUFBUSxDQUZUO0FBQUEsTUFHQ25YLFNBQVNnMEIsV0FBV2gwQixNQUhyQjtBQUlBLFNBQVFtWCxRQUFRblgsTUFBaEIsRUFBd0JtWCxPQUF4QixFQUFrQztBQUNqQyxPQUFNc2IsUUFBUXVCLFdBQVk3YyxLQUFaLEVBQW9CalgsSUFBcEIsQ0FBMEI2ekIsU0FBMUIsRUFBcUNqUSxJQUFyQyxFQUEyQzdmLEtBQTNDLENBQWQsRUFBb0U7O0FBRW5FO0FBQ0EsV0FBT3d1QixLQUFQO0FBQ0E7QUFDRDtBQUNEOztBQUVELFVBQVNhLGdCQUFULENBQTJCeHlCLElBQTNCLEVBQWlDc2pCLEtBQWpDLEVBQXdDNlAsSUFBeEMsRUFBK0M7QUFDOUM7QUFDQSxNQUFJblEsSUFBSjtBQUFBLE1BQVU3ZixLQUFWO0FBQUEsTUFBaUI4dEIsTUFBakI7QUFBQSxNQUF5QlUsS0FBekI7QUFBQSxNQUFnQ3JVLEtBQWhDO0FBQUEsTUFBdUM4VixPQUF2QztBQUFBLE1BQWdEN0gsT0FBaEQ7QUFBQSxNQUF5RDhILFFBQXpEO0FBQUEsTUFDQ0MsT0FBTyxJQURSO0FBQUEsTUFFQzlOLE9BQU8sRUFGUjtBQUFBLE1BR0M3SixRQUFRM2IsS0FBSzJiLEtBSGQ7QUFBQSxNQUlDZ1UsU0FBUzN2QixLQUFLeUMsUUFBTCxJQUFpQnViLFNBQVVoZSxJQUFWLENBSjNCO0FBQUEsTUFLQ3V6QixXQUFXcDFCLE9BQU84ZSxLQUFQLENBQWNqZCxJQUFkLEVBQW9CLFFBQXBCLENBTFo7O0FBT0E7QUFDQSxNQUFLLENBQUNtekIsS0FBS2hXLEtBQVgsRUFBbUI7QUFDbEJHLFdBQVFuZixPQUFPb2YsV0FBUCxDQUFvQnZkLElBQXBCLEVBQTBCLElBQTFCLENBQVI7QUFDQSxPQUFLc2QsTUFBTWtXLFFBQU4sSUFBa0IsSUFBdkIsRUFBOEI7QUFDN0JsVyxVQUFNa1csUUFBTixHQUFpQixDQUFqQjtBQUNBSixjQUFVOVYsTUFBTWpGLEtBQU4sQ0FBWUosSUFBdEI7QUFDQXFGLFVBQU1qRixLQUFOLENBQVlKLElBQVosR0FBbUIsWUFBVztBQUM3QixTQUFLLENBQUNxRixNQUFNa1csUUFBWixFQUF1QjtBQUN0Qko7QUFDQTtBQUNELEtBSkQ7QUFLQTtBQUNEOVYsU0FBTWtXLFFBQU47O0FBRUFGLFFBQUt4YSxNQUFMLENBQVksWUFBVztBQUN0QjtBQUNBO0FBQ0F3YSxTQUFLeGEsTUFBTCxDQUFZLFlBQVc7QUFDdEJ3RSxXQUFNa1csUUFBTjtBQUNBLFNBQUssQ0FBQ3IxQixPQUFPZ2YsS0FBUCxDQUFjbmQsSUFBZCxFQUFvQixJQUFwQixFQUEyQmQsTUFBakMsRUFBMEM7QUFDekNvZSxZQUFNakYsS0FBTixDQUFZSixJQUFaO0FBQ0E7QUFDRCxLQUxEO0FBTUEsSUFURDtBQVVBOztBQUVEO0FBQ0EsTUFBS2pZLEtBQUt5QyxRQUFMLEtBQWtCLENBQWxCLEtBQXlCLFlBQVk2Z0IsS0FBWixJQUFxQixXQUFXQSxLQUF6RCxDQUFMLEVBQXdFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E2UCxRQUFLTSxRQUFMLEdBQWdCLENBQUU5WCxNQUFNOFgsUUFBUixFQUFrQjlYLE1BQU0rWCxTQUF4QixFQUFtQy9YLE1BQU1nWSxTQUF6QyxDQUFoQjs7QUFFQTtBQUNBO0FBQ0FwSSxhQUFVcHRCLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFNBQWxCLENBQVY7QUFDQXF6QixjQUFXNUgsZUFBZ0J6ckIsS0FBS2lELFFBQXJCLENBQVg7QUFDQSxPQUFLc29CLFlBQVksTUFBakIsRUFBMEI7QUFDekJBLGNBQVU4SCxRQUFWO0FBQ0E7QUFDRCxPQUFLOUgsWUFBWSxRQUFaLElBQ0hwdEIsT0FBTytmLEdBQVAsQ0FBWWxlLElBQVosRUFBa0IsT0FBbEIsTUFBZ0MsTUFEbEMsRUFDMkM7O0FBRTFDO0FBQ0E7QUFDQSxRQUFLLENBQUMvQixRQUFRd2Qsc0JBQVQsSUFBbUM0WCxhQUFhLFFBQXJELEVBQWdFO0FBQy9EMVgsV0FBTTRQLE9BQU4sR0FBZ0IsY0FBaEI7QUFDQSxLQUZELE1BRU87QUFDTjVQLFdBQU1FLElBQU4sR0FBYSxDQUFiO0FBQ0E7QUFDRDtBQUNEOztBQUVELE1BQUtzWCxLQUFLTSxRQUFWLEVBQXFCO0FBQ3BCOVgsU0FBTThYLFFBQU4sR0FBaUIsUUFBakI7QUFDQSxPQUFLLENBQUN4MUIsUUFBUWl1QixnQkFBUixFQUFOLEVBQW1DO0FBQ2xDb0gsU0FBS3hhLE1BQUwsQ0FBWSxZQUFXO0FBQ3RCNkMsV0FBTThYLFFBQU4sR0FBaUJOLEtBQUtNLFFBQUwsQ0FBZSxDQUFmLENBQWpCO0FBQ0E5WCxXQUFNK1gsU0FBTixHQUFrQlAsS0FBS00sUUFBTCxDQUFlLENBQWYsQ0FBbEI7QUFDQTlYLFdBQU1nWSxTQUFOLEdBQWtCUixLQUFLTSxRQUFMLENBQWUsQ0FBZixDQUFsQjtBQUNBLEtBSkQ7QUFLQTtBQUNEOztBQUVEO0FBQ0EsT0FBTXpRLElBQU4sSUFBY00sS0FBZCxFQUFzQjtBQUNyQm5nQixXQUFRbWdCLE1BQU9OLElBQVAsQ0FBUjtBQUNBLE9BQUtvUCxTQUFTenBCLElBQVQsQ0FBZXhGLEtBQWYsQ0FBTCxFQUE4QjtBQUM3QixXQUFPbWdCLE1BQU9OLElBQVAsQ0FBUDtBQUNBaU8sYUFBU0EsVUFBVTl0QixVQUFVLFFBQTdCO0FBQ0EsUUFBS0EsV0FBWXdzQixTQUFTLE1BQVQsR0FBa0IsTUFBOUIsQ0FBTCxFQUE4Qzs7QUFFN0M7QUFDQSxTQUFLeHNCLFVBQVUsTUFBVixJQUFvQm93QixRQUFwQixJQUFnQ0EsU0FBVXZRLElBQVYsTUFBcUJ4aEIsU0FBMUQsRUFBc0U7QUFDckVtdUIsZUFBUyxJQUFUO0FBQ0EsTUFGRCxNQUVPO0FBQ047QUFDQTtBQUNEO0FBQ0RuSyxTQUFNeEMsSUFBTixJQUFldVEsWUFBWUEsU0FBVXZRLElBQVYsQ0FBWixJQUFnQzdrQixPQUFPd2QsS0FBUCxDQUFjM2IsSUFBZCxFQUFvQmdqQixJQUFwQixDQUEvQztBQUNBO0FBQ0Q7O0FBRUQsTUFBSyxDQUFDN2tCLE9BQU9vRSxhQUFQLENBQXNCaWpCLElBQXRCLENBQU4sRUFBcUM7QUFDcEMsT0FBSytOLFFBQUwsRUFBZ0I7QUFDZixRQUFLLFlBQVlBLFFBQWpCLEVBQTRCO0FBQzNCNUQsY0FBUzRELFNBQVM1RCxNQUFsQjtBQUNBO0FBQ0QsSUFKRCxNQUlPO0FBQ040RCxlQUFXcDFCLE9BQU84ZSxLQUFQLENBQWNqZCxJQUFkLEVBQW9CLFFBQXBCLEVBQThCLEVBQTlCLENBQVg7QUFDQTs7QUFFRDtBQUNBLE9BQUtpeEIsTUFBTCxFQUFjO0FBQ2JzQyxhQUFTNUQsTUFBVCxHQUFrQixDQUFDQSxNQUFuQjtBQUNBO0FBQ0QsT0FBS0EsTUFBTCxFQUFjO0FBQ2J4eEIsV0FBUTZCLElBQVIsRUFBZTB2QixJQUFmO0FBQ0EsSUFGRCxNQUVPO0FBQ040RCxTQUFLN3RCLElBQUwsQ0FBVSxZQUFXO0FBQ3BCdEgsWUFBUTZCLElBQVIsRUFBZWd4QixJQUFmO0FBQ0EsS0FGRDtBQUdBO0FBQ0RzQyxRQUFLN3RCLElBQUwsQ0FBVSxZQUFXO0FBQ3BCLFFBQUl1ZCxJQUFKO0FBQ0E3a0IsV0FBTytlLFdBQVAsQ0FBb0JsZCxJQUFwQixFQUEwQixRQUExQjtBQUNBLFNBQU1nakIsSUFBTixJQUFjd0MsSUFBZCxFQUFxQjtBQUNwQnJuQixZQUFPd2QsS0FBUCxDQUFjM2IsSUFBZCxFQUFvQmdqQixJQUFwQixFQUEwQndDLEtBQU14QyxJQUFOLENBQTFCO0FBQ0E7QUFDRCxJQU5EO0FBT0EsUUFBTUEsSUFBTixJQUFjd0MsSUFBZCxFQUFxQjtBQUNwQm1NLFlBQVFlLFlBQWEvQyxTQUFTNEQsU0FBVXZRLElBQVYsQ0FBVCxHQUE0QixDQUF6QyxFQUE0Q0EsSUFBNUMsRUFBa0RzUSxJQUFsRCxDQUFSOztBQUVBLFFBQUssRUFBR3RRLFFBQVF1USxRQUFYLENBQUwsRUFBNkI7QUFDNUJBLGNBQVV2USxJQUFWLElBQW1CMk8sTUFBTXBpQixLQUF6QjtBQUNBLFNBQUtvZ0IsTUFBTCxFQUFjO0FBQ2JnQyxZQUFNbHhCLEdBQU4sR0FBWWt4QixNQUFNcGlCLEtBQWxCO0FBQ0FvaUIsWUFBTXBpQixLQUFOLEdBQWN5VCxTQUFTLE9BQVQsSUFBb0JBLFNBQVMsUUFBN0IsR0FBd0MsQ0FBeEMsR0FBNEMsQ0FBMUQ7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFVBQVM0USxVQUFULENBQXFCdFEsS0FBckIsRUFBNEJ1USxhQUE1QixFQUE0QztBQUMzQyxNQUFJeGQsS0FBSixFQUFXclYsSUFBWCxFQUFpQm13QixNQUFqQixFQUF5Qmh1QixLQUF6QixFQUFnQ21hLEtBQWhDOztBQUVBO0FBQ0EsT0FBTWpILEtBQU4sSUFBZWlOLEtBQWYsRUFBdUI7QUFDdEJ0aUIsVUFBTzdDLE9BQU80RSxTQUFQLENBQWtCc1QsS0FBbEIsQ0FBUDtBQUNBOGEsWUFBUzBDLGNBQWU3eUIsSUFBZixDQUFUO0FBQ0FtQyxXQUFRbWdCLE1BQU9qTixLQUFQLENBQVI7QUFDQSxPQUFLbFksT0FBT29ELE9BQVAsQ0FBZ0I0QixLQUFoQixDQUFMLEVBQStCO0FBQzlCZ3VCLGFBQVNodUIsTUFBTyxDQUFQLENBQVQ7QUFDQUEsWUFBUW1nQixNQUFPak4sS0FBUCxJQUFpQmxULE1BQU8sQ0FBUCxDQUF6QjtBQUNBOztBQUVELE9BQUtrVCxVQUFVclYsSUFBZixFQUFzQjtBQUNyQnNpQixVQUFPdGlCLElBQVAsSUFBZ0JtQyxLQUFoQjtBQUNBLFdBQU9tZ0IsTUFBT2pOLEtBQVAsQ0FBUDtBQUNBOztBQUVEaUgsV0FBUW5mLE9BQU9peUIsUUFBUCxDQUFpQnB2QixJQUFqQixDQUFSO0FBQ0EsT0FBS3NjLFNBQVMsWUFBWUEsS0FBMUIsRUFBa0M7QUFDakNuYSxZQUFRbWEsTUFBTXVULE1BQU4sQ0FBYzF0QixLQUFkLENBQVI7QUFDQSxXQUFPbWdCLE1BQU90aUIsSUFBUCxDQUFQOztBQUVBO0FBQ0E7QUFDQSxTQUFNcVYsS0FBTixJQUFlbFQsS0FBZixFQUF1QjtBQUN0QixTQUFLLEVBQUdrVCxTQUFTaU4sS0FBWixDQUFMLEVBQTJCO0FBQzFCQSxZQUFPak4sS0FBUCxJQUFpQmxULE1BQU9rVCxLQUFQLENBQWpCO0FBQ0F3ZCxvQkFBZXhkLEtBQWYsSUFBeUI4YSxNQUF6QjtBQUNBO0FBQ0Q7QUFDRCxJQVpELE1BWU87QUFDTjBDLGtCQUFlN3lCLElBQWYsSUFBd0Jtd0IsTUFBeEI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsVUFBUzJDLFNBQVQsQ0FBb0I5ekIsSUFBcEIsRUFBMEIrekIsVUFBMUIsRUFBc0M5eUIsT0FBdEMsRUFBZ0Q7QUFDL0MsTUFBSThOLE1BQUo7QUFBQSxNQUNDaWxCLE9BREQ7QUFBQSxNQUVDM2QsUUFBUSxDQUZUO0FBQUEsTUFHQ25YLFNBQVNxekIsb0JBQW9CcnpCLE1BSDlCO0FBQUEsTUFJQzZaLFdBQVc1YSxPQUFPc2EsUUFBUCxHQUFrQkssTUFBbEIsQ0FBMEIsWUFBVztBQUMvQztBQUNBLFVBQU9tYixLQUFLajBCLElBQVo7QUFDQSxHQUhVLENBSlo7QUFBQSxNQVFDaTBCLE9BQU8sU0FBUEEsSUFBTyxHQUFXO0FBQ2pCLE9BQUtELE9BQUwsRUFBZTtBQUNkLFdBQU8sS0FBUDtBQUNBO0FBQ0QsT0FBSUUsY0FBY2hDLFNBQVNXLGFBQTNCO0FBQUEsT0FDQzlZLFlBQVlyWSxLQUFLaUMsR0FBTCxDQUFVLENBQVYsRUFBYXN2QixVQUFVa0IsU0FBVixHQUFzQmxCLFVBQVV4QixRQUFoQyxHQUEyQ3lDLFdBQXhELENBRGI7O0FBRUM7QUFDQXhoQixVQUFPcUgsWUFBWWtaLFVBQVV4QixRQUF0QixJQUFrQyxDQUgxQztBQUFBLE9BSUNGLFVBQVUsSUFBSTdlLElBSmY7QUFBQSxPQUtDMkQsUUFBUSxDQUxUO0FBQUEsT0FNQ25YLFNBQVMrekIsVUFBVW1CLE1BQVYsQ0FBaUJsMUIsTUFOM0I7O0FBUUEsVUFBUW1YLFFBQVFuWCxNQUFoQixFQUF5Qm1YLE9BQXpCLEVBQW1DO0FBQ2xDNGMsY0FBVW1CLE1BQVYsQ0FBa0IvZCxLQUFsQixFQUEwQmliLEdBQTFCLENBQStCQyxPQUEvQjtBQUNBOztBQUVEeFksWUFBU29CLFVBQVQsQ0FBcUJuYSxJQUFyQixFQUEyQixDQUFFaXpCLFNBQUYsRUFBYTFCLE9BQWIsRUFBc0J4WCxTQUF0QixDQUEzQjs7QUFFQSxPQUFLd1gsVUFBVSxDQUFWLElBQWVyeUIsTUFBcEIsRUFBNkI7QUFDNUIsV0FBTzZhLFNBQVA7QUFDQSxJQUZELE1BRU87QUFDTmhCLGFBQVNxQixXQUFULENBQXNCcGEsSUFBdEIsRUFBNEIsQ0FBRWl6QixTQUFGLENBQTVCO0FBQ0EsV0FBTyxLQUFQO0FBQ0E7QUFDRCxHQWhDRjtBQUFBLE1BaUNDQSxZQUFZbGEsU0FBU0YsT0FBVCxDQUFpQjtBQUM1QjdZLFNBQU1BLElBRHNCO0FBRTVCc2pCLFVBQU9ubEIsT0FBT3lDLE1BQVAsQ0FBZSxFQUFmLEVBQW1CbXpCLFVBQW5CLENBRnFCO0FBRzVCWixTQUFNaDFCLE9BQU95QyxNQUFQLENBQWUsSUFBZixFQUFxQixFQUFFaXpCLGVBQWUsRUFBakIsRUFBckIsRUFBNEM1eUIsT0FBNUMsQ0FIc0I7QUFJNUJvekIsdUJBQW9CTixVQUpRO0FBSzVCTyxvQkFBaUJyekIsT0FMVztBQU01Qmt6QixjQUFXakMsU0FBU1csYUFOUTtBQU81QnBCLGFBQVV4d0IsUUFBUXd3QixRQVBVO0FBUTVCMkMsV0FBUSxFQVJvQjtBQVM1QjFCLGdCQUFhLHFCQUFVMVAsSUFBVixFQUFnQnZpQixHQUFoQixFQUFzQjtBQUNsQyxRQUFJa3hCLFFBQVF4ekIsT0FBTyt5QixLQUFQLENBQWNseEIsSUFBZCxFQUFvQml6QixVQUFVRSxJQUE5QixFQUFvQ25RLElBQXBDLEVBQTBDdmlCLEdBQTFDLEVBQ1Z3eUIsVUFBVUUsSUFBVixDQUFlVSxhQUFmLENBQThCN1EsSUFBOUIsS0FBd0NpUSxVQUFVRSxJQUFWLENBQWVoQyxNQUQ3QyxDQUFaO0FBRUE4QixjQUFVbUIsTUFBVixDQUFpQjEyQixJQUFqQixDQUF1QmkwQixLQUF2QjtBQUNBLFdBQU9BLEtBQVA7QUFDQSxJQWQyQjtBQWU1Qm5VLFNBQU0sY0FBVStXLE9BQVYsRUFBb0I7QUFDekIsUUFBSWxlLFFBQVEsQ0FBWjs7QUFDQztBQUNBO0FBQ0FuWCxhQUFTcTFCLFVBQVV0QixVQUFVbUIsTUFBVixDQUFpQmwxQixNQUEzQixHQUFvQyxDQUg5QztBQUlBLFFBQUs4MEIsT0FBTCxFQUFlO0FBQ2QsWUFBTyxJQUFQO0FBQ0E7QUFDREEsY0FBVSxJQUFWO0FBQ0EsV0FBUTNkLFFBQVFuWCxNQUFoQixFQUF5Qm1YLE9BQXpCLEVBQW1DO0FBQ2xDNGMsZUFBVW1CLE1BQVYsQ0FBa0IvZCxLQUFsQixFQUEwQmliLEdBQTFCLENBQStCLENBQS9CO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLFFBQUtpRCxPQUFMLEVBQWU7QUFDZHhiLGNBQVNxQixXQUFULENBQXNCcGEsSUFBdEIsRUFBNEIsQ0FBRWl6QixTQUFGLEVBQWFzQixPQUFiLENBQTVCO0FBQ0EsS0FGRCxNQUVPO0FBQ054YixjQUFTeWIsVUFBVCxDQUFxQngwQixJQUFyQixFQUEyQixDQUFFaXpCLFNBQUYsRUFBYXNCLE9BQWIsQ0FBM0I7QUFDQTtBQUNELFdBQU8sSUFBUDtBQUNBO0FBcEMyQixHQUFqQixDQWpDYjtBQUFBLE1BdUVDalIsUUFBUTJQLFVBQVUzUCxLQXZFbkI7O0FBeUVBc1EsYUFBWXRRLEtBQVosRUFBbUIyUCxVQUFVRSxJQUFWLENBQWVVLGFBQWxDOztBQUVBLFNBQVF4ZCxRQUFRblgsTUFBaEIsRUFBeUJtWCxPQUF6QixFQUFtQztBQUNsQ3RILFlBQVN3akIsb0JBQXFCbGMsS0FBckIsRUFBNkJqWCxJQUE3QixDQUFtQzZ6QixTQUFuQyxFQUE4Q2p6QixJQUE5QyxFQUFvRHNqQixLQUFwRCxFQUEyRDJQLFVBQVVFLElBQXJFLENBQVQ7QUFDQSxPQUFLcGtCLE1BQUwsRUFBYztBQUNiLFdBQU9BLE1BQVA7QUFDQTtBQUNEOztBQUVENVEsU0FBTzRCLEdBQVAsQ0FBWXVqQixLQUFaLEVBQW1Cb1AsV0FBbkIsRUFBZ0NPLFNBQWhDOztBQUVBLE1BQUs5MEIsT0FBT2tELFVBQVAsQ0FBbUI0eEIsVUFBVUUsSUFBVixDQUFlNWpCLEtBQWxDLENBQUwsRUFBaUQ7QUFDaEQwakIsYUFBVUUsSUFBVixDQUFlNWpCLEtBQWYsQ0FBcUJuUSxJQUFyQixDQUEyQlksSUFBM0IsRUFBaUNpekIsU0FBakM7QUFDQTs7QUFFRDkwQixTQUFPeXpCLEVBQVAsQ0FBVTZDLEtBQVYsQ0FDQ3QyQixPQUFPeUMsTUFBUCxDQUFlcXpCLElBQWYsRUFBcUI7QUFDcEJqMEIsU0FBTUEsSUFEYztBQUVwQnN6QixTQUFNTCxTQUZjO0FBR3BCOVYsVUFBTzhWLFVBQVVFLElBQVYsQ0FBZWhXO0FBSEYsR0FBckIsQ0FERDs7QUFRQTtBQUNBLFNBQU84VixVQUFVelosUUFBVixDQUFvQnlaLFVBQVVFLElBQVYsQ0FBZTNaLFFBQW5DLEVBQ0wvVCxJQURLLENBQ0N3dEIsVUFBVUUsSUFBVixDQUFlMXRCLElBRGhCLEVBQ3NCd3RCLFVBQVVFLElBQVYsQ0FBZXVCLFFBRHJDLEVBRUwxYixJQUZLLENBRUNpYSxVQUFVRSxJQUFWLENBQWVuYSxJQUZoQixFQUdMRixNQUhLLENBR0dtYSxVQUFVRSxJQUFWLENBQWVyYSxNQUhsQixDQUFQO0FBSUE7O0FBRUQzYSxRQUFPMjFCLFNBQVAsR0FBbUIzMUIsT0FBT3lDLE1BQVAsQ0FBZWt6QixTQUFmLEVBQTBCO0FBQzVDYSxXQUFTLGlCQUFVclIsS0FBVixFQUFpQnpqQixRQUFqQixFQUE0QjtBQUNwQyxPQUFLMUIsT0FBT2tELFVBQVAsQ0FBbUJpaUIsS0FBbkIsQ0FBTCxFQUFrQztBQUNqQ3pqQixlQUFXeWpCLEtBQVg7QUFDQUEsWUFBUSxDQUFFLEdBQUYsQ0FBUjtBQUNBLElBSEQsTUFHTztBQUNOQSxZQUFRQSxNQUFNOWUsS0FBTixDQUFZLEdBQVosQ0FBUjtBQUNBOztBQUVELE9BQUl3ZSxJQUFKO0FBQUEsT0FDQzNNLFFBQVEsQ0FEVDtBQUFBLE9BRUNuWCxTQUFTb2tCLE1BQU1wa0IsTUFGaEI7O0FBSUEsVUFBUW1YLFFBQVFuWCxNQUFoQixFQUF5Qm1YLE9BQXpCLEVBQW1DO0FBQ2xDMk0sV0FBT00sTUFBT2pOLEtBQVAsQ0FBUDtBQUNBb2MsYUFBVXpQLElBQVYsSUFBbUJ5UCxTQUFVelAsSUFBVixLQUFvQixFQUF2QztBQUNBeVAsYUFBVXpQLElBQVYsRUFBaUJ4VixPQUFqQixDQUEwQjNOLFFBQTFCO0FBQ0E7QUFDRCxHQWxCMkM7O0FBb0I1QyswQixhQUFXLG1CQUFVLzBCLFFBQVYsRUFBb0JzcUIsT0FBcEIsRUFBOEI7QUFDeEMsT0FBS0EsT0FBTCxFQUFlO0FBQ2RvSSx3QkFBb0Iva0IsT0FBcEIsQ0FBNkIzTixRQUE3QjtBQUNBLElBRkQsTUFFTztBQUNOMHlCLHdCQUFvQjcwQixJQUFwQixDQUEwQm1DLFFBQTFCO0FBQ0E7QUFDRDtBQTFCMkMsRUFBMUIsQ0FBbkI7O0FBNkJBMUIsUUFBTzAyQixLQUFQLEdBQWUsVUFBVUEsS0FBVixFQUFpQjFELE1BQWpCLEVBQXlCN3lCLEVBQXpCLEVBQThCO0FBQzVDLE1BQUl3MkIsTUFBTUQsU0FBUyxRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQTFCLEdBQXFDMTJCLE9BQU95QyxNQUFQLENBQWUsRUFBZixFQUFtQmkwQixLQUFuQixDQUFyQyxHQUFrRTtBQUMzRUgsYUFBVXAyQixNQUFNLENBQUNBLEVBQUQsSUFBTzZ5QixNQUFiLElBQ1RoekIsT0FBT2tELFVBQVAsQ0FBbUJ3ekIsS0FBbkIsS0FBOEJBLEtBRjRDO0FBRzNFcEQsYUFBVW9ELEtBSGlFO0FBSTNFMUQsV0FBUTd5QixNQUFNNnlCLE1BQU4sSUFBZ0JBLFVBQVUsQ0FBQ2h6QixPQUFPa0QsVUFBUCxDQUFtQjh2QixNQUFuQixDQUFYLElBQTBDQTtBQUpTLEdBQTVFOztBQU9BMkQsTUFBSXJELFFBQUosR0FBZXR6QixPQUFPeXpCLEVBQVAsQ0FBVTdXLEdBQVYsR0FBZ0IsQ0FBaEIsR0FBb0IsT0FBTytaLElBQUlyRCxRQUFYLEtBQXdCLFFBQXhCLEdBQW1DcUQsSUFBSXJELFFBQXZDLEdBQ2xDcUQsSUFBSXJELFFBQUosSUFBZ0J0ekIsT0FBT3l6QixFQUFQLENBQVVtRCxNQUExQixHQUFtQzUyQixPQUFPeXpCLEVBQVAsQ0FBVW1ELE1BQVYsQ0FBa0JELElBQUlyRCxRQUF0QixDQUFuQyxHQUFzRXR6QixPQUFPeXpCLEVBQVAsQ0FBVW1ELE1BQVYsQ0FBaUIxUyxRQUR4Rjs7QUFHQTtBQUNBLE1BQUt5UyxJQUFJM1gsS0FBSixJQUFhLElBQWIsSUFBcUIyWCxJQUFJM1gsS0FBSixLQUFjLElBQXhDLEVBQStDO0FBQzlDMlgsT0FBSTNYLEtBQUosR0FBWSxJQUFaO0FBQ0E7O0FBRUQ7QUFDQTJYLE1BQUl4c0IsR0FBSixHQUFVd3NCLElBQUlKLFFBQWQ7O0FBRUFJLE1BQUlKLFFBQUosR0FBZSxZQUFXO0FBQ3pCLE9BQUt2MkIsT0FBT2tELFVBQVAsQ0FBbUJ5ekIsSUFBSXhzQixHQUF2QixDQUFMLEVBQW9DO0FBQ25Dd3NCLFFBQUl4c0IsR0FBSixDQUFRbEosSUFBUixDQUFjLElBQWQ7QUFDQTs7QUFFRCxPQUFLMDFCLElBQUkzWCxLQUFULEVBQWlCO0FBQ2hCaGYsV0FBT2lmLE9BQVAsQ0FBZ0IsSUFBaEIsRUFBc0IwWCxJQUFJM1gsS0FBMUI7QUFDQTtBQUNELEdBUkQ7O0FBVUEsU0FBTzJYLEdBQVA7QUFDQSxFQTlCRDs7QUFnQ0EzMkIsUUFBT0csRUFBUCxDQUFVc0MsTUFBVixDQUFpQjtBQUNoQm8wQixVQUFRLGdCQUFVSCxLQUFWLEVBQWlCSSxFQUFqQixFQUFxQjlELE1BQXJCLEVBQTZCdHhCLFFBQTdCLEVBQXdDOztBQUUvQztBQUNBLFVBQU8sS0FBS3dNLE1BQUwsQ0FBYTJSLFFBQWIsRUFBd0JFLEdBQXhCLENBQTZCLFNBQTdCLEVBQXdDLENBQXhDLEVBQTRDd1IsSUFBNUM7O0FBRU47QUFGTSxJQUdManZCLEdBSEssR0FHQ3kwQixPQUhELENBR1MsRUFBRXBKLFNBQVNtSixFQUFYLEVBSFQsRUFHMEJKLEtBSDFCLEVBR2lDMUQsTUFIakMsRUFHeUN0eEIsUUFIekMsQ0FBUDtBQUlBLEdBUmU7QUFTaEJxMUIsV0FBUyxpQkFBVWxTLElBQVYsRUFBZ0I2UixLQUFoQixFQUF1QjFELE1BQXZCLEVBQStCdHhCLFFBQS9CLEVBQTBDO0FBQ2xELE9BQUl3WSxRQUFRbGEsT0FBT29FLGFBQVAsQ0FBc0J5Z0IsSUFBdEIsQ0FBWjtBQUFBLE9BQ0NtUyxTQUFTaDNCLE9BQU8wMkIsS0FBUCxDQUFjQSxLQUFkLEVBQXFCMUQsTUFBckIsRUFBNkJ0eEIsUUFBN0IsQ0FEVjtBQUFBLE9BRUN1MUIsY0FBYyxTQUFkQSxXQUFjLEdBQVc7QUFDeEI7QUFDQSxRQUFJOUIsT0FBT1EsVUFBVyxJQUFYLEVBQWlCMzFCLE9BQU95QyxNQUFQLENBQWUsRUFBZixFQUFtQm9pQixJQUFuQixDQUFqQixFQUE0Q21TLE1BQTVDLENBQVg7O0FBRUE7QUFDQSxRQUFLOWMsU0FBU2xhLE9BQU84ZSxLQUFQLENBQWMsSUFBZCxFQUFvQixRQUFwQixDQUFkLEVBQStDO0FBQzlDcVcsVUFBSzlWLElBQUwsQ0FBVyxJQUFYO0FBQ0E7QUFDRCxJQVZGO0FBV0M0WCxlQUFZQyxNQUFaLEdBQXFCRCxXQUFyQjs7QUFFRCxVQUFPL2MsU0FBUzhjLE9BQU9oWSxLQUFQLEtBQWlCLEtBQTFCLEdBQ04sS0FBS3ZkLElBQUwsQ0FBV3cxQixXQUFYLENBRE0sR0FFTixLQUFLalksS0FBTCxDQUFZZ1ksT0FBT2hZLEtBQW5CLEVBQTBCaVksV0FBMUIsQ0FGRDtBQUdBLEdBMUJlO0FBMkJoQjVYLFFBQU0sY0FBVXRiLElBQVYsRUFBZ0J3YixVQUFoQixFQUE0QjZXLE9BQTVCLEVBQXNDO0FBQzNDLE9BQUllLFlBQVksU0FBWkEsU0FBWSxDQUFVaFksS0FBVixFQUFrQjtBQUNqQyxRQUFJRSxPQUFPRixNQUFNRSxJQUFqQjtBQUNBLFdBQU9GLE1BQU1FLElBQWI7QUFDQUEsU0FBTStXLE9BQU47QUFDQSxJQUpEOztBQU1BLE9BQUssT0FBT3J5QixJQUFQLEtBQWdCLFFBQXJCLEVBQWdDO0FBQy9CcXlCLGNBQVU3VyxVQUFWO0FBQ0FBLGlCQUFheGIsSUFBYjtBQUNBQSxXQUFPVixTQUFQO0FBQ0E7QUFDRCxPQUFLa2MsY0FBY3hiLFNBQVMsS0FBNUIsRUFBb0M7QUFDbkMsU0FBS2liLEtBQUwsQ0FBWWpiLFFBQVEsSUFBcEIsRUFBMEIsRUFBMUI7QUFDQTs7QUFFRCxVQUFPLEtBQUt0QyxJQUFMLENBQVUsWUFBVztBQUMzQixRQUFJd2QsVUFBVSxJQUFkO0FBQUEsUUFDQy9HLFFBQVFuVSxRQUFRLElBQVIsSUFBZ0JBLE9BQU8sWUFEaEM7QUFBQSxRQUVDcXpCLFNBQVNwM0IsT0FBT28zQixNQUZqQjtBQUFBLFFBR0MxeUIsT0FBTzFFLE9BQU84ZSxLQUFQLENBQWMsSUFBZCxDQUhSOztBQUtBLFFBQUs1RyxLQUFMLEVBQWE7QUFDWixTQUFLeFQsS0FBTXdULEtBQU4sS0FBaUJ4VCxLQUFNd1QsS0FBTixFQUFjbUgsSUFBcEMsRUFBMkM7QUFDMUM4WCxnQkFBV3p5QixLQUFNd1QsS0FBTixDQUFYO0FBQ0E7QUFDRCxLQUpELE1BSU87QUFDTixVQUFNQSxLQUFOLElBQWV4VCxJQUFmLEVBQXNCO0FBQ3JCLFVBQUtBLEtBQU13VCxLQUFOLEtBQWlCeFQsS0FBTXdULEtBQU4sRUFBY21ILElBQS9CLElBQXVDOFUsS0FBS3BwQixJQUFMLENBQVdtTixLQUFYLENBQTVDLEVBQWlFO0FBQ2hFaWYsaUJBQVd6eUIsS0FBTXdULEtBQU4sQ0FBWDtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxTQUFNQSxRQUFRa2YsT0FBT3IyQixNQUFyQixFQUE2Qm1YLE9BQTdCLEdBQXdDO0FBQ3ZDLFNBQUtrZixPQUFRbGYsS0FBUixFQUFnQnJXLElBQWhCLEtBQXlCLElBQXpCLEtBQWtDa0MsUUFBUSxJQUFSLElBQWdCcXpCLE9BQVFsZixLQUFSLEVBQWdCOEcsS0FBaEIsS0FBMEJqYixJQUE1RSxDQUFMLEVBQXlGO0FBQ3hGcXpCLGFBQVFsZixLQUFSLEVBQWdCaWQsSUFBaEIsQ0FBcUI5VixJQUFyQixDQUEyQitXLE9BQTNCO0FBQ0FuWCxnQkFBVSxLQUFWO0FBQ0FtWSxhQUFPNTBCLE1BQVAsQ0FBZTBWLEtBQWYsRUFBc0IsQ0FBdEI7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFFBQUsrRyxXQUFXLENBQUNtWCxPQUFqQixFQUEyQjtBQUMxQnAyQixZQUFPaWYsT0FBUCxDQUFnQixJQUFoQixFQUFzQmxiLElBQXRCO0FBQ0E7QUFDRCxJQWhDTSxDQUFQO0FBaUNBLEdBNUVlO0FBNkVoQm16QixVQUFRLGdCQUFVbnpCLElBQVYsRUFBaUI7QUFDeEIsT0FBS0EsU0FBUyxLQUFkLEVBQXNCO0FBQ3JCQSxXQUFPQSxRQUFRLElBQWY7QUFDQTtBQUNELFVBQU8sS0FBS3RDLElBQUwsQ0FBVSxZQUFXO0FBQzNCLFFBQUl5VyxLQUFKO0FBQUEsUUFDQ3hULE9BQU8xRSxPQUFPOGUsS0FBUCxDQUFjLElBQWQsQ0FEUjtBQUFBLFFBRUNFLFFBQVF0YSxLQUFNWCxPQUFPLE9BQWIsQ0FGVDtBQUFBLFFBR0NvYixRQUFRemEsS0FBTVgsT0FBTyxZQUFiLENBSFQ7QUFBQSxRQUlDcXpCLFNBQVNwM0IsT0FBT28zQixNQUpqQjtBQUFBLFFBS0NyMkIsU0FBU2llLFFBQVFBLE1BQU1qZSxNQUFkLEdBQXVCLENBTGpDOztBQU9BO0FBQ0EyRCxTQUFLd3lCLE1BQUwsR0FBYyxJQUFkOztBQUVBO0FBQ0FsM0IsV0FBT2dmLEtBQVAsQ0FBYyxJQUFkLEVBQW9CamIsSUFBcEIsRUFBMEIsRUFBMUI7O0FBRUEsUUFBS29iLFNBQVNBLE1BQU1FLElBQXBCLEVBQTJCO0FBQzFCRixXQUFNRSxJQUFOLENBQVdwZSxJQUFYLENBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ0E7O0FBRUQ7QUFDQSxTQUFNaVgsUUFBUWtmLE9BQU9yMkIsTUFBckIsRUFBNkJtWCxPQUE3QixHQUF3QztBQUN2QyxTQUFLa2YsT0FBUWxmLEtBQVIsRUFBZ0JyVyxJQUFoQixLQUF5QixJQUF6QixJQUFpQ3UxQixPQUFRbGYsS0FBUixFQUFnQjhHLEtBQWhCLEtBQTBCamIsSUFBaEUsRUFBdUU7QUFDdEVxekIsYUFBUWxmLEtBQVIsRUFBZ0JpZCxJQUFoQixDQUFxQjlWLElBQXJCLENBQTJCLElBQTNCO0FBQ0ErWCxhQUFPNTBCLE1BQVAsQ0FBZTBWLEtBQWYsRUFBc0IsQ0FBdEI7QUFDQTtBQUNEOztBQUVEO0FBQ0EsU0FBTUEsUUFBUSxDQUFkLEVBQWlCQSxRQUFRblgsTUFBekIsRUFBaUNtWCxPQUFqQyxFQUEyQztBQUMxQyxTQUFLOEcsTUFBTzlHLEtBQVAsS0FBa0I4RyxNQUFPOUcsS0FBUCxFQUFlZ2YsTUFBdEMsRUFBK0M7QUFDOUNsWSxZQUFPOUcsS0FBUCxFQUFlZ2YsTUFBZixDQUFzQmoyQixJQUF0QixDQUE0QixJQUE1QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFPeUQsS0FBS3d5QixNQUFaO0FBQ0EsSUFuQ00sQ0FBUDtBQW9DQTtBQXJIZSxFQUFqQjs7QUF3SEFsM0IsUUFBT3lCLElBQVAsQ0FBWSxDQUFFLFFBQUYsRUFBWSxNQUFaLEVBQW9CLE1BQXBCLENBQVosRUFBMEMsVUFBVUssQ0FBVixFQUFhZSxJQUFiLEVBQW9CO0FBQzdELE1BQUl3MEIsUUFBUXIzQixPQUFPRyxFQUFQLENBQVcwQyxJQUFYLENBQVo7QUFDQTdDLFNBQU9HLEVBQVAsQ0FBVzBDLElBQVgsSUFBb0IsVUFBVTZ6QixLQUFWLEVBQWlCMUQsTUFBakIsRUFBeUJ0eEIsUUFBekIsRUFBb0M7QUFDdkQsVUFBT2cxQixTQUFTLElBQVQsSUFBaUIsT0FBT0EsS0FBUCxLQUFpQixTQUFsQyxHQUNOVyxNQUFNdDFCLEtBQU4sQ0FBYSxJQUFiLEVBQW1CQyxTQUFuQixDQURNLEdBRU4sS0FBSyswQixPQUFMLENBQWNwQyxNQUFPOXhCLElBQVAsRUFBYSxJQUFiLENBQWQsRUFBbUM2ekIsS0FBbkMsRUFBMEMxRCxNQUExQyxFQUFrRHR4QixRQUFsRCxDQUZEO0FBR0EsR0FKRDtBQUtBLEVBUEQ7O0FBU0E7QUFDQTFCLFFBQU95QixJQUFQLENBQVk7QUFDWDYxQixhQUFXM0MsTUFBTSxNQUFOLENBREE7QUFFWDRDLFdBQVM1QyxNQUFNLE1BQU4sQ0FGRTtBQUdYNkMsZUFBYTdDLE1BQU0sUUFBTixDQUhGO0FBSVg4QyxVQUFRLEVBQUU5SixTQUFTLE1BQVgsRUFKRztBQUtYK0osV0FBUyxFQUFFL0osU0FBUyxNQUFYLEVBTEU7QUFNWGdLLGNBQVksRUFBRWhLLFNBQVMsUUFBWDtBQU5ELEVBQVosRUFPRyxVQUFVOXFCLElBQVYsRUFBZ0JzaUIsS0FBaEIsRUFBd0I7QUFDMUJubEIsU0FBT0csRUFBUCxDQUFXMEMsSUFBWCxJQUFvQixVQUFVNnpCLEtBQVYsRUFBaUIxRCxNQUFqQixFQUF5QnR4QixRQUF6QixFQUFvQztBQUN2RCxVQUFPLEtBQUtxMUIsT0FBTCxDQUFjNVIsS0FBZCxFQUFxQnVSLEtBQXJCLEVBQTRCMUQsTUFBNUIsRUFBb0N0eEIsUUFBcEMsQ0FBUDtBQUNBLEdBRkQ7QUFHQSxFQVhEOztBQWFBMUIsUUFBT28zQixNQUFQLEdBQWdCLEVBQWhCO0FBQ0FwM0IsUUFBT3l6QixFQUFQLENBQVVxQyxJQUFWLEdBQWlCLFlBQVc7QUFDM0IsTUFBSVEsS0FBSjtBQUFBLE1BQ0NjLFNBQVNwM0IsT0FBT28zQixNQURqQjtBQUFBLE1BRUN0MUIsSUFBSSxDQUZMOztBQUlBaXlCLFVBQVEvekIsT0FBT21HLEdBQVAsRUFBUjs7QUFFQSxTQUFRckUsSUFBSXMxQixPQUFPcjJCLE1BQW5CLEVBQTJCZSxHQUEzQixFQUFpQztBQUNoQ3cwQixXQUFRYyxPQUFRdDFCLENBQVIsQ0FBUjtBQUNBO0FBQ0EsT0FBSyxDQUFDdzBCLE9BQUQsSUFBWWMsT0FBUXQxQixDQUFSLE1BQWdCdzBCLEtBQWpDLEVBQXlDO0FBQ3hDYyxXQUFPNTBCLE1BQVAsQ0FBZVYsR0FBZixFQUFvQixDQUFwQjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSyxDQUFDczFCLE9BQU9yMkIsTUFBYixFQUFzQjtBQUNyQmYsVUFBT3l6QixFQUFQLENBQVVwVSxJQUFWO0FBQ0E7QUFDRDBVLFVBQVExd0IsU0FBUjtBQUNBLEVBbkJEOztBQXFCQXJELFFBQU95ekIsRUFBUCxDQUFVNkMsS0FBVixHQUFrQixVQUFVQSxLQUFWLEVBQWtCO0FBQ25DdDJCLFNBQU9vM0IsTUFBUCxDQUFjNzNCLElBQWQsQ0FBb0IrMkIsS0FBcEI7QUFDQSxNQUFLQSxPQUFMLEVBQWU7QUFDZHQyQixVQUFPeXpCLEVBQVAsQ0FBVXJpQixLQUFWO0FBQ0EsR0FGRCxNQUVPO0FBQ05wUixVQUFPbzNCLE1BQVAsQ0FBY3B2QixHQUFkO0FBQ0E7QUFDRCxFQVBEOztBQVNBaEksUUFBT3l6QixFQUFQLENBQVVtRSxRQUFWLEdBQXFCLEVBQXJCOztBQUVBNTNCLFFBQU95ekIsRUFBUCxDQUFVcmlCLEtBQVYsR0FBa0IsWUFBVztBQUM1QixNQUFLLENBQUM0aUIsT0FBTixFQUFnQjtBQUNmQSxhQUFVNkQsWUFBYTczQixPQUFPeXpCLEVBQVAsQ0FBVXFDLElBQXZCLEVBQTZCOTFCLE9BQU95ekIsRUFBUCxDQUFVbUUsUUFBdkMsQ0FBVjtBQUNBO0FBQ0QsRUFKRDs7QUFNQTUzQixRQUFPeXpCLEVBQVAsQ0FBVXBVLElBQVYsR0FBaUIsWUFBVztBQUMzQnlZLGdCQUFlOUQsT0FBZjtBQUNBQSxZQUFVLElBQVY7QUFDQSxFQUhEOztBQUtBaDBCLFFBQU95ekIsRUFBUCxDQUFVbUQsTUFBVixHQUFtQjtBQUNsQm1CLFFBQU0sR0FEWTtBQUVsQkMsUUFBTSxHQUZZO0FBR2xCO0FBQ0E5VCxZQUFVO0FBSlEsRUFBbkI7O0FBUUE7QUFDQTtBQUNBbGtCLFFBQU9HLEVBQVAsQ0FBVTgzQixLQUFWLEdBQWtCLFVBQVVDLElBQVYsRUFBZ0JuMEIsSUFBaEIsRUFBdUI7QUFDeENtMEIsU0FBT2w0QixPQUFPeXpCLEVBQVAsR0FBWXp6QixPQUFPeXpCLEVBQVAsQ0FBVW1ELE1BQVYsQ0FBa0JzQixJQUFsQixLQUE0QkEsSUFBeEMsR0FBK0NBLElBQXREO0FBQ0FuMEIsU0FBT0EsUUFBUSxJQUFmOztBQUVBLFNBQU8sS0FBS2liLEtBQUwsQ0FBWWpiLElBQVosRUFBa0IsVUFBVXdULElBQVYsRUFBZ0I0SCxLQUFoQixFQUF3QjtBQUNoRCxPQUFJZ1osVUFBVXpiLFdBQVluRixJQUFaLEVBQWtCMmdCLElBQWxCLENBQWQ7QUFDQS9ZLFNBQU1FLElBQU4sR0FBYSxZQUFXO0FBQ3ZCK1ksaUJBQWNELE9BQWQ7QUFDQSxJQUZEO0FBR0EsR0FMTSxDQUFQO0FBTUEsRUFWRDs7QUFhQSxFQUFDLFlBQVc7QUFDWCxNQUFJdndCLENBQUo7QUFBQSxNQUFPMEcsS0FBUDtBQUFBLE1BQWM3QyxNQUFkO0FBQUEsTUFBc0JrckIsR0FBdEI7QUFBQSxNQUNDM3FCLE1BQU1qTixTQUFTa04sYUFBVCxDQUF1QixLQUF2QixDQURQOztBQUdBO0FBQ0FELE1BQUlkLFlBQUosQ0FBa0IsV0FBbEIsRUFBK0IsR0FBL0I7QUFDQWMsTUFBSTZCLFNBQUosR0FBZ0Isb0VBQWhCO0FBQ0FqRyxNQUFJb0UsSUFBSXBCLG9CQUFKLENBQXlCLEdBQXpCLEVBQStCLENBQS9CLENBQUo7O0FBRUE7QUFDQWEsV0FBUzFNLFNBQVNrTixhQUFULENBQXVCLFFBQXZCLENBQVQ7QUFDQTBxQixRQUFNbHJCLE9BQU9rQyxXQUFQLENBQW9CNU8sU0FBU2tOLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBcEIsQ0FBTjtBQUNBcUMsVUFBUXRDLElBQUlwQixvQkFBSixDQUF5QixPQUF6QixFQUFtQyxDQUFuQyxDQUFSOztBQUVBaEQsSUFBRTRWLEtBQUYsQ0FBUUMsT0FBUixHQUFrQixTQUFsQjs7QUFFQTtBQUNBM2QsVUFBUXU0QixlQUFSLEdBQTBCcnNCLElBQUkwQixTQUFKLEtBQWtCLEdBQTVDOztBQUVBO0FBQ0E7QUFDQTVOLFVBQVEwZCxLQUFSLEdBQWdCLE1BQU16UyxJQUFOLENBQVluRCxFQUFFcUQsWUFBRixDQUFlLE9BQWYsQ0FBWixDQUFoQjs7QUFFQTtBQUNBO0FBQ0FuTCxVQUFRdzRCLGNBQVIsR0FBeUIxd0IsRUFBRXFELFlBQUYsQ0FBZSxNQUFmLE1BQTJCLElBQXBEOztBQUVBO0FBQ0FuTCxVQUFReTRCLE9BQVIsR0FBa0IsQ0FBQyxDQUFDanFCLE1BQU10SixLQUExQjs7QUFFQTtBQUNBO0FBQ0FsRixVQUFRMDRCLFdBQVIsR0FBc0I3QixJQUFJbmtCLFFBQTFCOztBQUVBO0FBQ0ExUyxVQUFRMjRCLE9BQVIsR0FBa0IsQ0FBQyxDQUFDMTVCLFNBQVNrTixhQUFULENBQXVCLE1BQXZCLEVBQStCd3NCLE9BQW5EOztBQUVBO0FBQ0E7QUFDQWh0QixTQUFPNkcsUUFBUCxHQUFrQixJQUFsQjtBQUNBeFMsVUFBUTQ0QixXQUFSLEdBQXNCLENBQUMvQixJQUFJcmtCLFFBQTNCOztBQUVBO0FBQ0E7QUFDQWhFLFVBQVF2UCxTQUFTa04sYUFBVCxDQUF3QixPQUF4QixDQUFSO0FBQ0FxQyxRQUFNcEQsWUFBTixDQUFvQixPQUFwQixFQUE2QixFQUE3QjtBQUNBcEwsVUFBUXdPLEtBQVIsR0FBZ0JBLE1BQU1yRCxZQUFOLENBQW9CLE9BQXBCLE1BQWtDLEVBQWxEOztBQUVBO0FBQ0FxRCxRQUFNdEosS0FBTixHQUFjLEdBQWQ7QUFDQXNKLFFBQU1wRCxZQUFOLENBQW9CLE1BQXBCLEVBQTRCLE9BQTVCO0FBQ0FwTCxVQUFRNjRCLFVBQVIsR0FBcUJycUIsTUFBTXRKLEtBQU4sS0FBZ0IsR0FBckM7O0FBRUE7QUFDQTRDLE1BQUkwRyxRQUFRN0MsU0FBU2tyQixNQUFNM3FCLE1BQU0sSUFBakM7QUFDQSxFQXZERDs7QUEwREEsS0FBSTRzQixVQUFVLEtBQWQ7O0FBRUE1NEIsUUFBT0csRUFBUCxDQUFVc0MsTUFBVixDQUFpQjtBQUNoQmdOLE9BQUssYUFBVXpLLEtBQVYsRUFBa0I7QUFDdEIsT0FBSW1hLEtBQUo7QUFBQSxPQUFXN2QsR0FBWDtBQUFBLE9BQWdCNEIsVUFBaEI7QUFBQSxPQUNDckIsT0FBTyxLQUFLLENBQUwsQ0FEUjs7QUFHQSxPQUFLLENBQUNHLFVBQVVqQixNQUFoQixFQUF5QjtBQUN4QixRQUFLYyxJQUFMLEVBQVk7QUFDWHNkLGFBQVFuZixPQUFPNjRCLFFBQVAsQ0FBaUJoM0IsS0FBS2tDLElBQXRCLEtBQWdDL0QsT0FBTzY0QixRQUFQLENBQWlCaDNCLEtBQUtpRCxRQUFMLENBQWNDLFdBQWQsRUFBakIsQ0FBeEM7O0FBRUEsU0FBS29hLFNBQVMsU0FBU0EsS0FBbEIsSUFBMkIsQ0FBQzdkLE1BQU02ZCxNQUFNamUsR0FBTixDQUFXVyxJQUFYLEVBQWlCLE9BQWpCLENBQVAsTUFBdUN3QixTQUF2RSxFQUFtRjtBQUNsRixhQUFPL0IsR0FBUDtBQUNBOztBQUVEQSxXQUFNTyxLQUFLbUQsS0FBWDs7QUFFQSxZQUFPLE9BQU8xRCxHQUFQLEtBQWUsUUFBZjtBQUNOO0FBQ0FBLFNBQUltQyxPQUFKLENBQVltMUIsT0FBWixFQUFxQixFQUFyQixDQUZNO0FBR047QUFDQXQzQixZQUFPLElBQVAsR0FBYyxFQUFkLEdBQW1CQSxHQUpwQjtBQUtBOztBQUVEO0FBQ0E7O0FBRUQ0QixnQkFBYWxELE9BQU9rRCxVQUFQLENBQW1COEIsS0FBbkIsQ0FBYjs7QUFFQSxVQUFPLEtBQUt2RCxJQUFMLENBQVUsVUFBVUssQ0FBVixFQUFjO0FBQzlCLFFBQUkyTixHQUFKOztBQUVBLFFBQUssS0FBS25MLFFBQUwsS0FBa0IsQ0FBdkIsRUFBMkI7QUFDMUI7QUFDQTs7QUFFRCxRQUFLcEIsVUFBTCxFQUFrQjtBQUNqQnVNLFdBQU16SyxNQUFNL0QsSUFBTixDQUFZLElBQVosRUFBa0JhLENBQWxCLEVBQXFCOUIsT0FBUSxJQUFSLEVBQWV5UCxHQUFmLEVBQXJCLENBQU47QUFDQSxLQUZELE1BRU87QUFDTkEsV0FBTXpLLEtBQU47QUFDQTs7QUFFRDtBQUNBLFFBQUt5SyxPQUFPLElBQVosRUFBbUI7QUFDbEJBLFdBQU0sRUFBTjtBQUNBLEtBRkQsTUFFTyxJQUFLLE9BQU9BLEdBQVAsS0FBZSxRQUFwQixFQUErQjtBQUNyQ0EsWUFBTyxFQUFQO0FBQ0EsS0FGTSxNQUVBLElBQUt6UCxPQUFPb0QsT0FBUCxDQUFnQnFNLEdBQWhCLENBQUwsRUFBNkI7QUFDbkNBLFdBQU16UCxPQUFPNEIsR0FBUCxDQUFZNk4sR0FBWixFQUFpQixVQUFVekssS0FBVixFQUFrQjtBQUN4QyxhQUFPQSxTQUFTLElBQVQsR0FBZ0IsRUFBaEIsR0FBcUJBLFFBQVEsRUFBcEM7QUFDQSxNQUZLLENBQU47QUFHQTs7QUFFRG1hLFlBQVFuZixPQUFPNjRCLFFBQVAsQ0FBaUIsS0FBSzkwQixJQUF0QixLQUFnQy9ELE9BQU82NEIsUUFBUCxDQUFpQixLQUFLL3pCLFFBQUwsQ0FBY0MsV0FBZCxFQUFqQixDQUF4Qzs7QUFFQTtBQUNBLFFBQUssQ0FBQ29hLEtBQUQsSUFBVSxFQUFFLFNBQVNBLEtBQVgsQ0FBVixJQUErQkEsTUFBTXNOLEdBQU4sQ0FBVyxJQUFYLEVBQWlCaGQsR0FBakIsRUFBc0IsT0FBdEIsTUFBb0NwTSxTQUF4RSxFQUFvRjtBQUNuRixVQUFLMkIsS0FBTCxHQUFheUssR0FBYjtBQUNBO0FBQ0QsSUE5Qk0sQ0FBUDtBQStCQTtBQTFEZSxFQUFqQjs7QUE2REF6UCxRQUFPeUMsTUFBUCxDQUFjO0FBQ2JvMkIsWUFBVTtBQUNUMVAsV0FBUTtBQUNQam9CLFNBQUssYUFBVVcsSUFBVixFQUFpQjtBQUNyQixTQUFJNE4sTUFBTXpQLE9BQU9pTyxJQUFQLENBQVl1QixJQUFaLENBQWtCM04sSUFBbEIsRUFBd0IsT0FBeEIsQ0FBVjtBQUNBLFlBQU80TixPQUFPLElBQVAsR0FDTkEsR0FETSxHQUVOelAsT0FBT2tGLElBQVAsQ0FBYXJELElBQWIsQ0FGRDtBQUdBO0FBTk0sSUFEQztBQVNUNEosV0FBUTtBQUNQdkssU0FBSyxhQUFVVyxJQUFWLEVBQWlCO0FBQ3JCLFNBQUltRCxLQUFKO0FBQUEsU0FBV21rQixNQUFYO0FBQUEsU0FDQ3JtQixVQUFVakIsS0FBS2lCLE9BRGhCO0FBQUEsU0FFQ29WLFFBQVFyVyxLQUFLNFEsYUFGZDtBQUFBLFNBR0N1VixNQUFNbm1CLEtBQUtrQyxJQUFMLEtBQWMsWUFBZCxJQUE4Qm1VLFFBQVEsQ0FIN0M7QUFBQSxTQUlDNEQsU0FBU2tNLE1BQU0sSUFBTixHQUFhLEVBSnZCO0FBQUEsU0FLQ3hpQixNQUFNd2lCLE1BQU05UCxRQUFRLENBQWQsR0FBa0JwVixRQUFRL0IsTUFMakM7QUFBQSxTQU1DZSxJQUFJb1csUUFBUSxDQUFSLEdBQ0gxUyxHQURHLEdBRUh3aUIsTUFBTTlQLEtBQU4sR0FBYyxDQVJoQjs7QUFVQTtBQUNBLFlBQVFwVyxJQUFJMEQsR0FBWixFQUFpQjFELEdBQWpCLEVBQXVCO0FBQ3RCcW5CLGVBQVNybUIsUUFBU2hCLENBQVQsQ0FBVDs7QUFFQTtBQUNBLFVBQUssQ0FBRXFuQixPQUFPM1csUUFBUCxJQUFtQjFRLE1BQU1vVyxLQUEzQjtBQUNIO0FBQ0VwWSxjQUFRNDRCLFdBQVIsR0FBc0IsQ0FBQ3ZQLE9BQU83VyxRQUE5QixHQUF5QzZXLE9BQU9sZSxZQUFQLENBQW9CLFVBQXBCLE1BQW9DLElBRjVFLE1BR0QsQ0FBQ2tlLE9BQU96ZSxVQUFQLENBQWtCNEgsUUFBbkIsSUFBK0IsQ0FBQ3RTLE9BQU84RSxRQUFQLENBQWlCcWtCLE9BQU96ZSxVQUF4QixFQUFvQyxVQUFwQyxDQUgvQixDQUFMLEVBR3lGOztBQUV4RjtBQUNBMUYsZUFBUWhGLE9BQVFtcEIsTUFBUixFQUFpQjFaLEdBQWpCLEVBQVI7O0FBRUE7QUFDQSxXQUFLdVksR0FBTCxFQUFXO0FBQ1YsZUFBT2hqQixLQUFQO0FBQ0E7O0FBRUQ7QUFDQThXLGNBQU92YyxJQUFQLENBQWF5RixLQUFiO0FBQ0E7QUFDRDs7QUFFRCxZQUFPOFcsTUFBUDtBQUNBLEtBcENNOztBQXNDUDJRLFNBQUssYUFBVTVxQixJQUFWLEVBQWdCbUQsS0FBaEIsRUFBd0I7QUFDNUIsU0FBSTh6QixTQUFKO0FBQUEsU0FBZTNQLE1BQWY7QUFBQSxTQUNDcm1CLFVBQVVqQixLQUFLaUIsT0FEaEI7QUFBQSxTQUVDZ1osU0FBUzliLE9BQU9tRixTQUFQLENBQWtCSCxLQUFsQixDQUZWO0FBQUEsU0FHQ2xELElBQUlnQixRQUFRL0IsTUFIYjs7QUFLQSxZQUFRZSxHQUFSLEVBQWM7QUFDYnFuQixlQUFTcm1CLFFBQVNoQixDQUFULENBQVQ7O0FBRUEsVUFBSzlCLE9BQU91RixPQUFQLENBQWdCdkYsT0FBTzY0QixRQUFQLENBQWdCMVAsTUFBaEIsQ0FBdUJqb0IsR0FBdkIsQ0FBNEJpb0IsTUFBNUIsQ0FBaEIsRUFBc0RyTixNQUF0RCxLQUFrRSxDQUF2RSxFQUEyRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFJO0FBQ0hxTixlQUFPM1csUUFBUCxHQUFrQnNtQixZQUFZLElBQTlCO0FBRUEsUUFIRCxDQUdFLE9BQVF2dkIsQ0FBUixFQUFZOztBQUViO0FBQ0E0ZixlQUFPNFAsWUFBUDtBQUNBO0FBRUQsT0FmRCxNQWVPO0FBQ041UCxjQUFPM1csUUFBUCxHQUFrQixLQUFsQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFLLENBQUNzbUIsU0FBTixFQUFrQjtBQUNqQmozQixXQUFLNFEsYUFBTCxHQUFxQixDQUFDLENBQXRCO0FBQ0E7O0FBRUQsWUFBTzNQLE9BQVA7QUFDQTtBQXpFTTtBQVRDO0FBREcsRUFBZDs7QUF3RkE7QUFDQTlDLFFBQU95QixJQUFQLENBQVksQ0FBRSxPQUFGLEVBQVcsVUFBWCxDQUFaLEVBQXFDLFlBQVc7QUFDL0N6QixTQUFPNjRCLFFBQVAsQ0FBaUIsSUFBakIsSUFBMEI7QUFDekJwTSxRQUFLLGFBQVU1cUIsSUFBVixFQUFnQm1ELEtBQWhCLEVBQXdCO0FBQzVCLFFBQUtoRixPQUFPb0QsT0FBUCxDQUFnQjRCLEtBQWhCLENBQUwsRUFBK0I7QUFDOUIsWUFBU25ELEtBQUswUSxPQUFMLEdBQWV2UyxPQUFPdUYsT0FBUCxDQUFnQnZGLE9BQU82QixJQUFQLEVBQWE0TixHQUFiLEVBQWhCLEVBQW9DekssS0FBcEMsS0FBK0MsQ0FBdkU7QUFDQTtBQUNEO0FBTHdCLEdBQTFCO0FBT0EsTUFBSyxDQUFDbEYsUUFBUXk0QixPQUFkLEVBQXdCO0FBQ3ZCdjRCLFVBQU82NEIsUUFBUCxDQUFpQixJQUFqQixFQUF3QjMzQixHQUF4QixHQUE4QixVQUFVVyxJQUFWLEVBQWlCO0FBQzlDO0FBQ0E7QUFDQSxXQUFPQSxLQUFLb0osWUFBTCxDQUFrQixPQUFsQixNQUErQixJQUEvQixHQUFzQyxJQUF0QyxHQUE2Q3BKLEtBQUttRCxLQUF6RDtBQUNBLElBSkQ7QUFLQTtBQUNELEVBZkQ7O0FBb0JBLEtBQUlnMEIsUUFBSjtBQUFBLEtBQWNDLFFBQWQ7QUFBQSxLQUNDM3NCLGFBQWF0TSxPQUFPc1AsSUFBUCxDQUFZaEQsVUFEMUI7QUFBQSxLQUVDNHNCLGNBQWMseUJBRmY7QUFBQSxLQUdDYixrQkFBa0J2NEIsUUFBUXU0QixlQUgzQjtBQUFBLEtBSUNjLGNBQWNyNUIsUUFBUXdPLEtBSnZCOztBQU1BdE8sUUFBT0csRUFBUCxDQUFVc0MsTUFBVixDQUFpQjtBQUNoQitNLFFBQU0sY0FBVTNNLElBQVYsRUFBZ0JtQyxLQUFoQixFQUF3QjtBQUM3QixVQUFPZ2IsT0FBUSxJQUFSLEVBQWNoZ0IsT0FBT3dQLElBQXJCLEVBQTJCM00sSUFBM0IsRUFBaUNtQyxLQUFqQyxFQUF3Q2hELFVBQVVqQixNQUFWLEdBQW1CLENBQTNELENBQVA7QUFDQSxHQUhlOztBQUtoQnE0QixjQUFZLG9CQUFVdjJCLElBQVYsRUFBaUI7QUFDNUIsVUFBTyxLQUFLcEIsSUFBTCxDQUFVLFlBQVc7QUFDM0J6QixXQUFPbzVCLFVBQVAsQ0FBbUIsSUFBbkIsRUFBeUJ2MkIsSUFBekI7QUFDQSxJQUZNLENBQVA7QUFHQTtBQVRlLEVBQWpCOztBQVlBN0MsUUFBT3lDLE1BQVAsQ0FBYztBQUNiK00sUUFBTSxjQUFVM04sSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCbUMsS0FBdEIsRUFBOEI7QUFDbkMsT0FBSW1hLEtBQUo7QUFBQSxPQUFXN2QsR0FBWDtBQUFBLE9BQ0MrM0IsUUFBUXgzQixLQUFLeUMsUUFEZDs7QUFHQTtBQUNBLE9BQUssQ0FBQ3pDLElBQUQsSUFBU3czQixVQUFVLENBQW5CLElBQXdCQSxVQUFVLENBQWxDLElBQXVDQSxVQUFVLENBQXRELEVBQTBEO0FBQ3pEO0FBQ0E7O0FBRUQ7QUFDQSxPQUFLLFFBQU94M0IsS0FBS29KLFlBQVosTUFBNkJuRCxZQUFsQyxFQUFpRDtBQUNoRCxXQUFPOUgsT0FBTzZrQixJQUFQLENBQWFoakIsSUFBYixFQUFtQmdCLElBQW5CLEVBQXlCbUMsS0FBekIsQ0FBUDtBQUNBOztBQUVEO0FBQ0E7QUFDQSxPQUFLcTBCLFVBQVUsQ0FBVixJQUFlLENBQUNyNUIsT0FBT3FXLFFBQVAsQ0FBaUJ4VSxJQUFqQixDQUFyQixFQUErQztBQUM5Q2dCLFdBQU9BLEtBQUtrQyxXQUFMLEVBQVA7QUFDQW9hLFlBQVFuZixPQUFPczVCLFNBQVAsQ0FBa0J6MkIsSUFBbEIsTUFDTDdDLE9BQU9zUCxJQUFQLENBQVl0RixLQUFaLENBQWtCdXZCLElBQWxCLENBQXVCeHVCLElBQXZCLENBQTZCbEksSUFBN0IsSUFBc0NvMkIsUUFBdEMsR0FBaURELFFBRDVDLENBQVI7QUFFQTs7QUFFRCxPQUFLaDBCLFVBQVUzQixTQUFmLEVBQTJCOztBQUUxQixRQUFLMkIsVUFBVSxJQUFmLEVBQXNCO0FBQ3JCaEYsWUFBT281QixVQUFQLENBQW1CdjNCLElBQW5CLEVBQXlCZ0IsSUFBekI7QUFFQSxLQUhELE1BR08sSUFBS3NjLFNBQVMsU0FBU0EsS0FBbEIsSUFBMkIsQ0FBQzdkLE1BQU02ZCxNQUFNc04sR0FBTixDQUFXNXFCLElBQVgsRUFBaUJtRCxLQUFqQixFQUF3Qm5DLElBQXhCLENBQVAsTUFBMkNRLFNBQTNFLEVBQXVGO0FBQzdGLFlBQU8vQixHQUFQO0FBRUEsS0FITSxNQUdBO0FBQ05PLFVBQUtxSixZQUFMLENBQW1CckksSUFBbkIsRUFBeUJtQyxRQUFRLEVBQWpDO0FBQ0EsWUFBT0EsS0FBUDtBQUNBO0FBRUQsSUFiRCxNQWFPLElBQUttYSxTQUFTLFNBQVNBLEtBQWxCLElBQTJCLENBQUM3ZCxNQUFNNmQsTUFBTWplLEdBQU4sQ0FBV1csSUFBWCxFQUFpQmdCLElBQWpCLENBQVAsTUFBb0MsSUFBcEUsRUFBMkU7QUFDakYsV0FBT3ZCLEdBQVA7QUFFQSxJQUhNLE1BR0E7QUFDTkEsVUFBTXRCLE9BQU9pTyxJQUFQLENBQVl1QixJQUFaLENBQWtCM04sSUFBbEIsRUFBd0JnQixJQUF4QixDQUFOOztBQUVBO0FBQ0EsV0FBT3ZCLE9BQU8sSUFBUCxHQUNOK0IsU0FETSxHQUVOL0IsR0FGRDtBQUdBO0FBQ0QsR0EvQ1k7O0FBaURiODNCLGNBQVksb0JBQVV2M0IsSUFBVixFQUFnQm1ELEtBQWhCLEVBQXdCO0FBQ25DLE9BQUluQyxJQUFKO0FBQUEsT0FBVTIyQixRQUFWO0FBQUEsT0FDQzEzQixJQUFJLENBREw7QUFBQSxPQUVDMjNCLFlBQVl6MEIsU0FBU0EsTUFBTWdGLEtBQU4sQ0FBYStPLFNBQWIsQ0FGdEI7O0FBSUEsT0FBSzBnQixhQUFhNTNCLEtBQUt5QyxRQUFMLEtBQWtCLENBQXBDLEVBQXdDO0FBQ3ZDLFdBQVN6QixPQUFPNDJCLFVBQVUzM0IsR0FBVixDQUFoQixFQUFrQztBQUNqQzAzQixnQkFBV3g1QixPQUFPMDVCLE9BQVAsQ0FBZ0I3MkIsSUFBaEIsS0FBMEJBLElBQXJDOztBQUVBO0FBQ0EsU0FBSzdDLE9BQU9zUCxJQUFQLENBQVl0RixLQUFaLENBQWtCdXZCLElBQWxCLENBQXVCeHVCLElBQXZCLENBQTZCbEksSUFBN0IsQ0FBTCxFQUEyQztBQUMxQztBQUNBLFVBQUtzMkIsZUFBZWQsZUFBZixJQUFrQyxDQUFDYSxZQUFZbnVCLElBQVosQ0FBa0JsSSxJQUFsQixDQUF4QyxFQUFtRTtBQUNsRWhCLFlBQU0yM0IsUUFBTixJQUFtQixLQUFuQjtBQUNEO0FBQ0E7QUFDQyxPQUpELE1BSU87QUFDTjMzQixZQUFNN0IsT0FBTzRFLFNBQVAsQ0FBa0IsYUFBYS9CLElBQS9CLENBQU4sSUFDQ2hCLEtBQU0yM0IsUUFBTixJQUFtQixLQURwQjtBQUVBOztBQUVGO0FBQ0MsTUFaRCxNQVlPO0FBQ054NUIsYUFBT3dQLElBQVAsQ0FBYTNOLElBQWIsRUFBbUJnQixJQUFuQixFQUF5QixFQUF6QjtBQUNBOztBQUVEaEIsVUFBSzJKLGVBQUwsQ0FBc0I2c0Isa0JBQWtCeDFCLElBQWxCLEdBQXlCMjJCLFFBQS9DO0FBQ0E7QUFDRDtBQUNELEdBOUVZOztBQWdGYkYsYUFBVztBQUNWdjFCLFNBQU07QUFDTDBvQixTQUFLLGFBQVU1cUIsSUFBVixFQUFnQm1ELEtBQWhCLEVBQXdCO0FBQzVCLFNBQUssQ0FBQ2xGLFFBQVE2NEIsVUFBVCxJQUF1QjN6QixVQUFVLE9BQWpDLElBQTRDaEYsT0FBTzhFLFFBQVAsQ0FBZ0JqRCxJQUFoQixFQUFzQixPQUF0QixDQUFqRCxFQUFrRjtBQUNqRjtBQUNBO0FBQ0EsVUFBSTROLE1BQU01TixLQUFLbUQsS0FBZjtBQUNBbkQsV0FBS3FKLFlBQUwsQ0FBbUIsTUFBbkIsRUFBMkJsRyxLQUEzQjtBQUNBLFVBQUt5SyxHQUFMLEVBQVc7QUFDVjVOLFlBQUttRCxLQUFMLEdBQWF5SyxHQUFiO0FBQ0E7QUFDRCxhQUFPekssS0FBUDtBQUNBO0FBQ0Q7QUFaSTtBQURJO0FBaEZFLEVBQWQ7O0FBa0dBO0FBQ0FpMEIsWUFBVztBQUNWeE0sT0FBSyxhQUFVNXFCLElBQVYsRUFBZ0JtRCxLQUFoQixFQUF1Qm5DLElBQXZCLEVBQThCO0FBQ2xDLE9BQUttQyxVQUFVLEtBQWYsRUFBdUI7QUFDdEI7QUFDQWhGLFdBQU9vNUIsVUFBUCxDQUFtQnYzQixJQUFuQixFQUF5QmdCLElBQXpCO0FBQ0EsSUFIRCxNQUdPLElBQUtzMkIsZUFBZWQsZUFBZixJQUFrQyxDQUFDYSxZQUFZbnVCLElBQVosQ0FBa0JsSSxJQUFsQixDQUF4QyxFQUFtRTtBQUN6RTtBQUNBaEIsU0FBS3FKLFlBQUwsQ0FBbUIsQ0FBQ210QixlQUFELElBQW9CcjRCLE9BQU8wNUIsT0FBUCxDQUFnQjcyQixJQUFoQixDQUFwQixJQUE4Q0EsSUFBakUsRUFBdUVBLElBQXZFOztBQUVEO0FBQ0MsSUFMTSxNQUtBO0FBQ05oQixTQUFNN0IsT0FBTzRFLFNBQVAsQ0FBa0IsYUFBYS9CLElBQS9CLENBQU4sSUFBZ0RoQixLQUFNZ0IsSUFBTixJQUFlLElBQS9EO0FBQ0E7O0FBRUQsVUFBT0EsSUFBUDtBQUNBO0FBZlMsRUFBWDs7QUFrQkE7QUFDQTdDLFFBQU95QixJQUFQLENBQWF6QixPQUFPc1AsSUFBUCxDQUFZdEYsS0FBWixDQUFrQnV2QixJQUFsQixDQUF1QjVaLE1BQXZCLENBQThCM1YsS0FBOUIsQ0FBcUMsTUFBckMsQ0FBYixFQUE0RCxVQUFVbEksQ0FBVixFQUFhZSxJQUFiLEVBQW9COztBQUUvRSxNQUFJODJCLFNBQVNydEIsV0FBWXpKLElBQVosS0FBc0I3QyxPQUFPaU8sSUFBUCxDQUFZdUIsSUFBL0M7O0FBRUFsRCxhQUFZekosSUFBWixJQUFxQnMyQixlQUFlZCxlQUFmLElBQWtDLENBQUNhLFlBQVludUIsSUFBWixDQUFrQmxJLElBQWxCLENBQW5DLEdBQ3BCLFVBQVVoQixJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBc0I0RCxLQUF0QixFQUE4QjtBQUM3QixPQUFJbkYsR0FBSixFQUFTb2hCLE1BQVQ7QUFDQSxPQUFLLENBQUNqYyxLQUFOLEVBQWM7QUFDYjtBQUNBaWMsYUFBU3BXLFdBQVl6SixJQUFaLENBQVQ7QUFDQXlKLGVBQVl6SixJQUFaLElBQXFCdkIsR0FBckI7QUFDQUEsVUFBTXE0QixPQUFROTNCLElBQVIsRUFBY2dCLElBQWQsRUFBb0I0RCxLQUFwQixLQUErQixJQUEvQixHQUNMNUQsS0FBS2tDLFdBQUwsRUFESyxHQUVMLElBRkQ7QUFHQXVILGVBQVl6SixJQUFaLElBQXFCNmYsTUFBckI7QUFDQTtBQUNELFVBQU9waEIsR0FBUDtBQUNBLEdBYm1CLEdBY3BCLFVBQVVPLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQjRELEtBQXRCLEVBQThCO0FBQzdCLE9BQUssQ0FBQ0EsS0FBTixFQUFjO0FBQ2IsV0FBTzVFLEtBQU03QixPQUFPNEUsU0FBUCxDQUFrQixhQUFhL0IsSUFBL0IsQ0FBTixJQUNOQSxLQUFLa0MsV0FBTCxFQURNLEdBRU4sSUFGRDtBQUdBO0FBQ0QsR0FwQkY7QUFxQkEsRUF6QkQ7O0FBMkJBO0FBQ0EsS0FBSyxDQUFDbzBCLFdBQUQsSUFBZ0IsQ0FBQ2QsZUFBdEIsRUFBd0M7QUFDdkNyNEIsU0FBT3M1QixTQUFQLENBQWlCdDBCLEtBQWpCLEdBQXlCO0FBQ3hCeW5CLFFBQUssYUFBVTVxQixJQUFWLEVBQWdCbUQsS0FBaEIsRUFBdUJuQyxJQUF2QixFQUE4QjtBQUNsQyxRQUFLN0MsT0FBTzhFLFFBQVAsQ0FBaUJqRCxJQUFqQixFQUF1QixPQUF2QixDQUFMLEVBQXdDO0FBQ3ZDO0FBQ0FBLFVBQUtzVSxZQUFMLEdBQW9CblIsS0FBcEI7QUFDQSxLQUhELE1BR087QUFDTjtBQUNBLFlBQU9nMEIsWUFBWUEsU0FBU3ZNLEdBQVQsQ0FBYzVxQixJQUFkLEVBQW9CbUQsS0FBcEIsRUFBMkJuQyxJQUEzQixDQUFuQjtBQUNBO0FBQ0Q7QUFUdUIsR0FBekI7QUFXQTs7QUFFRDtBQUNBLEtBQUssQ0FBQ3cxQixlQUFOLEVBQXdCOztBQUV2QjtBQUNBO0FBQ0FXLGFBQVc7QUFDVnZNLFFBQUssYUFBVTVxQixJQUFWLEVBQWdCbUQsS0FBaEIsRUFBdUJuQyxJQUF2QixFQUE4QjtBQUNsQztBQUNBLFFBQUl2QixNQUFNTyxLQUFLdU0sZ0JBQUwsQ0FBdUJ2TCxJQUF2QixDQUFWO0FBQ0EsUUFBSyxDQUFDdkIsR0FBTixFQUFZO0FBQ1hPLFVBQUsrM0IsZ0JBQUwsQ0FDRXQ0QixNQUFNTyxLQUFLMEksYUFBTCxDQUFtQnN2QixlQUFuQixDQUFvQ2gzQixJQUFwQyxDQURSO0FBR0E7O0FBRUR2QixRQUFJMEQsS0FBSixHQUFZQSxTQUFTLEVBQXJCOztBQUVBO0FBQ0EsUUFBS25DLFNBQVMsT0FBVCxJQUFvQm1DLFVBQVVuRCxLQUFLb0osWUFBTCxDQUFtQnBJLElBQW5CLENBQW5DLEVBQStEO0FBQzlELFlBQU9tQyxLQUFQO0FBQ0E7QUFDRDtBQWhCUyxHQUFYOztBQW1CQTtBQUNBc0gsYUFBVzNCLEVBQVgsR0FBZ0IyQixXQUFXekosSUFBWCxHQUFrQnlKLFdBQVd3dEIsTUFBWCxHQUNqQyxVQUFVajRCLElBQVYsRUFBZ0JnQixJQUFoQixFQUFzQjRELEtBQXRCLEVBQThCO0FBQzdCLE9BQUluRixHQUFKO0FBQ0EsT0FBSyxDQUFDbUYsS0FBTixFQUFjO0FBQ2IsV0FBTyxDQUFDbkYsTUFBTU8sS0FBS3VNLGdCQUFMLENBQXVCdkwsSUFBdkIsQ0FBUCxLQUF5Q3ZCLElBQUkwRCxLQUFKLEtBQWMsRUFBdkQsR0FDTjFELElBQUkwRCxLQURFLEdBRU4sSUFGRDtBQUdBO0FBQ0QsR0FSRjs7QUFVQTtBQUNBaEYsU0FBTzY0QixRQUFQLENBQWdCalUsTUFBaEIsR0FBeUI7QUFDeEIxakIsUUFBSyxhQUFVVyxJQUFWLEVBQWdCZ0IsSUFBaEIsRUFBdUI7QUFDM0IsUUFBSXZCLE1BQU1PLEtBQUt1TSxnQkFBTCxDQUF1QnZMLElBQXZCLENBQVY7QUFDQSxRQUFLdkIsT0FBT0EsSUFBSW9PLFNBQWhCLEVBQTRCO0FBQzNCLFlBQU9wTyxJQUFJMEQsS0FBWDtBQUNBO0FBQ0QsSUFOdUI7QUFPeEJ5bkIsUUFBS3VNLFNBQVN2TTtBQVBVLEdBQXpCOztBQVVBO0FBQ0E7QUFDQXpzQixTQUFPczVCLFNBQVAsQ0FBaUJTLGVBQWpCLEdBQW1DO0FBQ2xDdE4sUUFBSyxhQUFVNXFCLElBQVYsRUFBZ0JtRCxLQUFoQixFQUF1Qm5DLElBQXZCLEVBQThCO0FBQ2xDbTJCLGFBQVN2TSxHQUFULENBQWM1cUIsSUFBZCxFQUFvQm1ELFVBQVUsRUFBVixHQUFlLEtBQWYsR0FBdUJBLEtBQTNDLEVBQWtEbkMsSUFBbEQ7QUFDQTtBQUhpQyxHQUFuQzs7QUFNQTtBQUNBO0FBQ0E3QyxTQUFPeUIsSUFBUCxDQUFZLENBQUUsT0FBRixFQUFXLFFBQVgsQ0FBWixFQUFtQyxVQUFVSyxDQUFWLEVBQWFlLElBQWIsRUFBb0I7QUFDdEQ3QyxVQUFPczVCLFNBQVAsQ0FBa0J6MkIsSUFBbEIsSUFBMkI7QUFDMUI0cEIsU0FBSyxhQUFVNXFCLElBQVYsRUFBZ0JtRCxLQUFoQixFQUF3QjtBQUM1QixTQUFLQSxVQUFVLEVBQWYsRUFBb0I7QUFDbkJuRCxXQUFLcUosWUFBTCxDQUFtQnJJLElBQW5CLEVBQXlCLE1BQXpCO0FBQ0EsYUFBT21DLEtBQVA7QUFDQTtBQUNEO0FBTnlCLElBQTNCO0FBUUEsR0FURDtBQVVBOztBQUVELEtBQUssQ0FBQ2xGLFFBQVEwZCxLQUFkLEVBQXNCO0FBQ3JCeGQsU0FBT3M1QixTQUFQLENBQWlCOWIsS0FBakIsR0FBeUI7QUFDeEJ0YyxRQUFLLGFBQVVXLElBQVYsRUFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsV0FBT0EsS0FBSzJiLEtBQUwsQ0FBV0MsT0FBWCxJQUFzQnBhLFNBQTdCO0FBQ0EsSUFOdUI7QUFPeEJvcEIsUUFBSyxhQUFVNXFCLElBQVYsRUFBZ0JtRCxLQUFoQixFQUF3QjtBQUM1QixXQUFTbkQsS0FBSzJiLEtBQUwsQ0FBV0MsT0FBWCxHQUFxQnpZLFFBQVEsRUFBdEM7QUFDQTtBQVR1QixHQUF6QjtBQVdBOztBQUtELEtBQUlnMUIsYUFBYSw0Q0FBakI7QUFBQSxLQUNDQyxhQUFhLGVBRGQ7O0FBR0FqNkIsUUFBT0csRUFBUCxDQUFVc0MsTUFBVixDQUFpQjtBQUNoQm9pQixRQUFNLGNBQVVoaUIsSUFBVixFQUFnQm1DLEtBQWhCLEVBQXdCO0FBQzdCLFVBQU9nYixPQUFRLElBQVIsRUFBY2hnQixPQUFPNmtCLElBQXJCLEVBQTJCaGlCLElBQTNCLEVBQWlDbUMsS0FBakMsRUFBd0NoRCxVQUFVakIsTUFBVixHQUFtQixDQUEzRCxDQUFQO0FBQ0EsR0FIZTs7QUFLaEJtNUIsY0FBWSxvQkFBVXIzQixJQUFWLEVBQWlCO0FBQzVCQSxVQUFPN0MsT0FBTzA1QixPQUFQLENBQWdCNzJCLElBQWhCLEtBQTBCQSxJQUFqQztBQUNBLFVBQU8sS0FBS3BCLElBQUwsQ0FBVSxZQUFXO0FBQzNCO0FBQ0EsUUFBSTtBQUNILFVBQU1vQixJQUFOLElBQWVRLFNBQWY7QUFDQSxZQUFPLEtBQU1SLElBQU4sQ0FBUDtBQUNBLEtBSEQsQ0FHRSxPQUFPMEIsQ0FBUCxFQUFXLENBQUU7QUFDZixJQU5NLENBQVA7QUFPQTtBQWRlLEVBQWpCOztBQWlCQXZFLFFBQU95QyxNQUFQLENBQWM7QUFDYmkzQixXQUFTO0FBQ1IsVUFBTyxTQURDO0FBRVIsWUFBUztBQUZELEdBREk7O0FBTWI3VSxRQUFNLGNBQVVoakIsSUFBVixFQUFnQmdCLElBQWhCLEVBQXNCbUMsS0FBdEIsRUFBOEI7QUFDbkMsT0FBSTFELEdBQUo7QUFBQSxPQUFTNmQsS0FBVDtBQUFBLE9BQWdCZ2IsTUFBaEI7QUFBQSxPQUNDZCxRQUFReDNCLEtBQUt5QyxRQURkOztBQUdBO0FBQ0EsT0FBSyxDQUFDekMsSUFBRCxJQUFTdzNCLFVBQVUsQ0FBbkIsSUFBd0JBLFVBQVUsQ0FBbEMsSUFBdUNBLFVBQVUsQ0FBdEQsRUFBMEQ7QUFDekQ7QUFDQTs7QUFFRGMsWUFBU2QsVUFBVSxDQUFWLElBQWUsQ0FBQ3I1QixPQUFPcVcsUUFBUCxDQUFpQnhVLElBQWpCLENBQXpCOztBQUVBLE9BQUtzNEIsTUFBTCxFQUFjO0FBQ2I7QUFDQXQzQixXQUFPN0MsT0FBTzA1QixPQUFQLENBQWdCNzJCLElBQWhCLEtBQTBCQSxJQUFqQztBQUNBc2MsWUFBUW5mLE9BQU9rekIsU0FBUCxDQUFrQnJ3QixJQUFsQixDQUFSO0FBQ0E7O0FBRUQsT0FBS21DLFVBQVUzQixTQUFmLEVBQTJCO0FBQzFCLFdBQU84YixTQUFTLFNBQVNBLEtBQWxCLElBQTJCLENBQUM3ZCxNQUFNNmQsTUFBTXNOLEdBQU4sQ0FBVzVxQixJQUFYLEVBQWlCbUQsS0FBakIsRUFBd0JuQyxJQUF4QixDQUFQLE1BQTJDUSxTQUF0RSxHQUNOL0IsR0FETSxHQUVKTyxLQUFNZ0IsSUFBTixJQUFlbUMsS0FGbEI7QUFJQSxJQUxELE1BS087QUFDTixXQUFPbWEsU0FBUyxTQUFTQSxLQUFsQixJQUEyQixDQUFDN2QsTUFBTTZkLE1BQU1qZSxHQUFOLENBQVdXLElBQVgsRUFBaUJnQixJQUFqQixDQUFQLE1BQW9DLElBQS9ELEdBQ052QixHQURNLEdBRU5PLEtBQU1nQixJQUFOLENBRkQ7QUFHQTtBQUNELEdBakNZOztBQW1DYnF3QixhQUFXO0FBQ1Y3Z0IsYUFBVTtBQUNUblIsU0FBSyxhQUFVVyxJQUFWLEVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQUl1NEIsV0FBV3A2QixPQUFPaU8sSUFBUCxDQUFZdUIsSUFBWixDQUFrQjNOLElBQWxCLEVBQXdCLFVBQXhCLENBQWY7O0FBRUEsWUFBT3U0QixXQUNOQyxTQUFVRCxRQUFWLEVBQW9CLEVBQXBCLENBRE0sR0FFTkosV0FBV2p2QixJQUFYLENBQWlCbEosS0FBS2lELFFBQXRCLEtBQW9DbTFCLFdBQVdsdkIsSUFBWCxDQUFpQmxKLEtBQUtpRCxRQUF0QixLQUFvQ2pELEtBQUt1USxJQUE3RSxHQUNDLENBREQsR0FFQyxDQUFDLENBSkg7QUFLQTtBQVpRO0FBREE7QUFuQ0UsRUFBZDs7QUFxREE7QUFDQTtBQUNBLEtBQUssQ0FBQ3RTLFFBQVF3NEIsY0FBZCxFQUErQjtBQUM5QjtBQUNBdDRCLFNBQU95QixJQUFQLENBQVksQ0FBRSxNQUFGLEVBQVUsS0FBVixDQUFaLEVBQStCLFVBQVVLLENBQVYsRUFBYWUsSUFBYixFQUFvQjtBQUNsRDdDLFVBQU9rekIsU0FBUCxDQUFrQnJ3QixJQUFsQixJQUEyQjtBQUMxQjNCLFNBQUssYUFBVVcsSUFBVixFQUFpQjtBQUNyQixZQUFPQSxLQUFLb0osWUFBTCxDQUFtQnBJLElBQW5CLEVBQXlCLENBQXpCLENBQVA7QUFDQTtBQUh5QixJQUEzQjtBQUtBLEdBTkQ7QUFPQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxLQUFLLENBQUMvQyxRQUFRMDRCLFdBQWQsRUFBNEI7QUFDM0J4NEIsU0FBT2t6QixTQUFQLENBQWlCMWdCLFFBQWpCLEdBQTRCO0FBQzNCdFIsUUFBSyxhQUFVVyxJQUFWLEVBQWlCO0FBQ3JCLFFBQUl3TCxTQUFTeEwsS0FBSzZJLFVBQWxCOztBQUVBLFFBQUsyQyxNQUFMLEVBQWM7QUFDYkEsWUFBT29GLGFBQVA7O0FBRUE7QUFDQSxTQUFLcEYsT0FBTzNDLFVBQVosRUFBeUI7QUFDeEIyQyxhQUFPM0MsVUFBUCxDQUFrQitILGFBQWxCO0FBQ0E7QUFDRDtBQUNELFdBQU8sSUFBUDtBQUNBO0FBYjBCLEdBQTVCO0FBZUE7O0FBRUR6UyxRQUFPeUIsSUFBUCxDQUFZLENBQ1gsVUFEVyxFQUVYLFVBRlcsRUFHWCxXQUhXLEVBSVgsYUFKVyxFQUtYLGFBTFcsRUFNWCxTQU5XLEVBT1gsU0FQVyxFQVFYLFFBUlcsRUFTWCxhQVRXLEVBVVgsaUJBVlcsQ0FBWixFQVdHLFlBQVc7QUFDYnpCLFNBQU8wNUIsT0FBUCxDQUFnQixLQUFLMzBCLFdBQUwsRUFBaEIsSUFBdUMsSUFBdkM7QUFDQSxFQWJEOztBQWVBO0FBQ0EsS0FBSyxDQUFDakYsUUFBUTI0QixPQUFkLEVBQXdCO0FBQ3ZCejRCLFNBQU8wNUIsT0FBUCxDQUFlakIsT0FBZixHQUF5QixVQUF6QjtBQUNBOztBQUtELEtBQUk2QixTQUFTLGFBQWI7O0FBRUF0NkIsUUFBT0csRUFBUCxDQUFVc0MsTUFBVixDQUFpQjtBQUNoQjgzQixZQUFVLGtCQUFVdjFCLEtBQVYsRUFBa0I7QUFDM0IsT0FBSXcxQixPQUFKO0FBQUEsT0FBYTM0QixJQUFiO0FBQUEsT0FBbUIySyxHQUFuQjtBQUFBLE9BQXdCaXVCLEtBQXhCO0FBQUEsT0FBK0JwNEIsQ0FBL0I7QUFBQSxPQUFrQ3E0QixVQUFsQztBQUFBLE9BQ0M1NEIsSUFBSSxDQURMO0FBQUEsT0FFQ00sTUFBTSxLQUFLckIsTUFGWjtBQUFBLE9BR0M0NUIsVUFBVSxPQUFPMzFCLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLEtBSHhDOztBQUtBLE9BQUtoRixPQUFPa0QsVUFBUCxDQUFtQjhCLEtBQW5CLENBQUwsRUFBa0M7QUFDakMsV0FBTyxLQUFLdkQsSUFBTCxDQUFVLFVBQVVZLENBQVYsRUFBYztBQUM5QnJDLFlBQVEsSUFBUixFQUFldTZCLFFBQWYsQ0FBeUJ2MUIsTUFBTS9ELElBQU4sQ0FBWSxJQUFaLEVBQWtCb0IsQ0FBbEIsRUFBcUIsS0FBS3FMLFNBQTFCLENBQXpCO0FBQ0EsS0FGTSxDQUFQO0FBR0E7O0FBRUQsT0FBS2l0QixPQUFMLEVBQWU7QUFDZDtBQUNBSCxjQUFVLENBQUV4MUIsU0FBUyxFQUFYLEVBQWdCZ0YsS0FBaEIsQ0FBdUIrTyxTQUF2QixLQUFzQyxFQUFoRDs7QUFFQSxXQUFRalgsSUFBSU0sR0FBWixFQUFpQk4sR0FBakIsRUFBdUI7QUFDdEJELFlBQU8sS0FBTUMsQ0FBTixDQUFQO0FBQ0EwSyxXQUFNM0ssS0FBS3lDLFFBQUwsS0FBa0IsQ0FBbEIsS0FBeUJ6QyxLQUFLNkwsU0FBTCxHQUM5QixDQUFFLE1BQU03TCxLQUFLNkwsU0FBWCxHQUF1QixHQUF6QixFQUErQmpLLE9BQS9CLENBQXdDNjJCLE1BQXhDLEVBQWdELEdBQWhELENBRDhCLEdBRTlCLEdBRkssQ0FBTjs7QUFLQSxTQUFLOXRCLEdBQUwsRUFBVztBQUNWbkssVUFBSSxDQUFKO0FBQ0EsYUFBU280QixRQUFRRCxRQUFRbjRCLEdBQVIsQ0FBakIsRUFBaUM7QUFDaEMsV0FBS21LLElBQUloTixPQUFKLENBQWEsTUFBTWk3QixLQUFOLEdBQWMsR0FBM0IsSUFBbUMsQ0FBeEMsRUFBNEM7QUFDM0NqdUIsZUFBT2l1QixRQUFRLEdBQWY7QUFDQTtBQUNEOztBQUVEO0FBQ0FDLG1CQUFhMTZCLE9BQU9ILElBQVAsQ0FBYTJNLEdBQWIsQ0FBYjtBQUNBLFVBQUszSyxLQUFLNkwsU0FBTCxLQUFtQmd0QixVQUF4QixFQUFxQztBQUNwQzc0QixZQUFLNkwsU0FBTCxHQUFpQmd0QixVQUFqQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFVBQU8sSUFBUDtBQUNBLEdBMUNlOztBQTRDaEJFLGVBQWEscUJBQVU1MUIsS0FBVixFQUFrQjtBQUM5QixPQUFJdzFCLE9BQUo7QUFBQSxPQUFhMzRCLElBQWI7QUFBQSxPQUFtQjJLLEdBQW5CO0FBQUEsT0FBd0JpdUIsS0FBeEI7QUFBQSxPQUErQnA0QixDQUEvQjtBQUFBLE9BQWtDcTRCLFVBQWxDO0FBQUEsT0FDQzU0QixJQUFJLENBREw7QUFBQSxPQUVDTSxNQUFNLEtBQUtyQixNQUZaO0FBQUEsT0FHQzQ1QixVQUFVMzRCLFVBQVVqQixNQUFWLEtBQXFCLENBQXJCLElBQTBCLE9BQU9pRSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCQSxLQUhsRTs7QUFLQSxPQUFLaEYsT0FBT2tELFVBQVAsQ0FBbUI4QixLQUFuQixDQUFMLEVBQWtDO0FBQ2pDLFdBQU8sS0FBS3ZELElBQUwsQ0FBVSxVQUFVWSxDQUFWLEVBQWM7QUFDOUJyQyxZQUFRLElBQVIsRUFBZTQ2QixXQUFmLENBQTRCNTFCLE1BQU0vRCxJQUFOLENBQVksSUFBWixFQUFrQm9CLENBQWxCLEVBQXFCLEtBQUtxTCxTQUExQixDQUE1QjtBQUNBLEtBRk0sQ0FBUDtBQUdBO0FBQ0QsT0FBS2l0QixPQUFMLEVBQWU7QUFDZEgsY0FBVSxDQUFFeDFCLFNBQVMsRUFBWCxFQUFnQmdGLEtBQWhCLENBQXVCK08sU0FBdkIsS0FBc0MsRUFBaEQ7O0FBRUEsV0FBUWpYLElBQUlNLEdBQVosRUFBaUJOLEdBQWpCLEVBQXVCO0FBQ3RCRCxZQUFPLEtBQU1DLENBQU4sQ0FBUDtBQUNBO0FBQ0EwSyxXQUFNM0ssS0FBS3lDLFFBQUwsS0FBa0IsQ0FBbEIsS0FBeUJ6QyxLQUFLNkwsU0FBTCxHQUM5QixDQUFFLE1BQU03TCxLQUFLNkwsU0FBWCxHQUF1QixHQUF6QixFQUErQmpLLE9BQS9CLENBQXdDNjJCLE1BQXhDLEVBQWdELEdBQWhELENBRDhCLEdBRTlCLEVBRkssQ0FBTjs7QUFLQSxTQUFLOXRCLEdBQUwsRUFBVztBQUNWbkssVUFBSSxDQUFKO0FBQ0EsYUFBU280QixRQUFRRCxRQUFRbjRCLEdBQVIsQ0FBakIsRUFBaUM7QUFDaEM7QUFDQSxjQUFRbUssSUFBSWhOLE9BQUosQ0FBYSxNQUFNaTdCLEtBQU4sR0FBYyxHQUEzQixLQUFvQyxDQUE1QyxFQUFnRDtBQUMvQ2p1QixjQUFNQSxJQUFJL0ksT0FBSixDQUFhLE1BQU1nM0IsS0FBTixHQUFjLEdBQTNCLEVBQWdDLEdBQWhDLENBQU47QUFDQTtBQUNEOztBQUVEO0FBQ0FDLG1CQUFhMTFCLFFBQVFoRixPQUFPSCxJQUFQLENBQWEyTSxHQUFiLENBQVIsR0FBNkIsRUFBMUM7QUFDQSxVQUFLM0ssS0FBSzZMLFNBQUwsS0FBbUJndEIsVUFBeEIsRUFBcUM7QUFDcEM3NEIsWUFBSzZMLFNBQUwsR0FBaUJndEIsVUFBakI7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxVQUFPLElBQVA7QUFDQSxHQXJGZTs7QUF1RmhCRyxlQUFhLHFCQUFVNzFCLEtBQVYsRUFBaUI4MUIsUUFBakIsRUFBNEI7QUFDeEMsT0FBSS8yQixjQUFjaUIsS0FBZCx5Q0FBY0EsS0FBZCxDQUFKOztBQUVBLE9BQUssT0FBTzgxQixRQUFQLEtBQW9CLFNBQXBCLElBQWlDLzJCLFNBQVMsUUFBL0MsRUFBMEQ7QUFDekQsV0FBTysyQixXQUFXLEtBQUtQLFFBQUwsQ0FBZXYxQixLQUFmLENBQVgsR0FBb0MsS0FBSzQxQixXQUFMLENBQWtCNTFCLEtBQWxCLENBQTNDO0FBQ0E7O0FBRUQsT0FBS2hGLE9BQU9rRCxVQUFQLENBQW1COEIsS0FBbkIsQ0FBTCxFQUFrQztBQUNqQyxXQUFPLEtBQUt2RCxJQUFMLENBQVUsVUFBVUssQ0FBVixFQUFjO0FBQzlCOUIsWUFBUSxJQUFSLEVBQWU2NkIsV0FBZixDQUE0QjcxQixNQUFNL0QsSUFBTixDQUFXLElBQVgsRUFBaUJhLENBQWpCLEVBQW9CLEtBQUs0TCxTQUF6QixFQUFvQ290QixRQUFwQyxDQUE1QixFQUEyRUEsUUFBM0U7QUFDQSxLQUZNLENBQVA7QUFHQTs7QUFFRCxVQUFPLEtBQUtyNUIsSUFBTCxDQUFVLFlBQVc7QUFDM0IsUUFBS3NDLFNBQVMsUUFBZCxFQUF5QjtBQUN4QjtBQUNBLFNBQUkySixTQUFKO0FBQUEsU0FDQzVMLElBQUksQ0FETDtBQUFBLFNBRUMrVSxPQUFPN1csT0FBUSxJQUFSLENBRlI7QUFBQSxTQUdDKzZCLGFBQWEvMUIsTUFBTWdGLEtBQU4sQ0FBYStPLFNBQWIsS0FBNEIsRUFIMUM7O0FBS0EsWUFBU3JMLFlBQVlxdEIsV0FBWWo1QixHQUFaLENBQXJCLEVBQTBDO0FBQ3pDO0FBQ0EsVUFBSytVLEtBQUtta0IsUUFBTCxDQUFldHRCLFNBQWYsQ0FBTCxFQUFrQztBQUNqQ21KLFlBQUsrakIsV0FBTCxDQUFrQmx0QixTQUFsQjtBQUNBLE9BRkQsTUFFTztBQUNObUosWUFBSzBqQixRQUFMLENBQWU3c0IsU0FBZjtBQUNBO0FBQ0Q7O0FBRUY7QUFDQyxLQWpCRCxNQWlCTyxJQUFLM0osU0FBUytELFlBQVQsSUFBeUIvRCxTQUFTLFNBQXZDLEVBQW1EO0FBQ3pELFNBQUssS0FBSzJKLFNBQVYsRUFBc0I7QUFDckI7QUFDQTFOLGFBQU84ZSxLQUFQLENBQWMsSUFBZCxFQUFvQixlQUFwQixFQUFxQyxLQUFLcFIsU0FBMUM7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUtBLFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxJQUFrQjFJLFVBQVUsS0FBNUIsR0FBb0MsRUFBcEMsR0FBeUNoRixPQUFPOGUsS0FBUCxDQUFjLElBQWQsRUFBb0IsZUFBcEIsS0FBeUMsRUFBbkc7QUFDQTtBQUNELElBOUJNLENBQVA7QUErQkEsR0FuSWU7O0FBcUloQmtjLFlBQVUsa0JBQVUvNkIsUUFBVixFQUFxQjtBQUM5QixPQUFJeU4sWUFBWSxNQUFNek4sUUFBTixHQUFpQixHQUFqQztBQUFBLE9BQ0M2QixJQUFJLENBREw7QUFBQSxPQUVDa1csSUFBSSxLQUFLalgsTUFGVjtBQUdBLFVBQVFlLElBQUlrVyxDQUFaLEVBQWVsVyxHQUFmLEVBQXFCO0FBQ3BCLFFBQUssS0FBS0EsQ0FBTCxFQUFRd0MsUUFBUixLQUFxQixDQUFyQixJQUEwQixDQUFDLE1BQU0sS0FBS3hDLENBQUwsRUFBUTRMLFNBQWQsR0FBMEIsR0FBM0IsRUFBZ0NqSyxPQUFoQyxDQUF3QzYyQixNQUF4QyxFQUFnRCxHQUFoRCxFQUFxRDk2QixPQUFyRCxDQUE4RGtPLFNBQTlELEtBQTZFLENBQTVHLEVBQWdIO0FBQy9HLFlBQU8sSUFBUDtBQUNBO0FBQ0Q7O0FBRUQsVUFBTyxLQUFQO0FBQ0E7QUFoSmUsRUFBakI7O0FBc0pBOzs7QUFHQTFOLFFBQU95QixJQUFQLENBQWEsQ0FBQywwRUFDYix1RUFEYSxHQUViLCtEQUZZLEVBRXFENEUsS0FGckQsQ0FFMkQsR0FGM0QsQ0FBYixFQUU4RSxVQUFVdkUsQ0FBVixFQUFhZSxJQUFiLEVBQW9COztBQUVqRztBQUNBN0MsU0FBT0csRUFBUCxDQUFXMEMsSUFBWCxJQUFvQixVQUFVNkIsSUFBVixFQUFnQnZFLEVBQWhCLEVBQXFCO0FBQ3hDLFVBQU82QixVQUFVakIsTUFBVixHQUFtQixDQUFuQixHQUNOLEtBQUtnbkIsRUFBTCxDQUFTbGxCLElBQVQsRUFBZSxJQUFmLEVBQXFCNkIsSUFBckIsRUFBMkJ2RSxFQUEzQixDQURNLEdBRU4sS0FBS3djLE9BQUwsQ0FBYzlaLElBQWQsQ0FGRDtBQUdBLEdBSkQ7QUFLQSxFQVZEOztBQVlBN0MsUUFBT0csRUFBUCxDQUFVc0MsTUFBVixDQUFpQjtBQUNoQnc0QixTQUFPLGVBQVVDLE1BQVYsRUFBa0JDLEtBQWxCLEVBQTBCO0FBQ2hDLFVBQU8sS0FBS2hVLFVBQUwsQ0FBaUIrVCxNQUFqQixFQUEwQjlULFVBQTFCLENBQXNDK1QsU0FBU0QsTUFBL0MsQ0FBUDtBQUNBLEdBSGU7O0FBS2hCRSxRQUFNLGNBQVVyWixLQUFWLEVBQWlCcmQsSUFBakIsRUFBdUJ2RSxFQUF2QixFQUE0QjtBQUNqQyxVQUFPLEtBQUs0bkIsRUFBTCxDQUFTaEcsS0FBVCxFQUFnQixJQUFoQixFQUFzQnJkLElBQXRCLEVBQTRCdkUsRUFBNUIsQ0FBUDtBQUNBLEdBUGU7QUFRaEJrN0IsVUFBUSxnQkFBVXRaLEtBQVYsRUFBaUI1aEIsRUFBakIsRUFBc0I7QUFDN0IsVUFBTyxLQUFLeWMsR0FBTCxDQUFVbUYsS0FBVixFQUFpQixJQUFqQixFQUF1QjVoQixFQUF2QixDQUFQO0FBQ0EsR0FWZTs7QUFZaEJtN0IsWUFBVSxrQkFBVXI3QixRQUFWLEVBQW9COGhCLEtBQXBCLEVBQTJCcmQsSUFBM0IsRUFBaUN2RSxFQUFqQyxFQUFzQztBQUMvQyxVQUFPLEtBQUs0bkIsRUFBTCxDQUFTaEcsS0FBVCxFQUFnQjloQixRQUFoQixFQUEwQnlFLElBQTFCLEVBQWdDdkUsRUFBaEMsQ0FBUDtBQUNBLEdBZGU7QUFlaEJvN0IsY0FBWSxvQkFBVXQ3QixRQUFWLEVBQW9COGhCLEtBQXBCLEVBQTJCNWhCLEVBQTNCLEVBQWdDO0FBQzNDO0FBQ0EsVUFBTzZCLFVBQVVqQixNQUFWLEtBQXFCLENBQXJCLEdBQXlCLEtBQUs2YixHQUFMLENBQVUzYyxRQUFWLEVBQW9CLElBQXBCLENBQXpCLEdBQXNELEtBQUsyYyxHQUFMLENBQVVtRixLQUFWLEVBQWlCOWhCLFlBQVksSUFBN0IsRUFBbUNFLEVBQW5DLENBQTdEO0FBQ0E7QUFsQmUsRUFBakI7O0FBc0JBLEtBQUlxN0IsUUFBUXg3QixPQUFPbUcsR0FBUCxFQUFaOztBQUVBLEtBQUlzMUIsU0FBVSxJQUFkOztBQUlBLEtBQUlDLGVBQWUsa0lBQW5COztBQUVBMTdCLFFBQU9rZSxTQUFQLEdBQW1CLFVBQVV4WixJQUFWLEVBQWlCO0FBQ25DO0FBQ0EsTUFBS3hGLE9BQU95OEIsSUFBUCxJQUFlejhCLE9BQU95OEIsSUFBUCxDQUFZQyxLQUFoQyxFQUF3QztBQUN2QztBQUNBO0FBQ0EsVUFBTzE4QixPQUFPeThCLElBQVAsQ0FBWUMsS0FBWixDQUFtQmwzQixPQUFPLEVBQTFCLENBQVA7QUFDQTs7QUFFRCxNQUFJbTNCLGVBQUo7QUFBQSxNQUNDQyxRQUFRLElBRFQ7QUFBQSxNQUVDQyxNQUFNLzdCLE9BQU9ILElBQVAsQ0FBYTZFLE9BQU8sRUFBcEIsQ0FGUDs7QUFJQTtBQUNBO0FBQ0EsU0FBT3EzQixPQUFPLENBQUMvN0IsT0FBT0gsSUFBUCxDQUFhazhCLElBQUl0NEIsT0FBSixDQUFhaTRCLFlBQWIsRUFBMkIsVUFBVXpsQixLQUFWLEVBQWlCK2xCLEtBQWpCLEVBQXdCQyxJQUF4QixFQUE4QnpPLEtBQTlCLEVBQXNDOztBQUU1RjtBQUNBLE9BQUtxTyxtQkFBbUJHLEtBQXhCLEVBQWdDO0FBQy9CRixZQUFRLENBQVI7QUFDQTs7QUFFRDtBQUNBLE9BQUtBLFVBQVUsQ0FBZixFQUFtQjtBQUNsQixXQUFPN2xCLEtBQVA7QUFDQTs7QUFFRDtBQUNBNGxCLHFCQUFrQkksUUFBUUQsS0FBMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQUYsWUFBUyxDQUFDdE8sS0FBRCxHQUFTLENBQUN5TyxJQUFuQjs7QUFFQTtBQUNBLFVBQU8sRUFBUDtBQUNBLEdBdkIyQixDQUFiLENBQVIsR0F3QkpDLFNBQVUsWUFBWUgsR0FBdEIsQ0FBRixFQXhCTSxHQXlCTi83QixPQUFPMkQsS0FBUCxDQUFjLG1CQUFtQmUsSUFBakMsQ0F6QkQ7QUEwQkEsRUF4Q0Q7O0FBMkNBO0FBQ0ExRSxRQUFPbThCLFFBQVAsR0FBa0IsVUFBVXozQixJQUFWLEVBQWlCO0FBQ2xDLE1BQUl1TSxHQUFKLEVBQVMvSyxHQUFUO0FBQ0EsTUFBSyxDQUFDeEIsSUFBRCxJQUFTLE9BQU9BLElBQVAsS0FBZ0IsUUFBOUIsRUFBeUM7QUFDeEMsVUFBTyxJQUFQO0FBQ0E7QUFDRCxNQUFJO0FBQ0gsT0FBS3hGLE9BQU9rOUIsU0FBWixFQUF3QjtBQUFFO0FBQ3pCbDJCLFVBQU0sSUFBSWsyQixTQUFKLEVBQU47QUFDQW5yQixVQUFNL0ssSUFBSW0yQixlQUFKLENBQXFCMzNCLElBQXJCLEVBQTJCLFVBQTNCLENBQU47QUFDQSxJQUhELE1BR087QUFBRTtBQUNSdU0sVUFBTSxJQUFJcXJCLGFBQUosQ0FBbUIsa0JBQW5CLENBQU47QUFDQXJyQixRQUFJc3JCLEtBQUosR0FBWSxPQUFaO0FBQ0F0ckIsUUFBSXVyQixPQUFKLENBQWE5M0IsSUFBYjtBQUNBO0FBQ0QsR0FURCxDQVNFLE9BQU9ILENBQVAsRUFBVztBQUNaME0sU0FBTTVOLFNBQU47QUFDQTtBQUNELE1BQUssQ0FBQzROLEdBQUQsSUFBUSxDQUFDQSxJQUFJaEUsZUFBYixJQUFnQ2dFLElBQUlyRyxvQkFBSixDQUEwQixhQUExQixFQUEwQzdKLE1BQS9FLEVBQXdGO0FBQ3ZGZixVQUFPMkQsS0FBUCxDQUFjLGtCQUFrQmUsSUFBaEM7QUFDQTtBQUNELFNBQU91TSxHQUFQO0FBQ0EsRUFyQkQ7O0FBd0JBO0FBQ0M7QUFDQXdyQixhQUZEO0FBQUEsS0FHQ0MsWUFIRDtBQUFBLEtBS0NDLFFBQVEsTUFMVDtBQUFBLEtBTUNDLE1BQU0sZUFOUDtBQUFBLEtBT0NDLFdBQVcsK0JBUFo7QUFBQSxLQU82QztBQUM1QztBQUNBQyxrQkFBaUIsMkRBVGxCO0FBQUEsS0FVQ0MsYUFBYSxnQkFWZDtBQUFBLEtBV0NDLFlBQVksT0FYYjtBQUFBLEtBWUNDLE9BQU8sMkRBWlI7OztBQWNDOzs7Ozs7Ozs7QUFTQUMsY0FBYSxFQXZCZDs7O0FBeUJDOzs7OztBQUtBQyxjQUFhLEVBOUJkOzs7QUFnQ0M7QUFDQUMsWUFBVyxLQUFLOTlCLE1BQUwsQ0FBWSxHQUFaLENBakNaOztBQW1DQTtBQUNBO0FBQ0EsS0FBSTtBQUNIbzlCLGlCQUFlenFCLFNBQVNHLElBQXhCO0FBQ0EsRUFGRCxDQUVFLE9BQU83TixDQUFQLEVBQVc7QUFDWjtBQUNBO0FBQ0FtNEIsaUJBQWUzOUIsU0FBU2tOLGFBQVQsQ0FBd0IsR0FBeEIsQ0FBZjtBQUNBeXdCLGVBQWF0cUIsSUFBYixHQUFvQixFQUFwQjtBQUNBc3FCLGlCQUFlQSxhQUFhdHFCLElBQTVCO0FBQ0E7O0FBRUQ7QUFDQXFxQixnQkFBZVEsS0FBS3p5QixJQUFMLENBQVdreUIsYUFBYTMzQixXQUFiLEVBQVgsS0FBMkMsRUFBMUQ7O0FBRUE7QUFDQSxVQUFTczRCLDJCQUFULENBQXNDQyxTQUF0QyxFQUFrRDs7QUFFakQ7QUFDQSxTQUFPLFVBQVVDLGtCQUFWLEVBQThCaGpCLElBQTlCLEVBQXFDOztBQUUzQyxPQUFLLE9BQU9nakIsa0JBQVAsS0FBOEIsUUFBbkMsRUFBOEM7QUFDN0NoakIsV0FBT2dqQixrQkFBUDtBQUNBQSx5QkFBcUIsR0FBckI7QUFDQTs7QUFFRCxPQUFJQyxRQUFKO0FBQUEsT0FDQzE3QixJQUFJLENBREw7QUFBQSxPQUVDMjdCLFlBQVlGLG1CQUFtQng0QixXQUFuQixHQUFpQ2lGLEtBQWpDLENBQXdDK08sU0FBeEMsS0FBdUQsRUFGcEU7O0FBSUEsT0FBSy9ZLE9BQU9rRCxVQUFQLENBQW1CcVgsSUFBbkIsQ0FBTCxFQUFpQztBQUNoQztBQUNBLFdBQVNpakIsV0FBV0MsVUFBVTM3QixHQUFWLENBQXBCLEVBQXNDO0FBQ3JDO0FBQ0EsU0FBSzA3QixTQUFTeG1CLE1BQVQsQ0FBaUIsQ0FBakIsTUFBeUIsR0FBOUIsRUFBb0M7QUFDbkN3bUIsaUJBQVdBLFNBQVNuK0IsS0FBVCxDQUFnQixDQUFoQixLQUF1QixHQUFsQztBQUNBLE9BQUNpK0IsVUFBV0UsUUFBWCxJQUF3QkYsVUFBV0UsUUFBWCxLQUF5QixFQUFsRCxFQUFzRG51QixPQUF0RCxDQUErRGtMLElBQS9EOztBQUVEO0FBQ0MsTUFMRCxNQUtPO0FBQ04sT0FBQytpQixVQUFXRSxRQUFYLElBQXdCRixVQUFXRSxRQUFYLEtBQXlCLEVBQWxELEVBQXNEaitCLElBQXRELENBQTREZ2IsSUFBNUQ7QUFDQTtBQUNEO0FBQ0Q7QUFDRCxHQXpCRDtBQTBCQTs7QUFFRDtBQUNBLFVBQVNtakIsNkJBQVQsQ0FBd0NKLFNBQXhDLEVBQW1EeDZCLE9BQW5ELEVBQTREcXpCLGVBQTVELEVBQTZFd0gsS0FBN0UsRUFBcUY7O0FBRXBGLE1BQUlDLFlBQVksRUFBaEI7QUFBQSxNQUNDQyxtQkFBcUJQLGNBQWNILFVBRHBDOztBQUdBLFdBQVNXLE9BQVQsQ0FBa0JOLFFBQWxCLEVBQTZCO0FBQzVCLE9BQUlockIsUUFBSjtBQUNBb3JCLGFBQVdKLFFBQVgsSUFBd0IsSUFBeEI7QUFDQXg5QixVQUFPeUIsSUFBUCxDQUFhNjdCLFVBQVdFLFFBQVgsS0FBeUIsRUFBdEMsRUFBMEMsVUFBVWowQixDQUFWLEVBQWF3MEIsa0JBQWIsRUFBa0M7QUFDM0UsUUFBSUMsc0JBQXNCRCxtQkFBb0JqN0IsT0FBcEIsRUFBNkJxekIsZUFBN0IsRUFBOEN3SCxLQUE5QyxDQUExQjtBQUNBLFFBQUssT0FBT0ssbUJBQVAsS0FBK0IsUUFBL0IsSUFBMkMsQ0FBQ0gsZ0JBQTVDLElBQWdFLENBQUNELFVBQVdJLG1CQUFYLENBQXRFLEVBQXlHO0FBQ3hHbDdCLGFBQVEyNkIsU0FBUixDQUFrQnB1QixPQUFsQixDQUEyQjJ1QixtQkFBM0I7QUFDQUYsYUFBU0UsbUJBQVQ7QUFDQSxZQUFPLEtBQVA7QUFDQSxLQUpELE1BSU8sSUFBS0gsZ0JBQUwsRUFBd0I7QUFDOUIsWUFBTyxFQUFHcnJCLFdBQVd3ckIsbUJBQWQsQ0FBUDtBQUNBO0FBQ0QsSUFURDtBQVVBLFVBQU94ckIsUUFBUDtBQUNBOztBQUVELFNBQU9zckIsUUFBU2g3QixRQUFRMjZCLFNBQVIsQ0FBbUIsQ0FBbkIsQ0FBVCxLQUFxQyxDQUFDRyxVQUFXLEdBQVgsQ0FBRCxJQUFxQkUsUUFBUyxHQUFULENBQWpFO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBU0csVUFBVCxDQUFxQmo3QixNQUFyQixFQUE2Qk4sR0FBN0IsRUFBbUM7QUFDbEMsTUFBSU8sSUFBSjtBQUFBLE1BQVVvQixHQUFWO0FBQUEsTUFDQzY1QixjQUFjbCtCLE9BQU9tK0IsWUFBUCxDQUFvQkQsV0FBcEIsSUFBbUMsRUFEbEQ7O0FBR0EsT0FBTTc1QixHQUFOLElBQWEzQixHQUFiLEVBQW1CO0FBQ2xCLE9BQUtBLElBQUsyQixHQUFMLE1BQWVoQixTQUFwQixFQUFnQztBQUMvQixLQUFFNjZCLFlBQWE3NUIsR0FBYixJQUFxQnJCLE1BQXJCLEdBQWdDQyxTQUFTQSxPQUFPLEVBQWhCLENBQWxDLEVBQTJEb0IsR0FBM0QsSUFBbUUzQixJQUFLMkIsR0FBTCxDQUFuRTtBQUNBO0FBQ0Q7QUFDRCxNQUFLcEIsSUFBTCxFQUFZO0FBQ1hqRCxVQUFPeUMsTUFBUCxDQUFlLElBQWYsRUFBcUJPLE1BQXJCLEVBQTZCQyxJQUE3QjtBQUNBOztBQUVELFNBQU9ELE1BQVA7QUFDQTs7QUFFRDs7OztBQUlBLFVBQVNvN0IsbUJBQVQsQ0FBOEJDLENBQTlCLEVBQWlDVixLQUFqQyxFQUF3Q1csU0FBeEMsRUFBb0Q7QUFDbkQsTUFBSUMsYUFBSjtBQUFBLE1BQW1CQyxFQUFuQjtBQUFBLE1BQXVCQyxhQUF2QjtBQUFBLE1BQXNDMTZCLElBQXRDO0FBQUEsTUFDQ3VULFdBQVcrbUIsRUFBRS9tQixRQURkO0FBQUEsTUFFQ21tQixZQUFZWSxFQUFFWixTQUZmOztBQUlBO0FBQ0EsU0FBUUEsVUFBVyxDQUFYLE1BQW1CLEdBQTNCLEVBQWlDO0FBQ2hDQSxhQUFVNXhCLEtBQVY7QUFDQSxPQUFLMnlCLE9BQU9uN0IsU0FBWixFQUF3QjtBQUN2Qm03QixTQUFLSCxFQUFFSyxRQUFGLElBQWNmLE1BQU1nQixpQkFBTixDQUF3QixjQUF4QixDQUFuQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFLSCxFQUFMLEVBQVU7QUFDVCxRQUFNejZCLElBQU4sSUFBY3VULFFBQWQsRUFBeUI7QUFDeEIsUUFBS0EsU0FBVXZULElBQVYsS0FBb0J1VCxTQUFVdlQsSUFBVixFQUFpQmdILElBQWpCLENBQXVCeXpCLEVBQXZCLENBQXpCLEVBQXVEO0FBQ3REZixlQUFVcHVCLE9BQVYsQ0FBbUJ0TCxJQUFuQjtBQUNBO0FBQ0E7QUFDRDtBQUNEOztBQUVEO0FBQ0EsTUFBSzA1QixVQUFXLENBQVgsS0FBa0JhLFNBQXZCLEVBQW1DO0FBQ2xDRyxtQkFBZ0JoQixVQUFXLENBQVgsQ0FBaEI7QUFDQSxHQUZELE1BRU87QUFDTjtBQUNBLFFBQU0xNUIsSUFBTixJQUFjdTZCLFNBQWQsRUFBMEI7QUFDekIsUUFBSyxDQUFDYixVQUFXLENBQVgsQ0FBRCxJQUFtQlksRUFBRU8sVUFBRixDQUFjNzZCLE9BQU8sR0FBUCxHQUFhMDVCLFVBQVUsQ0FBVixDQUEzQixDQUF4QixFQUFvRTtBQUNuRWdCLHFCQUFnQjE2QixJQUFoQjtBQUNBO0FBQ0E7QUFDRCxRQUFLLENBQUN3NkIsYUFBTixFQUFzQjtBQUNyQkEscUJBQWdCeDZCLElBQWhCO0FBQ0E7QUFDRDtBQUNEO0FBQ0EwNkIsbUJBQWdCQSxpQkFBaUJGLGFBQWpDO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBS0UsYUFBTCxFQUFxQjtBQUNwQixPQUFLQSxrQkFBa0JoQixVQUFXLENBQVgsQ0FBdkIsRUFBd0M7QUFDdkNBLGNBQVVwdUIsT0FBVixDQUFtQm92QixhQUFuQjtBQUNBO0FBQ0QsVUFBT0gsVUFBV0csYUFBWCxDQUFQO0FBQ0E7QUFDRDs7QUFFRDs7O0FBR0EsVUFBU0ksV0FBVCxDQUFzQlIsQ0FBdEIsRUFBeUJTLFFBQXpCLEVBQW1DbkIsS0FBbkMsRUFBMENvQixTQUExQyxFQUFzRDtBQUNyRCxNQUFJQyxLQUFKO0FBQUEsTUFBV0MsT0FBWDtBQUFBLE1BQW9CQyxJQUFwQjtBQUFBLE1BQTBCaDVCLEdBQTFCO0FBQUEsTUFBK0JzUixJQUEvQjtBQUFBLE1BQ0NvbkIsYUFBYSxFQURkOztBQUVDO0FBQ0FuQixjQUFZWSxFQUFFWixTQUFGLENBQVlwK0IsS0FBWixFQUhiOztBQUtBO0FBQ0EsTUFBS28rQixVQUFXLENBQVgsQ0FBTCxFQUFzQjtBQUNyQixRQUFNeUIsSUFBTixJQUFjYixFQUFFTyxVQUFoQixFQUE2QjtBQUM1QkEsZUFBWU0sS0FBS242QixXQUFMLEVBQVosSUFBbUNzNUIsRUFBRU8sVUFBRixDQUFjTSxJQUFkLENBQW5DO0FBQ0E7QUFDRDs7QUFFREQsWUFBVXhCLFVBQVU1eEIsS0FBVixFQUFWOztBQUVBO0FBQ0EsU0FBUW96QixPQUFSLEVBQWtCOztBQUVqQixPQUFLWixFQUFFYyxjQUFGLENBQWtCRixPQUFsQixDQUFMLEVBQW1DO0FBQ2xDdEIsVUFBT1UsRUFBRWMsY0FBRixDQUFrQkYsT0FBbEIsQ0FBUCxJQUF1Q0gsUUFBdkM7QUFDQTs7QUFFRDtBQUNBLE9BQUssQ0FBQ3RuQixJQUFELElBQVN1bkIsU0FBVCxJQUFzQlYsRUFBRWUsVUFBN0IsRUFBMEM7QUFDekNOLGVBQVdULEVBQUVlLFVBQUYsQ0FBY04sUUFBZCxFQUF3QlQsRUFBRWIsUUFBMUIsQ0FBWDtBQUNBOztBQUVEaG1CLFVBQU95bkIsT0FBUDtBQUNBQSxhQUFVeEIsVUFBVTV4QixLQUFWLEVBQVY7O0FBRUEsT0FBS296QixPQUFMLEVBQWU7O0FBRWQ7QUFDQSxRQUFLQSxZQUFZLEdBQWpCLEVBQXVCOztBQUV0QkEsZUFBVXpuQixJQUFWOztBQUVEO0FBQ0MsS0FMRCxNQUtPLElBQUtBLFNBQVMsR0FBVCxJQUFnQkEsU0FBU3luQixPQUE5QixFQUF3Qzs7QUFFOUM7QUFDQUMsWUFBT04sV0FBWXBuQixPQUFPLEdBQVAsR0FBYXluQixPQUF6QixLQUFzQ0wsV0FBWSxPQUFPSyxPQUFuQixDQUE3Qzs7QUFFQTtBQUNBLFNBQUssQ0FBQ0MsSUFBTixFQUFhO0FBQ1osV0FBTUYsS0FBTixJQUFlSixVQUFmLEVBQTRCOztBQUUzQjtBQUNBMTRCLGFBQU04NEIsTUFBTTM0QixLQUFOLENBQWEsR0FBYixDQUFOO0FBQ0EsV0FBS0gsSUFBSyxDQUFMLE1BQWErNEIsT0FBbEIsRUFBNEI7O0FBRTNCO0FBQ0FDLGVBQU9OLFdBQVlwbkIsT0FBTyxHQUFQLEdBQWF0UixJQUFLLENBQUwsQ0FBekIsS0FDTjA0QixXQUFZLE9BQU8xNEIsSUFBSyxDQUFMLENBQW5CLENBREQ7QUFFQSxZQUFLZzVCLElBQUwsRUFBWTtBQUNYO0FBQ0EsYUFBS0EsU0FBUyxJQUFkLEVBQXFCO0FBQ3BCQSxpQkFBT04sV0FBWUksS0FBWixDQUFQOztBQUVEO0FBQ0MsVUFKRCxNQUlPLElBQUtKLFdBQVlJLEtBQVosTUFBd0IsSUFBN0IsRUFBb0M7QUFDMUNDLG9CQUFVLzRCLElBQUssQ0FBTCxDQUFWO0FBQ0F1M0Isb0JBQVVwdUIsT0FBVixDQUFtQm5KLElBQUssQ0FBTCxDQUFuQjtBQUNBO0FBQ0Q7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLFNBQUtnNUIsU0FBUyxJQUFkLEVBQXFCOztBQUVwQjtBQUNBLFVBQUtBLFFBQVFiLEVBQUcsUUFBSCxDQUFiLEVBQTZCO0FBQzVCUyxrQkFBV0ksS0FBTUosUUFBTixDQUFYO0FBQ0EsT0FGRCxNQUVPO0FBQ04sV0FBSTtBQUNIQSxtQkFBV0ksS0FBTUosUUFBTixDQUFYO0FBQ0EsUUFGRCxDQUVFLE9BQVF2NkIsQ0FBUixFQUFZO0FBQ2IsZUFBTyxFQUFFa1csT0FBTyxhQUFULEVBQXdCOVcsT0FBT3U3QixPQUFPMzZCLENBQVAsR0FBVyx3QkFBd0JpVCxJQUF4QixHQUErQixNQUEvQixHQUF3Q3luQixPQUFsRixFQUFQO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFNBQU8sRUFBRXhrQixPQUFPLFNBQVQsRUFBb0IvVixNQUFNbzZCLFFBQTFCLEVBQVA7QUFDQTs7QUFFRDkrQixRQUFPeUMsTUFBUCxDQUFjOztBQUViO0FBQ0E0OEIsVUFBUSxDQUhLOztBQUtiO0FBQ0FDLGdCQUFjLEVBTkQ7QUFPYkMsUUFBTSxFQVBPOztBQVNicEIsZ0JBQWM7QUFDYnFCLFFBQUs5QyxZQURRO0FBRWIzNEIsU0FBTSxLQUZPO0FBR2IwN0IsWUFBUzNDLGVBQWUveEIsSUFBZixDQUFxQjB4QixhQUFjLENBQWQsQ0FBckIsQ0FISTtBQUliOTlCLFdBQVEsSUFKSztBQUtiK2dDLGdCQUFhLElBTEE7QUFNYm5ELFVBQU8sSUFOTTtBQU9ib0QsZ0JBQWEsa0RBUEE7QUFRYjs7Ozs7Ozs7Ozs7O0FBWUFDLFlBQVM7QUFDUixTQUFLeEMsUUFERztBQUVSbDRCLFVBQU0sWUFGRTtBQUdSbW5CLFVBQU0sV0FIRTtBQUlScGIsU0FBSywyQkFKRztBQUtSNHVCLFVBQU07QUFMRSxJQXBCSTs7QUE0QmJ2b0IsYUFBVTtBQUNUckcsU0FBSyxLQURJO0FBRVRvYixVQUFNLE1BRkc7QUFHVHdULFVBQU07QUFIRyxJQTVCRzs7QUFrQ2JWLG1CQUFnQjtBQUNmbHVCLFNBQUssYUFEVTtBQUVmL0wsVUFBTSxjQUZTO0FBR2YyNkIsVUFBTTtBQUhTLElBbENIOztBQXdDYjtBQUNBO0FBQ0FqQixlQUFZOztBQUVYO0FBQ0EsY0FBVWoxQixNQUhDOztBQUtYO0FBQ0EsaUJBQWEsSUFORjs7QUFRWDtBQUNBLGlCQUFhM0osT0FBT2tlLFNBVFQ7O0FBV1g7QUFDQSxnQkFBWWxlLE9BQU9tOEI7QUFaUixJQTFDQzs7QUF5RGI7QUFDQTtBQUNBO0FBQ0E7QUFDQStCLGdCQUFhO0FBQ1pzQixTQUFLLElBRE87QUFFWnQvQixhQUFTO0FBRkc7QUE3REEsR0FURDs7QUE0RWI7QUFDQTtBQUNBO0FBQ0E0L0IsYUFBVyxtQkFBVTk4QixNQUFWLEVBQWtCKzhCLFFBQWxCLEVBQTZCO0FBQ3ZDLFVBQU9BOztBQUVOO0FBQ0E5QixjQUFZQSxXQUFZajdCLE1BQVosRUFBb0JoRCxPQUFPbStCLFlBQTNCLENBQVosRUFBdUQ0QixRQUF2RCxDQUhNOztBQUtOO0FBQ0E5QixjQUFZaitCLE9BQU9tK0IsWUFBbkIsRUFBaUNuN0IsTUFBakMsQ0FORDtBQU9BLEdBdkZZOztBQXlGYmc5QixpQkFBZTNDLDRCQUE2QkgsVUFBN0IsQ0F6RkY7QUEwRmIrQyxpQkFBZTVDLDRCQUE2QkYsVUFBN0IsQ0ExRkY7O0FBNEZiO0FBQ0ErQyxRQUFNLGNBQVVWLEdBQVYsRUFBZTE4QixPQUFmLEVBQXlCOztBQUU5QjtBQUNBLE9BQUssUUFBTzA4QixHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBcEIsRUFBK0I7QUFDOUIxOEIsY0FBVTA4QixHQUFWO0FBQ0FBLFVBQU1uOEIsU0FBTjtBQUNBOztBQUVEO0FBQ0FQLGFBQVVBLFdBQVcsRUFBckI7O0FBRUEsT0FBSTtBQUNIOHZCLFFBREQ7O0FBRUM7QUFDQTl3QixJQUhEOztBQUlDO0FBQ0FxK0IsV0FMRDs7QUFNQztBQUNBQyx3QkFQRDs7QUFRQztBQUNBQyxlQVREOzs7QUFXQztBQUNBQyxjQVpEO0FBQUEsT0FjQ0MsU0FkRDs7QUFlQztBQUNBQyxrQkFoQkQ7O0FBaUJDO0FBQ0FuQyxPQUFJcitCLE9BQU84L0IsU0FBUCxDQUFrQixFQUFsQixFQUFzQmg5QixPQUF0QixDQWxCTDs7QUFtQkM7QUFDQTI5QixxQkFBa0JwQyxFQUFFbitCLE9BQUYsSUFBYW0rQixDQXBCaEM7O0FBcUJDO0FBQ0FxQyx3QkFBcUJyQyxFQUFFbitCLE9BQUYsS0FBZXVnQyxnQkFBZ0JuOEIsUUFBaEIsSUFBNEJtOEIsZ0JBQWdCNS9CLE1BQTNELElBQ3BCYixPQUFReWdDLGVBQVIsQ0FEb0IsR0FFcEJ6Z0MsT0FBT2lkLEtBeEJUOztBQXlCQztBQUNBckMsY0FBVzVhLE9BQU9zYSxRQUFQLEVBMUJaO0FBQUEsT0EyQkNxbUIsbUJBQW1CM2dDLE9BQU9vWixTQUFQLENBQWlCLGFBQWpCLENBM0JwQjs7QUE0QkM7QUFDQXduQixpQkFBYXZDLEVBQUV1QyxVQUFGLElBQWdCLEVBN0I5Qjs7QUE4QkM7QUFDQUMsb0JBQWlCLEVBL0JsQjtBQUFBLE9BZ0NDQyxzQkFBc0IsRUFoQ3ZCOztBQWlDQztBQUNBcm1CLFdBQVEsQ0FsQ1Q7O0FBbUNDO0FBQ0FzbUIsY0FBVyxVQXBDWjs7QUFxQ0M7QUFDQXBELFdBQVE7QUFDUHpnQixnQkFBWSxDQURMOztBQUdQO0FBQ0F5aEIsdUJBQW1CLDJCQUFVdDZCLEdBQVYsRUFBZ0I7QUFDbEMsU0FBSTJGLEtBQUo7QUFDQSxTQUFLeVEsVUFBVSxDQUFmLEVBQW1CO0FBQ2xCLFVBQUssQ0FBQytsQixlQUFOLEVBQXdCO0FBQ3ZCQSx5QkFBa0IsRUFBbEI7QUFDQSxjQUFTeDJCLFFBQVE2eUIsU0FBU3J5QixJQUFULENBQWU0MUIscUJBQWYsQ0FBakIsRUFBMkQ7QUFDMURJLHdCQUFpQngyQixNQUFNLENBQU4sRUFBU2pGLFdBQVQsRUFBakIsSUFBNENpRixNQUFPLENBQVAsQ0FBNUM7QUFDQTtBQUNEO0FBQ0RBLGNBQVF3MkIsZ0JBQWlCbjhCLElBQUlVLFdBQUosRUFBakIsQ0FBUjtBQUNBO0FBQ0QsWUFBT2lGLFNBQVMsSUFBVCxHQUFnQixJQUFoQixHQUF1QkEsS0FBOUI7QUFDQSxLQWhCTTs7QUFrQlA7QUFDQWczQiwyQkFBdUIsaUNBQVc7QUFDakMsWUFBT3ZtQixVQUFVLENBQVYsR0FBYzJsQixxQkFBZCxHQUFzQyxJQUE3QztBQUNBLEtBckJNOztBQXVCUDtBQUNBYSxzQkFBa0IsMEJBQVVwK0IsSUFBVixFQUFnQm1DLEtBQWhCLEVBQXdCO0FBQ3pDLFNBQUlrOEIsUUFBUXIrQixLQUFLa0MsV0FBTCxFQUFaO0FBQ0EsU0FBSyxDQUFDMFYsS0FBTixFQUFjO0FBQ2I1WCxhQUFPaStCLG9CQUFxQkksS0FBckIsSUFBK0JKLG9CQUFxQkksS0FBckIsS0FBZ0NyK0IsSUFBdEU7QUFDQWcrQixxQkFBZ0JoK0IsSUFBaEIsSUFBeUJtQyxLQUF6QjtBQUNBO0FBQ0QsWUFBTyxJQUFQO0FBQ0EsS0EvQk07O0FBaUNQO0FBQ0FtOEIsc0JBQWtCLDBCQUFVcDlCLElBQVYsRUFBaUI7QUFDbEMsU0FBSyxDQUFDMFcsS0FBTixFQUFjO0FBQ2I0akIsUUFBRUssUUFBRixHQUFhMzZCLElBQWI7QUFDQTtBQUNELFlBQU8sSUFBUDtBQUNBLEtBdkNNOztBQXlDUDtBQUNBNjhCLGdCQUFZLG9CQUFVaC9CLEdBQVYsRUFBZ0I7QUFDM0IsU0FBSXcvQixJQUFKO0FBQ0EsU0FBS3gvQixHQUFMLEVBQVc7QUFDVixVQUFLNlksUUFBUSxDQUFiLEVBQWlCO0FBQ2hCLFlBQU0ybUIsSUFBTixJQUFjeC9CLEdBQWQsRUFBb0I7QUFDbkI7QUFDQWcvQixvQkFBWVEsSUFBWixJQUFxQixDQUFFUixZQUFZUSxJQUFaLENBQUYsRUFBc0J4L0IsSUFBS3cvQixJQUFMLENBQXRCLENBQXJCO0FBQ0E7QUFDRCxPQUxELE1BS087QUFDTjtBQUNBekQsYUFBTWhqQixNQUFOLENBQWMvWSxJQUFLKzdCLE1BQU0wRCxNQUFYLENBQWQ7QUFDQTtBQUNEO0FBQ0QsWUFBTyxJQUFQO0FBQ0EsS0F4RE07O0FBMERQO0FBQ0FDLFdBQU8sZUFBVUMsVUFBVixFQUF1QjtBQUM3QixTQUFJQyxZQUFZRCxjQUFjUixRQUE5QjtBQUNBLFNBQUtSLFNBQUwsRUFBaUI7QUFDaEJBLGdCQUFVZSxLQUFWLENBQWlCRSxTQUFqQjtBQUNBO0FBQ0RsNkIsVUFBTSxDQUFOLEVBQVNrNkIsU0FBVDtBQUNBLFlBQU8sSUFBUDtBQUNBO0FBbEVNLElBdENUOztBQTJHQTtBQUNBNW1CLFlBQVNGLE9BQVQsQ0FBa0JpakIsS0FBbEIsRUFBMEJwSCxRQUExQixHQUFxQ29LLGlCQUFpQnZvQixHQUF0RDtBQUNBdWxCLFNBQU04RCxPQUFOLEdBQWdCOUQsTUFBTXIyQixJQUF0QjtBQUNBcTJCLFNBQU1oNkIsS0FBTixHQUFjZzZCLE1BQU05aUIsSUFBcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQXdqQixLQUFFbUIsR0FBRixHQUFRLENBQUUsQ0FBRUEsT0FBT25CLEVBQUVtQixHQUFULElBQWdCOUMsWUFBbEIsSUFBbUMsRUFBckMsRUFBMENqNUIsT0FBMUMsQ0FBbURrNUIsS0FBbkQsRUFBMEQsRUFBMUQsRUFBK0RsNUIsT0FBL0QsQ0FBd0V1NUIsU0FBeEUsRUFBbUZQLGFBQWMsQ0FBZCxJQUFvQixJQUF2RyxDQUFSOztBQUVBO0FBQ0E0QixLQUFFdDZCLElBQUYsR0FBU2pCLFFBQVE0K0IsTUFBUixJQUFrQjUrQixRQUFRaUIsSUFBMUIsSUFBa0NzNkIsRUFBRXFELE1BQXBDLElBQThDckQsRUFBRXQ2QixJQUF6RDs7QUFFQTtBQUNBczZCLEtBQUVaLFNBQUYsR0FBY3o5QixPQUFPSCxJQUFQLENBQWF3K0IsRUFBRWIsUUFBRixJQUFjLEdBQTNCLEVBQWlDejRCLFdBQWpDLEdBQStDaUYsS0FBL0MsQ0FBc0QrTyxTQUF0RCxLQUFxRSxDQUFFLEVBQUYsQ0FBbkY7O0FBRUE7QUFDQSxPQUFLc2xCLEVBQUVzRCxXQUFGLElBQWlCLElBQXRCLEVBQTZCO0FBQzVCL08sWUFBUXFLLEtBQUt6eUIsSUFBTCxDQUFXNnpCLEVBQUVtQixHQUFGLENBQU16NkIsV0FBTixFQUFYLENBQVI7QUFDQXM1QixNQUFFc0QsV0FBRixHQUFnQixDQUFDLEVBQUcvTyxVQUNqQkEsTUFBTyxDQUFQLE1BQWU2SixhQUFjLENBQWQsQ0FBZixJQUFvQzdKLE1BQU8sQ0FBUCxNQUFlNkosYUFBYyxDQUFkLENBQW5ELElBQ0QsQ0FBRTdKLE1BQU8sQ0FBUCxNQUFnQkEsTUFBTyxDQUFQLE1BQWUsT0FBZixHQUF5QixJQUF6QixHQUFnQyxLQUFoRCxDQUFGLE9BQ0c2SixhQUFjLENBQWQsTUFBdUJBLGFBQWMsQ0FBZCxNQUFzQixPQUF0QixHQUFnQyxJQUFoQyxHQUF1QyxLQUE5RCxDQURILENBRmtCLENBQUgsQ0FBakI7QUFLQTs7QUFFRDtBQUNBLE9BQUs0QixFQUFFMzVCLElBQUYsSUFBVTI1QixFQUFFcUIsV0FBWixJQUEyQixPQUFPckIsRUFBRTM1QixJQUFULEtBQWtCLFFBQWxELEVBQTZEO0FBQzVEMjVCLE1BQUUzNUIsSUFBRixHQUFTMUUsT0FBT3NwQixLQUFQLENBQWMrVSxFQUFFMzVCLElBQWhCLEVBQXNCMjVCLEVBQUV1RCxXQUF4QixDQUFUO0FBQ0E7O0FBRUQ7QUFDQWxFLGlDQUErQlIsVUFBL0IsRUFBMkNtQixDQUEzQyxFQUE4Q3Y3QixPQUE5QyxFQUF1RDY2QixLQUF2RDs7QUFFQTtBQUNBLE9BQUtsakIsVUFBVSxDQUFmLEVBQW1CO0FBQ2xCLFdBQU9rakIsS0FBUDtBQUNBOztBQUVEO0FBQ0EyQyxpQkFBY2pDLEVBQUUxL0IsTUFBaEI7O0FBRUE7QUFDQSxPQUFLMmhDLGVBQWV0Z0MsT0FBT3EvQixNQUFQLE9BQW9CLENBQXhDLEVBQTRDO0FBQzNDci9CLFdBQU9pZCxLQUFQLENBQWFOLE9BQWIsQ0FBcUIsV0FBckI7QUFDQTs7QUFFRDtBQUNBMGhCLEtBQUV0NkIsSUFBRixHQUFTczZCLEVBQUV0NkIsSUFBRixDQUFPcEQsV0FBUCxFQUFUOztBQUVBO0FBQ0EwOUIsS0FBRXdELFVBQUYsR0FBZSxDQUFDOUUsV0FBV2h5QixJQUFYLENBQWlCc3pCLEVBQUV0NkIsSUFBbkIsQ0FBaEI7O0FBRUE7QUFDQTtBQUNBbzhCLGNBQVc5QixFQUFFbUIsR0FBYjs7QUFFQTtBQUNBLE9BQUssQ0FBQ25CLEVBQUV3RCxVQUFSLEVBQXFCOztBQUVwQjtBQUNBLFFBQUt4RCxFQUFFMzVCLElBQVAsRUFBYztBQUNieTdCLGdCQUFhOUIsRUFBRW1CLEdBQUYsSUFBUyxDQUFFL0QsT0FBTzF3QixJQUFQLENBQWFvMUIsUUFBYixJQUEwQixHQUExQixHQUFnQyxHQUFsQyxJQUEwQzlCLEVBQUUzNUIsSUFBbEU7QUFDQTtBQUNBLFlBQU8yNUIsRUFBRTM1QixJQUFUO0FBQ0E7O0FBRUQ7QUFDQSxRQUFLMjVCLEVBQUUxeUIsS0FBRixLQUFZLEtBQWpCLEVBQXlCO0FBQ3hCMHlCLE9BQUVtQixHQUFGLEdBQVE1QyxJQUFJN3hCLElBQUosQ0FBVW8xQixRQUFWOztBQUVQO0FBQ0FBLGNBQVMxOEIsT0FBVCxDQUFrQm01QixHQUFsQixFQUF1QixTQUFTcEIsT0FBaEMsQ0FITzs7QUFLUDtBQUNBMkUsaUJBQWExRSxPQUFPMXdCLElBQVAsQ0FBYW8xQixRQUFiLElBQTBCLEdBQTFCLEdBQWdDLEdBQTdDLElBQXFELElBQXJELEdBQTREM0UsT0FON0Q7QUFPQTtBQUNEOztBQUVEO0FBQ0EsT0FBSzZDLEVBQUV5RCxVQUFQLEVBQW9CO0FBQ25CLFFBQUs5aEMsT0FBT3MvQixZQUFQLENBQXFCYSxRQUFyQixDQUFMLEVBQXVDO0FBQ3RDeEMsV0FBTXNELGdCQUFOLENBQXdCLG1CQUF4QixFQUE2Q2poQyxPQUFPcy9CLFlBQVAsQ0FBcUJhLFFBQXJCLENBQTdDO0FBQ0E7QUFDRCxRQUFLbmdDLE9BQU91L0IsSUFBUCxDQUFhWSxRQUFiLENBQUwsRUFBK0I7QUFDOUJ4QyxXQUFNc0QsZ0JBQU4sQ0FBd0IsZUFBeEIsRUFBeUNqaEMsT0FBT3UvQixJQUFQLENBQWFZLFFBQWIsQ0FBekM7QUFDQTtBQUNEOztBQUVEO0FBQ0EsT0FBSzlCLEVBQUUzNUIsSUFBRixJQUFVMjVCLEVBQUV3RCxVQUFaLElBQTBCeEQsRUFBRXNCLFdBQUYsS0FBa0IsS0FBNUMsSUFBcUQ3OEIsUUFBUTY4QixXQUFsRSxFQUFnRjtBQUMvRWhDLFVBQU1zRCxnQkFBTixDQUF3QixjQUF4QixFQUF3QzVDLEVBQUVzQixXQUExQztBQUNBOztBQUVEO0FBQ0FoQyxTQUFNc0QsZ0JBQU4sQ0FDQyxRQURELEVBRUM1QyxFQUFFWixTQUFGLENBQWEsQ0FBYixLQUFvQlksRUFBRXVCLE9BQUYsQ0FBV3ZCLEVBQUVaLFNBQUYsQ0FBWSxDQUFaLENBQVgsQ0FBcEIsR0FDQ1ksRUFBRXVCLE9BQUYsQ0FBV3ZCLEVBQUVaLFNBQUYsQ0FBWSxDQUFaLENBQVgsS0FBZ0NZLEVBQUVaLFNBQUYsQ0FBYSxDQUFiLE1BQXFCLEdBQXJCLEdBQTJCLE9BQU9MLFFBQVAsR0FBa0IsVUFBN0MsR0FBMEQsRUFBMUYsQ0FERCxHQUVDaUIsRUFBRXVCLE9BQUYsQ0FBVyxHQUFYLENBSkY7O0FBT0E7QUFDQSxRQUFNOTlCLENBQU4sSUFBV3U4QixFQUFFMEQsT0FBYixFQUF1QjtBQUN0QnBFLFVBQU1zRCxnQkFBTixDQUF3Qm4vQixDQUF4QixFQUEyQnU4QixFQUFFMEQsT0FBRixDQUFXamdDLENBQVgsQ0FBM0I7QUFDQTs7QUFFRDtBQUNBLE9BQUt1OEIsRUFBRTJELFVBQUYsS0FBa0IzRCxFQUFFMkQsVUFBRixDQUFhL2dDLElBQWIsQ0FBbUJ3L0IsZUFBbkIsRUFBb0M5QyxLQUFwQyxFQUEyQ1UsQ0FBM0MsTUFBbUQsS0FBbkQsSUFBNEQ1akIsVUFBVSxDQUF4RixDQUFMLEVBQW1HO0FBQ2xHO0FBQ0EsV0FBT2tqQixNQUFNMkQsS0FBTixFQUFQO0FBQ0E7O0FBRUQ7QUFDQVAsY0FBVyxPQUFYOztBQUVBO0FBQ0EsUUFBTWovQixDQUFOLElBQVcsRUFBRTIvQixTQUFTLENBQVgsRUFBYzk5QixPQUFPLENBQXJCLEVBQXdCNHlCLFVBQVUsQ0FBbEMsRUFBWCxFQUFtRDtBQUNsRG9ILFVBQU83N0IsQ0FBUCxFQUFZdThCLEVBQUd2OEIsQ0FBSCxDQUFaO0FBQ0E7O0FBRUQ7QUFDQXkrQixlQUFZN0MsOEJBQStCUCxVQUEvQixFQUEyQ2tCLENBQTNDLEVBQThDdjdCLE9BQTlDLEVBQXVENjZCLEtBQXZELENBQVo7O0FBRUE7QUFDQSxPQUFLLENBQUM0QyxTQUFOLEVBQWtCO0FBQ2pCajVCLFNBQU0sQ0FBQyxDQUFQLEVBQVUsY0FBVjtBQUNBLElBRkQsTUFFTztBQUNOcTJCLFVBQU16Z0IsVUFBTixHQUFtQixDQUFuQjs7QUFFQTtBQUNBLFFBQUtvakIsV0FBTCxFQUFtQjtBQUNsQkksd0JBQW1CL2pCLE9BQW5CLENBQTRCLFVBQTVCLEVBQXdDLENBQUVnaEIsS0FBRixFQUFTVSxDQUFULENBQXhDO0FBQ0E7QUFDRDtBQUNBLFFBQUtBLEVBQUU5QixLQUFGLElBQVc4QixFQUFFbEcsT0FBRixHQUFZLENBQTVCLEVBQWdDO0FBQy9Ca0ksb0JBQWUzakIsV0FBVyxZQUFXO0FBQ3BDaWhCLFlBQU0yRCxLQUFOLENBQVksU0FBWjtBQUNBLE1BRmMsRUFFWmpELEVBQUVsRyxPQUZVLENBQWY7QUFHQTs7QUFFRCxRQUFJO0FBQ0gxZCxhQUFRLENBQVI7QUFDQThsQixlQUFVMEIsSUFBVixDQUFnQnBCLGNBQWhCLEVBQWdDdjVCLElBQWhDO0FBQ0EsS0FIRCxDQUdFLE9BQVEvQyxDQUFSLEVBQVk7QUFDYjtBQUNBLFNBQUtrVyxRQUFRLENBQWIsRUFBaUI7QUFDaEJuVCxXQUFNLENBQUMsQ0FBUCxFQUFVL0MsQ0FBVjtBQUNEO0FBQ0MsTUFIRCxNQUdPO0FBQ04sWUFBTUEsQ0FBTjtBQUNBO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLFlBQVMrQyxJQUFULENBQWUrNUIsTUFBZixFQUF1QmEsZ0JBQXZCLEVBQXlDNUQsU0FBekMsRUFBb0R5RCxPQUFwRCxFQUE4RDtBQUM3RCxRQUFJaEQsU0FBSjtBQUFBLFFBQWUwQyxPQUFmO0FBQUEsUUFBd0I5OUIsS0FBeEI7QUFBQSxRQUErQm03QixRQUEvQjtBQUFBLFFBQXlDcUQsUUFBekM7QUFBQSxRQUNDWixhQUFhVyxnQkFEZDs7QUFHQTtBQUNBLFFBQUt6bkIsVUFBVSxDQUFmLEVBQW1CO0FBQ2xCO0FBQ0E7O0FBRUQ7QUFDQUEsWUFBUSxDQUFSOztBQUVBO0FBQ0EsUUFBSzRsQixZQUFMLEVBQW9CO0FBQ25Cakksa0JBQWNpSSxZQUFkO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBRSxnQkFBWWw5QixTQUFaOztBQUVBO0FBQ0ErOEIsNEJBQXdCMkIsV0FBVyxFQUFuQzs7QUFFQTtBQUNBcEUsVUFBTXpnQixVQUFOLEdBQW1CbWtCLFNBQVMsQ0FBVCxHQUFhLENBQWIsR0FBaUIsQ0FBcEM7O0FBRUE7QUFDQXRDLGdCQUFZc0MsVUFBVSxHQUFWLElBQWlCQSxTQUFTLEdBQTFCLElBQWlDQSxXQUFXLEdBQXhEOztBQUVBO0FBQ0EsUUFBSy9DLFNBQUwsRUFBaUI7QUFDaEJRLGdCQUFXVixvQkFBcUJDLENBQXJCLEVBQXdCVixLQUF4QixFQUErQlcsU0FBL0IsQ0FBWDtBQUNBOztBQUVEO0FBQ0FRLGVBQVdELFlBQWFSLENBQWIsRUFBZ0JTLFFBQWhCLEVBQTBCbkIsS0FBMUIsRUFBaUNvQixTQUFqQyxDQUFYOztBQUVBO0FBQ0EsUUFBS0EsU0FBTCxFQUFpQjs7QUFFaEI7QUFDQSxTQUFLVixFQUFFeUQsVUFBUCxFQUFvQjtBQUNuQkssaUJBQVd4RSxNQUFNZ0IsaUJBQU4sQ0FBd0IsZUFBeEIsQ0FBWDtBQUNBLFVBQUt3RCxRQUFMLEVBQWdCO0FBQ2ZuaUMsY0FBT3MvQixZQUFQLENBQXFCYSxRQUFyQixJQUFrQ2dDLFFBQWxDO0FBQ0E7QUFDREEsaUJBQVd4RSxNQUFNZ0IsaUJBQU4sQ0FBd0IsTUFBeEIsQ0FBWDtBQUNBLFVBQUt3RCxRQUFMLEVBQWdCO0FBQ2ZuaUMsY0FBT3UvQixJQUFQLENBQWFZLFFBQWIsSUFBMEJnQyxRQUExQjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFLZCxXQUFXLEdBQVgsSUFBa0JoRCxFQUFFdDZCLElBQUYsS0FBVyxNQUFsQyxFQUEyQztBQUMxQ3c5QixtQkFBYSxXQUFiOztBQUVEO0FBQ0MsTUFKRCxNQUlPLElBQUtGLFdBQVcsR0FBaEIsRUFBc0I7QUFDNUJFLG1CQUFhLGFBQWI7O0FBRUQ7QUFDQyxNQUpNLE1BSUE7QUFDTkEsbUJBQWF6QyxTQUFTcmtCLEtBQXRCO0FBQ0FnbkIsZ0JBQVUzQyxTQUFTcDZCLElBQW5CO0FBQ0FmLGNBQVFtN0IsU0FBU243QixLQUFqQjtBQUNBbzdCLGtCQUFZLENBQUNwN0IsS0FBYjtBQUNBO0FBQ0QsS0E3QkQsTUE2Qk87QUFDTjtBQUNBO0FBQ0FBLGFBQVE0OUIsVUFBUjtBQUNBLFNBQUtGLFVBQVUsQ0FBQ0UsVUFBaEIsRUFBNkI7QUFDNUJBLG1CQUFhLE9BQWI7QUFDQSxVQUFLRixTQUFTLENBQWQsRUFBa0I7QUFDakJBLGdCQUFTLENBQVQ7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTFELFVBQU0wRCxNQUFOLEdBQWVBLE1BQWY7QUFDQTFELFVBQU00RCxVQUFOLEdBQW1CLENBQUVXLG9CQUFvQlgsVUFBdEIsSUFBcUMsRUFBeEQ7O0FBRUE7QUFDQSxRQUFLeEMsU0FBTCxFQUFpQjtBQUNoQm5rQixjQUFTcUIsV0FBVCxDQUFzQndrQixlQUF0QixFQUF1QyxDQUFFZ0IsT0FBRixFQUFXRixVQUFYLEVBQXVCNUQsS0FBdkIsQ0FBdkM7QUFDQSxLQUZELE1BRU87QUFDTi9pQixjQUFTeWIsVUFBVCxDQUFxQm9LLGVBQXJCLEVBQXNDLENBQUU5QyxLQUFGLEVBQVM0RCxVQUFULEVBQXFCNTlCLEtBQXJCLENBQXRDO0FBQ0E7O0FBRUQ7QUFDQWc2QixVQUFNaUQsVUFBTixDQUFrQkEsV0FBbEI7QUFDQUEsa0JBQWF2OUIsU0FBYjs7QUFFQSxRQUFLaTlCLFdBQUwsRUFBbUI7QUFDbEJJLHdCQUFtQi9qQixPQUFuQixDQUE0Qm9pQixZQUFZLGFBQVosR0FBNEIsV0FBeEQsRUFDQyxDQUFFcEIsS0FBRixFQUFTVSxDQUFULEVBQVlVLFlBQVkwQyxPQUFaLEdBQXNCOTlCLEtBQWxDLENBREQ7QUFFQTs7QUFFRDtBQUNBZzlCLHFCQUFpQnRtQixRQUFqQixDQUEyQm9tQixlQUEzQixFQUE0QyxDQUFFOUMsS0FBRixFQUFTNEQsVUFBVCxDQUE1Qzs7QUFFQSxRQUFLakIsV0FBTCxFQUFtQjtBQUNsQkksd0JBQW1CL2pCLE9BQW5CLENBQTRCLGNBQTVCLEVBQTRDLENBQUVnaEIsS0FBRixFQUFTVSxDQUFULENBQTVDO0FBQ0E7QUFDQSxTQUFLLENBQUcsR0FBRXIrQixPQUFPcS9CLE1BQWpCLEVBQTRCO0FBQzNCci9CLGFBQU9pZCxLQUFQLENBQWFOLE9BQWIsQ0FBcUIsVUFBckI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsVUFBT2doQixLQUFQO0FBQ0EsR0FqZVk7O0FBbWVieUUsV0FBUyxpQkFBVTVDLEdBQVYsRUFBZTk2QixJQUFmLEVBQXFCaEQsUUFBckIsRUFBZ0M7QUFDeEMsVUFBTzFCLE9BQU9rQixHQUFQLENBQVlzK0IsR0FBWixFQUFpQjk2QixJQUFqQixFQUF1QmhELFFBQXZCLEVBQWlDLE1BQWpDLENBQVA7QUFDQSxHQXJlWTs7QUF1ZWIyZ0MsYUFBVyxtQkFBVTdDLEdBQVYsRUFBZTk5QixRQUFmLEVBQTBCO0FBQ3BDLFVBQU8xQixPQUFPa0IsR0FBUCxDQUFZcytCLEdBQVosRUFBaUJuOEIsU0FBakIsRUFBNEIzQixRQUE1QixFQUFzQyxRQUF0QyxDQUFQO0FBQ0E7QUF6ZVksRUFBZDs7QUE0ZUExQixRQUFPeUIsSUFBUCxDQUFhLENBQUUsS0FBRixFQUFTLE1BQVQsQ0FBYixFQUFnQyxVQUFVSyxDQUFWLEVBQWE0L0IsTUFBYixFQUFzQjtBQUNyRDFoQyxTQUFRMGhDLE1BQVIsSUFBbUIsVUFBVWxDLEdBQVYsRUFBZTk2QixJQUFmLEVBQXFCaEQsUUFBckIsRUFBK0JxQyxJQUEvQixFQUFzQztBQUN4RDtBQUNBLE9BQUsvRCxPQUFPa0QsVUFBUCxDQUFtQndCLElBQW5CLENBQUwsRUFBaUM7QUFDaENYLFdBQU9BLFFBQVFyQyxRQUFmO0FBQ0FBLGVBQVdnRCxJQUFYO0FBQ0FBLFdBQU9yQixTQUFQO0FBQ0E7O0FBRUQsVUFBT3JELE9BQU9rZ0MsSUFBUCxDQUFZO0FBQ2xCVixTQUFLQSxHQURhO0FBRWxCejdCLFVBQU0yOUIsTUFGWTtBQUdsQmxFLGNBQVV6NUIsSUFIUTtBQUlsQlcsVUFBTUEsSUFKWTtBQUtsQis4QixhQUFTLy9CO0FBTFMsSUFBWixDQUFQO0FBT0EsR0FmRDtBQWdCQSxFQWpCRDs7QUFtQkE7QUFDQTFCLFFBQU95QixJQUFQLENBQWEsQ0FBRSxXQUFGLEVBQWUsVUFBZixFQUEyQixjQUEzQixFQUEyQyxXQUEzQyxFQUF3RCxhQUF4RCxFQUF1RSxVQUF2RSxDQUFiLEVBQWtHLFVBQVVLLENBQVYsRUFBYWlDLElBQWIsRUFBb0I7QUFDckgvRCxTQUFPRyxFQUFQLENBQVc0RCxJQUFYLElBQW9CLFVBQVU1RCxFQUFWLEVBQWU7QUFDbEMsVUFBTyxLQUFLNG5CLEVBQUwsQ0FBU2hrQixJQUFULEVBQWU1RCxFQUFmLENBQVA7QUFDQSxHQUZEO0FBR0EsRUFKRDs7QUFPQUgsUUFBTzJzQixRQUFQLEdBQWtCLFVBQVU2UyxHQUFWLEVBQWdCO0FBQ2pDLFNBQU94L0IsT0FBT2tnQyxJQUFQLENBQVk7QUFDbEJWLFFBQUtBLEdBRGE7QUFFbEJ6N0IsU0FBTSxLQUZZO0FBR2xCeTVCLGFBQVUsUUFIUTtBQUlsQmpCLFVBQU8sS0FKVztBQUtsQjU5QixXQUFRLEtBTFU7QUFNbEIsYUFBVTtBQU5RLEdBQVosQ0FBUDtBQVFBLEVBVEQ7O0FBWUFxQixRQUFPRyxFQUFQLENBQVVzQyxNQUFWLENBQWlCO0FBQ2hCNi9CLFdBQVMsaUJBQVVqVyxJQUFWLEVBQWlCO0FBQ3pCLE9BQUtyc0IsT0FBT2tELFVBQVAsQ0FBbUJtcEIsSUFBbkIsQ0FBTCxFQUFpQztBQUNoQyxXQUFPLEtBQUs1cUIsSUFBTCxDQUFVLFVBQVNLLENBQVQsRUFBWTtBQUM1QjlCLFlBQU8sSUFBUCxFQUFhc2lDLE9BQWIsQ0FBc0JqVyxLQUFLcHJCLElBQUwsQ0FBVSxJQUFWLEVBQWdCYSxDQUFoQixDQUF0QjtBQUNBLEtBRk0sQ0FBUDtBQUdBOztBQUVELE9BQUssS0FBSyxDQUFMLENBQUwsRUFBZTtBQUNkO0FBQ0EsUUFBSTRwQixPQUFPMXJCLE9BQVFxc0IsSUFBUixFQUFjLEtBQUssQ0FBTCxFQUFROWhCLGFBQXRCLEVBQXNDckksRUFBdEMsQ0FBeUMsQ0FBekMsRUFBNENhLEtBQTVDLENBQWtELElBQWxELENBQVg7O0FBRUEsUUFBSyxLQUFLLENBQUwsRUFBUTJILFVBQWIsRUFBMEI7QUFDekJnaEIsVUFBS08sWUFBTCxDQUFtQixLQUFLLENBQUwsQ0FBbkI7QUFDQTs7QUFFRFAsU0FBSzlwQixHQUFMLENBQVMsWUFBVztBQUNuQixTQUFJQyxPQUFPLElBQVg7O0FBRUEsWUFBUUEsS0FBS2lNLFVBQUwsSUFBbUJqTSxLQUFLaU0sVUFBTCxDQUFnQnhKLFFBQWhCLEtBQTZCLENBQXhELEVBQTREO0FBQzNEekMsYUFBT0EsS0FBS2lNLFVBQVo7QUFDQTs7QUFFRCxZQUFPak0sSUFBUDtBQUNBLEtBUkQsRUFRR2lxQixNQVJILENBUVcsSUFSWDtBQVNBOztBQUVELFVBQU8sSUFBUDtBQUNBLEdBNUJlOztBQThCaEJ5VyxhQUFXLG1CQUFVbFcsSUFBVixFQUFpQjtBQUMzQixPQUFLcnNCLE9BQU9rRCxVQUFQLENBQW1CbXBCLElBQW5CLENBQUwsRUFBaUM7QUFDaEMsV0FBTyxLQUFLNXFCLElBQUwsQ0FBVSxVQUFTSyxDQUFULEVBQVk7QUFDNUI5QixZQUFPLElBQVAsRUFBYXVpQyxTQUFiLENBQXdCbFcsS0FBS3ByQixJQUFMLENBQVUsSUFBVixFQUFnQmEsQ0FBaEIsQ0FBeEI7QUFDQSxLQUZNLENBQVA7QUFHQTs7QUFFRCxVQUFPLEtBQUtMLElBQUwsQ0FBVSxZQUFXO0FBQzNCLFFBQUlvVixPQUFPN1csT0FBUSxJQUFSLENBQVg7QUFBQSxRQUNDc1gsV0FBV1QsS0FBS1MsUUFBTCxFQURaOztBQUdBLFFBQUtBLFNBQVN2VyxNQUFkLEVBQXVCO0FBQ3RCdVcsY0FBU2dyQixPQUFULENBQWtCalcsSUFBbEI7QUFFQSxLQUhELE1BR087QUFDTnhWLFVBQUtpVixNQUFMLENBQWFPLElBQWI7QUFDQTtBQUNELElBVk0sQ0FBUDtBQVdBLEdBaERlOztBQWtEaEJYLFFBQU0sY0FBVVcsSUFBVixFQUFpQjtBQUN0QixPQUFJbnBCLGFBQWFsRCxPQUFPa0QsVUFBUCxDQUFtQm1wQixJQUFuQixDQUFqQjs7QUFFQSxVQUFPLEtBQUs1cUIsSUFBTCxDQUFVLFVBQVNLLENBQVQsRUFBWTtBQUM1QjlCLFdBQVEsSUFBUixFQUFlc2lDLE9BQWYsQ0FBd0JwL0IsYUFBYW1wQixLQUFLcHJCLElBQUwsQ0FBVSxJQUFWLEVBQWdCYSxDQUFoQixDQUFiLEdBQWtDdXFCLElBQTFEO0FBQ0EsSUFGTSxDQUFQO0FBR0EsR0F4RGU7O0FBMERoQm1XLFVBQVEsa0JBQVc7QUFDbEIsVUFBTyxLQUFLbjFCLE1BQUwsR0FBYzVMLElBQWQsQ0FBbUIsWUFBVztBQUNwQyxRQUFLLENBQUN6QixPQUFPOEUsUUFBUCxDQUFpQixJQUFqQixFQUF1QixNQUF2QixDQUFOLEVBQXdDO0FBQ3ZDOUUsWUFBUSxJQUFSLEVBQWVzc0IsV0FBZixDQUE0QixLQUFLemlCLFVBQWpDO0FBQ0E7QUFDRCxJQUpNLEVBSUp2SCxHQUpJLEVBQVA7QUFLQTtBQWhFZSxFQUFqQjs7QUFvRUF0QyxRQUFPc1AsSUFBUCxDQUFZMkQsT0FBWixDQUFvQnVlLE1BQXBCLEdBQTZCLFVBQVUzdkIsSUFBVixFQUFpQjtBQUM3QztBQUNBO0FBQ0EsU0FBT0EsS0FBSzhiLFdBQUwsSUFBb0IsQ0FBcEIsSUFBeUI5YixLQUFLaXVCLFlBQUwsSUFBcUIsQ0FBOUMsSUFDTCxDQUFDaHdCLFFBQVE2dkIscUJBQVIsRUFBRCxJQUNBLENBQUU5dEIsS0FBSzJiLEtBQUwsSUFBYzNiLEtBQUsyYixLQUFMLENBQVc0UCxPQUExQixJQUFzQ3B0QixPQUFPK2YsR0FBUCxDQUFZbGUsSUFBWixFQUFrQixTQUFsQixDQUF2QyxNQUEwRSxNQUY1RTtBQUdBLEVBTkQ7O0FBUUE3QixRQUFPc1AsSUFBUCxDQUFZMkQsT0FBWixDQUFvQnd2QixPQUFwQixHQUE4QixVQUFVNWdDLElBQVYsRUFBaUI7QUFDOUMsU0FBTyxDQUFDN0IsT0FBT3NQLElBQVAsQ0FBWTJELE9BQVosQ0FBb0J1ZSxNQUFwQixDQUE0QjN2QixJQUE1QixDQUFSO0FBQ0EsRUFGRDs7QUFPQSxLQUFJNmdDLE1BQU0sTUFBVjtBQUFBLEtBQ0NDLFdBQVcsT0FEWjtBQUFBLEtBRUNDLFFBQVEsUUFGVDtBQUFBLEtBR0NDLGtCQUFrQix1Q0FIbkI7QUFBQSxLQUlDQyxlQUFlLG9DQUpoQjs7QUFNQSxVQUFTQyxXQUFULENBQXNCdlEsTUFBdEIsRUFBOEIxdUIsR0FBOUIsRUFBbUM4OUIsV0FBbkMsRUFBZ0R4cEIsR0FBaEQsRUFBc0Q7QUFDckQsTUFBSXZWLElBQUo7O0FBRUEsTUFBSzdDLE9BQU9vRCxPQUFQLENBQWdCVSxHQUFoQixDQUFMLEVBQTZCO0FBQzVCO0FBQ0E5RCxVQUFPeUIsSUFBUCxDQUFhcUMsR0FBYixFQUFrQixVQUFVaEMsQ0FBVixFQUFha2hDLENBQWIsRUFBaUI7QUFDbEMsUUFBS3BCLGVBQWVlLFNBQVM1M0IsSUFBVCxDQUFleW5CLE1BQWYsQ0FBcEIsRUFBOEM7QUFDN0M7QUFDQXBhLFNBQUtvYSxNQUFMLEVBQWF3USxDQUFiO0FBRUEsS0FKRCxNQUlPO0FBQ047QUFDQUQsaUJBQWF2USxTQUFTLEdBQVQsSUFBaUIsUUFBT3dRLENBQVAseUNBQU9BLENBQVAsT0FBYSxRQUFiLEdBQXdCbGhDLENBQXhCLEdBQTRCLEVBQTdDLElBQW9ELEdBQWpFLEVBQXNFa2hDLENBQXRFLEVBQXlFcEIsV0FBekUsRUFBc0Z4cEIsR0FBdEY7QUFDQTtBQUNELElBVEQ7QUFXQSxHQWJELE1BYU8sSUFBSyxDQUFDd3BCLFdBQUQsSUFBZ0I1aEMsT0FBTytELElBQVAsQ0FBYUQsR0FBYixNQUF1QixRQUE1QyxFQUF1RDtBQUM3RDtBQUNBLFFBQU1qQixJQUFOLElBQWNpQixHQUFkLEVBQW9CO0FBQ25CaS9CLGdCQUFhdlEsU0FBUyxHQUFULEdBQWUzdkIsSUFBZixHQUFzQixHQUFuQyxFQUF3Q2lCLElBQUtqQixJQUFMLENBQXhDLEVBQXFEKytCLFdBQXJELEVBQWtFeHBCLEdBQWxFO0FBQ0E7QUFFRCxHQU5NLE1BTUE7QUFDTjtBQUNBQSxPQUFLb2EsTUFBTCxFQUFhMXVCLEdBQWI7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQTlELFFBQU9zcEIsS0FBUCxHQUFlLFVBQVUxaEIsQ0FBVixFQUFhZzZCLFdBQWIsRUFBMkI7QUFDekMsTUFBSXBQLE1BQUo7QUFBQSxNQUNDNkwsSUFBSSxFQURMO0FBQUEsTUFFQ2ptQixNQUFNLFNBQU5BLEdBQU0sQ0FBVS9ULEdBQVYsRUFBZVcsS0FBZixFQUF1QjtBQUM1QjtBQUNBQSxXQUFRaEYsT0FBT2tELFVBQVAsQ0FBbUI4QixLQUFuQixJQUE2QkEsT0FBN0IsR0FBeUNBLFNBQVMsSUFBVCxHQUFnQixFQUFoQixHQUFxQkEsS0FBdEU7QUFDQXE1QixLQUFHQSxFQUFFdDlCLE1BQUwsSUFBZ0JraUMsbUJBQW9CNStCLEdBQXBCLElBQTRCLEdBQTVCLEdBQWtDNCtCLG1CQUFvQmorQixLQUFwQixDQUFsRDtBQUNBLEdBTkY7O0FBUUE7QUFDQSxNQUFLNDhCLGdCQUFnQnYrQixTQUFyQixFQUFpQztBQUNoQ3UrQixpQkFBYzVoQyxPQUFPbStCLFlBQVAsSUFBdUJuK0IsT0FBT20rQixZQUFQLENBQW9CeUQsV0FBekQ7QUFDQTs7QUFFRDtBQUNBLE1BQUs1aEMsT0FBT29ELE9BQVAsQ0FBZ0J3RSxDQUFoQixLQUF5QkEsRUFBRS9HLE1BQUYsSUFBWSxDQUFDYixPQUFPbUQsYUFBUCxDQUFzQnlFLENBQXRCLENBQTNDLEVBQXlFO0FBQ3hFO0FBQ0E1SCxVQUFPeUIsSUFBUCxDQUFhbUcsQ0FBYixFQUFnQixZQUFXO0FBQzFCd1EsUUFBSyxLQUFLdlYsSUFBVixFQUFnQixLQUFLbUMsS0FBckI7QUFDQSxJQUZEO0FBSUEsR0FORCxNQU1PO0FBQ047QUFDQTtBQUNBLFFBQU13dEIsTUFBTixJQUFnQjVxQixDQUFoQixFQUFvQjtBQUNuQm03QixnQkFBYXZRLE1BQWIsRUFBcUI1cUIsRUFBRzRxQixNQUFILENBQXJCLEVBQWtDb1AsV0FBbEMsRUFBK0N4cEIsR0FBL0M7QUFDQTtBQUNEOztBQUVEO0FBQ0EsU0FBT2ltQixFQUFFaHpCLElBQUYsQ0FBUSxHQUFSLEVBQWM1SCxPQUFkLENBQXVCaS9CLEdBQXZCLEVBQTRCLEdBQTVCLENBQVA7QUFDQSxFQS9CRDs7QUFpQ0ExaUMsUUFBT0csRUFBUCxDQUFVc0MsTUFBVixDQUFpQjtBQUNoQnlnQyxhQUFXLHFCQUFXO0FBQ3JCLFVBQU9sakMsT0FBT3NwQixLQUFQLENBQWMsS0FBSzZaLGNBQUwsRUFBZCxDQUFQO0FBQ0EsR0FIZTtBQUloQkEsa0JBQWdCLDBCQUFXO0FBQzFCLFVBQU8sS0FBS3ZoQyxHQUFMLENBQVMsWUFBVztBQUMxQjtBQUNBLFFBQUkyTixXQUFXdlAsT0FBTzZrQixJQUFQLENBQWEsSUFBYixFQUFtQixVQUFuQixDQUFmO0FBQ0EsV0FBT3RWLFdBQVd2UCxPQUFPbUYsU0FBUCxDQUFrQm9LLFFBQWxCLENBQVgsR0FBMEMsSUFBakQ7QUFDQSxJQUpNLEVBS05yQixNQUxNLENBS0MsWUFBVztBQUNsQixRQUFJbkssT0FBTyxLQUFLQSxJQUFoQjtBQUNBO0FBQ0EsV0FBTyxLQUFLbEIsSUFBTCxJQUFhLENBQUM3QyxPQUFRLElBQVIsRUFBZThXLEVBQWYsQ0FBbUIsV0FBbkIsQ0FBZCxJQUNOZ3NCLGFBQWEvM0IsSUFBYixDQUFtQixLQUFLakcsUUFBeEIsQ0FETSxJQUNnQyxDQUFDKzlCLGdCQUFnQjkzQixJQUFoQixDQUFzQmhILElBQXRCLENBRGpDLEtBRUosS0FBS3dPLE9BQUwsSUFBZ0IsQ0FBQzhOLGVBQWV0VixJQUFmLENBQXFCaEgsSUFBckIsQ0FGYixDQUFQO0FBR0EsSUFYTSxFQVlObkMsR0FaTSxDQVlGLFVBQVVFLENBQVYsRUFBYUQsSUFBYixFQUFvQjtBQUN4QixRQUFJNE4sTUFBTXpQLE9BQVEsSUFBUixFQUFleVAsR0FBZixFQUFWOztBQUVBLFdBQU9BLE9BQU8sSUFBUCxHQUNOLElBRE0sR0FFTnpQLE9BQU9vRCxPQUFQLENBQWdCcU0sR0FBaEIsSUFDQ3pQLE9BQU80QixHQUFQLENBQVk2TixHQUFaLEVBQWlCLFVBQVVBLEdBQVYsRUFBZ0I7QUFDaEMsWUFBTyxFQUFFNU0sTUFBTWhCLEtBQUtnQixJQUFiLEVBQW1CbUMsT0FBT3lLLElBQUloTSxPQUFKLENBQWFtL0IsS0FBYixFQUFvQixNQUFwQixDQUExQixFQUFQO0FBQ0EsS0FGRCxDQURELEdBSUMsRUFBRS8vQixNQUFNaEIsS0FBS2dCLElBQWIsRUFBbUJtQyxPQUFPeUssSUFBSWhNLE9BQUosQ0FBYW0vQixLQUFiLEVBQW9CLE1BQXBCLENBQTFCLEVBTkY7QUFPQSxJQXRCTSxFQXNCSjFoQyxHQXRCSSxFQUFQO0FBdUJBO0FBNUJlLEVBQWpCOztBQWdDQTtBQUNBO0FBQ0FsQixRQUFPbStCLFlBQVAsQ0FBb0JpRixHQUFwQixHQUEwQmxrQyxPQUFPbzlCLGFBQVAsS0FBeUJqNUIsU0FBekI7QUFDekI7QUFDQSxhQUFXOztBQUVWO0FBQ0EsU0FBTyxDQUFDLEtBQUtvOEIsT0FBTjs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBd0MxMEIsSUFBeEMsQ0FBOEMsS0FBS2hILElBQW5ELENBUk0sSUFVTnMvQixtQkFWTSxJQVVpQkMsaUJBVnhCO0FBV0EsRUFoQndCO0FBaUJ6QjtBQUNBRCxrQkFsQkQ7O0FBb0JBLEtBQUlFLFFBQVEsQ0FBWjtBQUFBLEtBQ0NDLGVBQWUsRUFEaEI7QUFBQSxLQUVDQyxlQUFlempDLE9BQU9tK0IsWUFBUCxDQUFvQmlGLEdBQXBCLEVBRmhCOztBQUlBO0FBQ0E7QUFDQSxLQUFLbGtDLE9BQU9vOUIsYUFBWixFQUE0QjtBQUMzQnQ4QixTQUFRZCxNQUFSLEVBQWlCNm9CLEVBQWpCLENBQXFCLFFBQXJCLEVBQStCLFlBQVc7QUFDekMsUUFBTSxJQUFJMWpCLEdBQVYsSUFBaUJtL0IsWUFBakIsRUFBZ0M7QUFDL0JBLGlCQUFjbi9CLEdBQWQsRUFBcUJoQixTQUFyQixFQUFnQyxJQUFoQztBQUNBO0FBQ0QsR0FKRDtBQUtBOztBQUVEO0FBQ0F2RCxTQUFRNGpDLElBQVIsR0FBZSxDQUFDLENBQUNELFlBQUYsSUFBb0IscUJBQXFCQSxZQUF4RDtBQUNBQSxnQkFBZTNqQyxRQUFRb2dDLElBQVIsR0FBZSxDQUFDLENBQUN1RCxZQUFoQzs7QUFFQTtBQUNBLEtBQUtBLFlBQUwsRUFBb0I7O0FBRW5CempDLFNBQU9pZ0MsYUFBUCxDQUFxQixVQUFVbjlCLE9BQVYsRUFBb0I7QUFDeEM7QUFDQSxPQUFLLENBQUNBLFFBQVE2K0IsV0FBVCxJQUF3QjdoQyxRQUFRNGpDLElBQXJDLEVBQTRDOztBQUUzQyxRQUFJaGlDLFNBQUo7O0FBRUEsV0FBTztBQUNOdWdDLFdBQU0sY0FBVUYsT0FBVixFQUFtQnhMLFFBQW5CLEVBQThCO0FBQ25DLFVBQUl6MEIsQ0FBSjtBQUFBLFVBQ0NzaEMsTUFBTXRnQyxRQUFRc2dDLEdBQVIsRUFEUDtBQUFBLFVBRUN6NEIsS0FBSyxFQUFFNDRCLEtBRlI7O0FBSUE7QUFDQUgsVUFBSW5ILElBQUosQ0FBVW41QixRQUFRaUIsSUFBbEIsRUFBd0JqQixRQUFRMDhCLEdBQWhDLEVBQXFDMThCLFFBQVF5NUIsS0FBN0MsRUFBb0R6NUIsUUFBUTZnQyxRQUE1RCxFQUFzRTdnQyxRQUFRK1AsUUFBOUU7O0FBRUE7QUFDQSxVQUFLL1AsUUFBUThnQyxTQUFiLEVBQXlCO0FBQ3hCLFlBQU05aEMsQ0FBTixJQUFXZ0IsUUFBUThnQyxTQUFuQixFQUErQjtBQUM5QlIsWUFBS3RoQyxDQUFMLElBQVdnQixRQUFROGdDLFNBQVIsQ0FBbUI5aEMsQ0FBbkIsQ0FBWDtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFLZ0IsUUFBUTQ3QixRQUFSLElBQW9CMEUsSUFBSWpDLGdCQUE3QixFQUFnRDtBQUMvQ2lDLFdBQUlqQyxnQkFBSixDQUFzQnIrQixRQUFRNDdCLFFBQTlCO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUssQ0FBQzU3QixRQUFRNitCLFdBQVQsSUFBd0IsQ0FBQ0ksUUFBUSxrQkFBUixDQUE5QixFQUE0RDtBQUMzREEsZUFBUSxrQkFBUixJQUE4QixnQkFBOUI7QUFDQTs7QUFFRDtBQUNBLFdBQU1qZ0MsQ0FBTixJQUFXaWdDLE9BQVgsRUFBcUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBS0EsUUFBU2pnQyxDQUFULE1BQWlCdUIsU0FBdEIsRUFBa0M7QUFDakMrL0IsWUFBSW5DLGdCQUFKLENBQXNCbi9CLENBQXRCLEVBQXlCaWdDLFFBQVNqZ0MsQ0FBVCxJQUFlLEVBQXhDO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQXNoQyxVQUFJbkIsSUFBSixDQUFZbi9CLFFBQVErK0IsVUFBUixJQUFzQi8rQixRQUFRNEIsSUFBaEMsSUFBMEMsSUFBcEQ7O0FBRUE7QUFDQWhELGtCQUFXLGtCQUFVNkgsQ0FBVixFQUFhczZCLE9BQWIsRUFBdUI7QUFDakMsV0FBSXhDLE1BQUosRUFBWUUsVUFBWixFQUF3QmpELFNBQXhCOztBQUVBO0FBQ0EsV0FBSzU4QixjQUFjbWlDLFdBQVdULElBQUlsbUIsVUFBSixLQUFtQixDQUE1QyxDQUFMLEVBQXVEO0FBQ3REO0FBQ0EsZUFBT3NtQixhQUFjNzRCLEVBQWQsQ0FBUDtBQUNBakosb0JBQVcyQixTQUFYO0FBQ0ErL0IsWUFBSVUsa0JBQUosR0FBeUI5akMsT0FBTzZELElBQWhDOztBQUVBO0FBQ0EsWUFBS2dnQyxPQUFMLEVBQWU7QUFDZCxhQUFLVCxJQUFJbG1CLFVBQUosS0FBbUIsQ0FBeEIsRUFBNEI7QUFDM0JrbUIsY0FBSTlCLEtBQUo7QUFDQTtBQUNELFNBSkQsTUFJTztBQUNOaEQscUJBQVksRUFBWjtBQUNBK0Msa0JBQVMrQixJQUFJL0IsTUFBYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFLLE9BQU8rQixJQUFJVyxZQUFYLEtBQTRCLFFBQWpDLEVBQTRDO0FBQzNDekYsb0JBQVVwNUIsSUFBVixHQUFpQmsrQixJQUFJVyxZQUFyQjtBQUNBOztBQUVEO0FBQ0E7QUFDQSxhQUFJO0FBQ0h4Qyx1QkFBYTZCLElBQUk3QixVQUFqQjtBQUNBLFVBRkQsQ0FFRSxPQUFPaDlCLENBQVAsRUFBVztBQUNaO0FBQ0FnOUIsdUJBQWEsRUFBYjtBQUNBOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQUssQ0FBQ0YsTUFBRCxJQUFXditCLFFBQVEyOEIsT0FBbkIsSUFBOEIsQ0FBQzM4QixRQUFRNitCLFdBQTVDLEVBQTBEO0FBQ3pETixtQkFBUy9DLFVBQVVwNUIsSUFBVixHQUFpQixHQUFqQixHQUF1QixHQUFoQztBQUNEO0FBQ0MsVUFIRCxNQUdPLElBQUttOEIsV0FBVyxJQUFoQixFQUF1QjtBQUM3QkEsbUJBQVMsR0FBVDtBQUNBO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLFdBQUsvQyxTQUFMLEVBQWlCO0FBQ2hCL0gsaUJBQVU4SyxNQUFWLEVBQWtCRSxVQUFsQixFQUE4QmpELFNBQTlCLEVBQXlDOEUsSUFBSXBDLHFCQUFKLEVBQXpDO0FBQ0E7QUFDRCxPQXJERDs7QUF1REEsVUFBSyxDQUFDbCtCLFFBQVF5NUIsS0FBZCxFQUFzQjtBQUNyQjtBQUNBNzZCO0FBQ0EsT0FIRCxNQUdPLElBQUswaEMsSUFBSWxtQixVQUFKLEtBQW1CLENBQXhCLEVBQTRCO0FBQ2xDO0FBQ0E7QUFDQVIsa0JBQVloYixTQUFaO0FBQ0EsT0FKTSxNQUlBO0FBQ047QUFDQTBoQyxXQUFJVSxrQkFBSixHQUF5Qk4sYUFBYzc0QixFQUFkLElBQXFCakosU0FBOUM7QUFDQTtBQUNELE1BbkhLOztBQXFITjQvQixZQUFPLGlCQUFXO0FBQ2pCLFVBQUs1L0IsU0FBTCxFQUFnQjtBQUNmQSxpQkFBVTJCLFNBQVYsRUFBcUIsSUFBckI7QUFDQTtBQUNEO0FBekhLLEtBQVA7QUEySEE7QUFDRCxHQWxJRDtBQW1JQTs7QUFFRDtBQUNBLFVBQVNnZ0MsaUJBQVQsR0FBNkI7QUFDNUIsTUFBSTtBQUNILFVBQU8sSUFBSW5rQyxPQUFPOGtDLGNBQVgsRUFBUDtBQUNBLEdBRkQsQ0FFRSxPQUFPei9CLENBQVAsRUFBVyxDQUFFO0FBQ2Y7O0FBRUQsVUFBUysrQixlQUFULEdBQTJCO0FBQzFCLE1BQUk7QUFDSCxVQUFPLElBQUlwa0MsT0FBT285QixhQUFYLENBQTBCLG1CQUExQixDQUFQO0FBQ0EsR0FGRCxDQUVFLE9BQU8vM0IsQ0FBUCxFQUFXLENBQUU7QUFDZjs7QUFLRDtBQUNBdkUsUUFBTzgvQixTQUFQLENBQWlCO0FBQ2hCRixXQUFTO0FBQ1JxRSxXQUFRO0FBREEsR0FETztBQUloQjNzQixZQUFVO0FBQ1Qyc0IsV0FBUTtBQURDLEdBSk07QUFPaEJyRixjQUFZO0FBQ1gsa0JBQWUsb0JBQVUxNUIsSUFBVixFQUFpQjtBQUMvQmxGLFdBQU95RSxVQUFQLENBQW1CUyxJQUFuQjtBQUNBLFdBQU9BLElBQVA7QUFDQTtBQUpVO0FBUEksRUFBakI7O0FBZUE7QUFDQWxGLFFBQU9nZ0MsYUFBUCxDQUFzQixRQUF0QixFQUFnQyxVQUFVM0IsQ0FBVixFQUFjO0FBQzdDLE1BQUtBLEVBQUUxeUIsS0FBRixLQUFZdEksU0FBakIsRUFBNkI7QUFDNUJnN0IsS0FBRTF5QixLQUFGLEdBQVUsS0FBVjtBQUNBO0FBQ0QsTUFBSzB5QixFQUFFc0QsV0FBUCxFQUFxQjtBQUNwQnRELEtBQUV0NkIsSUFBRixHQUFTLEtBQVQ7QUFDQXM2QixLQUFFMS9CLE1BQUYsR0FBVyxLQUFYO0FBQ0E7QUFDRCxFQVJEOztBQVVBO0FBQ0FxQixRQUFPaWdDLGFBQVAsQ0FBc0IsUUFBdEIsRUFBZ0MsVUFBUzVCLENBQVQsRUFBWTs7QUFFM0M7QUFDQSxNQUFLQSxFQUFFc0QsV0FBUCxFQUFxQjs7QUFFcEIsT0FBSXNDLE1BQUo7QUFBQSxPQUNDQyxPQUFPbmxDLFNBQVNtbEMsSUFBVCxJQUFpQmxrQyxPQUFPLE1BQVAsRUFBZSxDQUFmLENBQWpCLElBQXNDakIsU0FBU2tPLGVBRHZEOztBQUdBLFVBQU87O0FBRU5nMUIsVUFBTSxjQUFVMTRCLENBQVYsRUFBYTdILFFBQWIsRUFBd0I7O0FBRTdCdWlDLGNBQVNsbEMsU0FBU2tOLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBVDs7QUFFQWc0QixZQUFPMUgsS0FBUCxHQUFlLElBQWY7O0FBRUEsU0FBSzhCLEVBQUU4RixhQUFQLEVBQXVCO0FBQ3RCRixhQUFPRyxPQUFQLEdBQWlCL0YsRUFBRThGLGFBQW5CO0FBQ0E7O0FBRURGLFlBQU92aEMsR0FBUCxHQUFhMjdCLEVBQUVtQixHQUFmOztBQUVBO0FBQ0F5RSxZQUFPSSxNQUFQLEdBQWdCSixPQUFPSCxrQkFBUCxHQUE0QixVQUFVdjZCLENBQVYsRUFBYXM2QixPQUFiLEVBQXVCOztBQUVsRSxVQUFLQSxXQUFXLENBQUNJLE9BQU8vbUIsVUFBbkIsSUFBaUMsa0JBQWtCblMsSUFBbEIsQ0FBd0JrNUIsT0FBTy9tQixVQUEvQixDQUF0QyxFQUFvRjs7QUFFbkY7QUFDQSttQixjQUFPSSxNQUFQLEdBQWdCSixPQUFPSCxrQkFBUCxHQUE0QixJQUE1Qzs7QUFFQTtBQUNBLFdBQUtHLE9BQU92NUIsVUFBWixFQUF5QjtBQUN4QnU1QixlQUFPdjVCLFVBQVAsQ0FBa0J3QixXQUFsQixDQUErQiszQixNQUEvQjtBQUNBOztBQUVEO0FBQ0FBLGdCQUFTLElBQVQ7O0FBRUE7QUFDQSxXQUFLLENBQUNKLE9BQU4sRUFBZ0I7QUFDZm5pQyxpQkFBVSxHQUFWLEVBQWUsU0FBZjtBQUNBO0FBQ0Q7QUFDRCxNQXBCRDs7QUFzQkE7QUFDQTtBQUNBd2lDLFVBQUtqWSxZQUFMLENBQW1CZ1ksTUFBbkIsRUFBMkJDLEtBQUtwMkIsVUFBaEM7QUFDQSxLQXhDSzs7QUEwQ053ekIsV0FBTyxpQkFBVztBQUNqQixTQUFLMkMsTUFBTCxFQUFjO0FBQ2JBLGFBQU9JLE1BQVAsQ0FBZWhoQyxTQUFmLEVBQTBCLElBQTFCO0FBQ0E7QUFDRDtBQTlDSyxJQUFQO0FBZ0RBO0FBQ0QsRUF6REQ7O0FBOERBLEtBQUlpaEMsZUFBZSxFQUFuQjtBQUFBLEtBQ0NDLFNBQVMsbUJBRFY7O0FBR0E7QUFDQXZrQyxRQUFPOC9CLFNBQVAsQ0FBaUI7QUFDaEIwRSxTQUFPLFVBRFM7QUFFaEJDLGlCQUFlLHlCQUFXO0FBQ3pCLE9BQUkvaUMsV0FBVzRpQyxhQUFhdDhCLEdBQWIsTUFBd0JoSSxPQUFPc0QsT0FBUCxHQUFpQixHQUFqQixHQUF5Qms0QixPQUFoRTtBQUNBLFFBQU05NUIsUUFBTixJQUFtQixJQUFuQjtBQUNBLFVBQU9BLFFBQVA7QUFDQTtBQU5lLEVBQWpCOztBQVNBO0FBQ0ExQixRQUFPZ2dDLGFBQVAsQ0FBc0IsWUFBdEIsRUFBb0MsVUFBVTNCLENBQVYsRUFBYXFHLGdCQUFiLEVBQStCL0csS0FBL0IsRUFBdUM7O0FBRTFFLE1BQUlnSCxZQUFKO0FBQUEsTUFBa0JDLFdBQWxCO0FBQUEsTUFBK0JDLGlCQUEvQjtBQUFBLE1BQ0NDLFdBQVd6RyxFQUFFbUcsS0FBRixLQUFZLEtBQVosS0FBdUJELE9BQU94NUIsSUFBUCxDQUFhc3pCLEVBQUVtQixHQUFmLElBQ2pDLEtBRGlDLEdBRWpDLE9BQU9uQixFQUFFMzVCLElBQVQsS0FBa0IsUUFBbEIsSUFBOEIsQ0FBQyxDQUFFMjVCLEVBQUVzQixXQUFGLElBQWlCLEVBQW5CLEVBQXdCbmdDLE9BQXhCLENBQWdDLG1DQUFoQyxDQUEvQixJQUF1RytrQyxPQUFPeDVCLElBQVAsQ0FBYXN6QixFQUFFMzVCLElBQWYsQ0FBdkcsSUFBZ0ksTUFGdEgsQ0FEWjs7QUFNQTtBQUNBLE1BQUtvZ0MsWUFBWXpHLEVBQUVaLFNBQUYsQ0FBYSxDQUFiLE1BQXFCLE9BQXRDLEVBQWdEOztBQUUvQztBQUNBa0gsa0JBQWV0RyxFQUFFb0csYUFBRixHQUFrQnprQyxPQUFPa0QsVUFBUCxDQUFtQm03QixFQUFFb0csYUFBckIsSUFDaENwRyxFQUFFb0csYUFBRixFQURnQyxHQUVoQ3BHLEVBQUVvRyxhQUZIOztBQUlBO0FBQ0EsT0FBS0ssUUFBTCxFQUFnQjtBQUNmekcsTUFBR3lHLFFBQUgsSUFBZ0J6RyxFQUFHeUcsUUFBSCxFQUFjcmhDLE9BQWQsQ0FBdUI4Z0MsTUFBdkIsRUFBK0IsT0FBT0ksWUFBdEMsQ0FBaEI7QUFDQSxJQUZELE1BRU8sSUFBS3RHLEVBQUVtRyxLQUFGLEtBQVksS0FBakIsRUFBeUI7QUFDL0JuRyxNQUFFbUIsR0FBRixJQUFTLENBQUUvRCxPQUFPMXdCLElBQVAsQ0FBYXN6QixFQUFFbUIsR0FBZixJQUF1QixHQUF2QixHQUE2QixHQUEvQixJQUF1Q25CLEVBQUVtRyxLQUF6QyxHQUFpRCxHQUFqRCxHQUF1REcsWUFBaEU7QUFDQTs7QUFFRDtBQUNBdEcsS0FBRU8sVUFBRixDQUFhLGFBQWIsSUFBOEIsWUFBVztBQUN4QyxRQUFLLENBQUNpRyxpQkFBTixFQUEwQjtBQUN6QjdrQyxZQUFPMkQsS0FBUCxDQUFjZ2hDLGVBQWUsaUJBQTdCO0FBQ0E7QUFDRCxXQUFPRSxrQkFBbUIsQ0FBbkIsQ0FBUDtBQUNBLElBTEQ7O0FBT0E7QUFDQXhHLEtBQUVaLFNBQUYsQ0FBYSxDQUFiLElBQW1CLE1BQW5COztBQUVBO0FBQ0FtSCxpQkFBYzFsQyxPQUFReWxDLFlBQVIsQ0FBZDtBQUNBemxDLFVBQVF5bEMsWUFBUixJQUF5QixZQUFXO0FBQ25DRSx3QkFBb0I3aUMsU0FBcEI7QUFDQSxJQUZEOztBQUlBO0FBQ0EyN0IsU0FBTWhqQixNQUFOLENBQWEsWUFBVztBQUN2QjtBQUNBemIsV0FBUXlsQyxZQUFSLElBQXlCQyxXQUF6Qjs7QUFFQTtBQUNBLFFBQUt2RyxFQUFHc0csWUFBSCxDQUFMLEVBQXlCO0FBQ3hCO0FBQ0F0RyxPQUFFb0csYUFBRixHQUFrQkMsaUJBQWlCRCxhQUFuQzs7QUFFQTtBQUNBSCxrQkFBYS9rQyxJQUFiLENBQW1Cb2xDLFlBQW5CO0FBQ0E7O0FBRUQ7QUFDQSxRQUFLRSxxQkFBcUI3a0MsT0FBT2tELFVBQVAsQ0FBbUIwaEMsV0FBbkIsQ0FBMUIsRUFBNkQ7QUFDNURBLGlCQUFhQyxrQkFBbUIsQ0FBbkIsQ0FBYjtBQUNBOztBQUVEQSx3QkFBb0JELGNBQWN2aEMsU0FBbEM7QUFDQSxJQW5CRDs7QUFxQkE7QUFDQSxVQUFPLFFBQVA7QUFDQTtBQUNELEVBakVEOztBQXNFQTtBQUNBO0FBQ0E7QUFDQXJELFFBQU9pWCxTQUFQLEdBQW1CLFVBQVV2UyxJQUFWLEVBQWdCeEUsT0FBaEIsRUFBeUI2a0MsV0FBekIsRUFBdUM7QUFDekQsTUFBSyxDQUFDcmdDLElBQUQsSUFBUyxPQUFPQSxJQUFQLEtBQWdCLFFBQTlCLEVBQXlDO0FBQ3hDLFVBQU8sSUFBUDtBQUNBO0FBQ0QsTUFBSyxPQUFPeEUsT0FBUCxLQUFtQixTQUF4QixFQUFvQztBQUNuQzZrQyxpQkFBYzdrQyxPQUFkO0FBQ0FBLGFBQVUsS0FBVjtBQUNBO0FBQ0RBLFlBQVVBLFdBQVduQixRQUFyQjs7QUFFQSxNQUFJaW1DLFNBQVN4dUIsV0FBV2hNLElBQVgsQ0FBaUI5RixJQUFqQixDQUFiO0FBQUEsTUFDQzhtQixVQUFVLENBQUN1WixXQUFELElBQWdCLEVBRDNCOztBQUdBO0FBQ0EsTUFBS0MsTUFBTCxFQUFjO0FBQ2IsVUFBTyxDQUFFOWtDLFFBQVErTCxhQUFSLENBQXVCKzRCLE9BQU8sQ0FBUCxDQUF2QixDQUFGLENBQVA7QUFDQTs7QUFFREEsV0FBU2hsQyxPQUFPdXJCLGFBQVAsQ0FBc0IsQ0FBRTdtQixJQUFGLENBQXRCLEVBQWdDeEUsT0FBaEMsRUFBeUNzckIsT0FBekMsQ0FBVDs7QUFFQSxNQUFLQSxXQUFXQSxRQUFRenFCLE1BQXhCLEVBQWlDO0FBQ2hDZixVQUFRd3JCLE9BQVIsRUFBa0J2UixNQUFsQjtBQUNBOztBQUVELFNBQU9qYSxPQUFPdUIsS0FBUCxDQUFjLEVBQWQsRUFBa0J5akMsT0FBT243QixVQUF6QixDQUFQO0FBQ0EsRUF6QkQ7O0FBNEJBO0FBQ0EsS0FBSW83QixRQUFRamxDLE9BQU9HLEVBQVAsQ0FBVW1tQixJQUF0Qjs7QUFFQTs7O0FBR0F0bUIsUUFBT0csRUFBUCxDQUFVbW1CLElBQVYsR0FBaUIsVUFBVWtaLEdBQVYsRUFBZTBGLE1BQWYsRUFBdUJ4akMsUUFBdkIsRUFBa0M7QUFDbEQsTUFBSyxPQUFPODlCLEdBQVAsS0FBZSxRQUFmLElBQTJCeUYsS0FBaEMsRUFBd0M7QUFDdkMsVUFBT0EsTUFBTWxqQyxLQUFOLENBQWEsSUFBYixFQUFtQkMsU0FBbkIsQ0FBUDtBQUNBOztBQUVELE1BQUkvQixRQUFKO0FBQUEsTUFBYzYrQixRQUFkO0FBQUEsTUFBd0IvNkIsSUFBeEI7QUFBQSxNQUNDOFMsT0FBTyxJQURSO0FBQUEsTUFFQytGLE1BQU00aUIsSUFBSWhnQyxPQUFKLENBQVksR0FBWixDQUZQOztBQUlBLE1BQUtvZCxPQUFPLENBQVosRUFBZ0I7QUFDZjNjLGNBQVd1L0IsSUFBSW5nQyxLQUFKLENBQVd1ZCxHQUFYLEVBQWdCNGlCLElBQUl6K0IsTUFBcEIsQ0FBWDtBQUNBeStCLFNBQU1BLElBQUluZ0MsS0FBSixDQUFXLENBQVgsRUFBY3VkLEdBQWQsQ0FBTjtBQUNBOztBQUVEO0FBQ0EsTUFBSzVjLE9BQU9rRCxVQUFQLENBQW1CZ2lDLE1BQW5CLENBQUwsRUFBbUM7O0FBRWxDO0FBQ0F4akMsY0FBV3dqQyxNQUFYO0FBQ0FBLFlBQVM3aEMsU0FBVDs7QUFFRDtBQUNDLEdBUEQsTUFPTyxJQUFLNmhDLFVBQVUsUUFBT0EsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFqQyxFQUE0QztBQUNsRG5oQyxVQUFPLE1BQVA7QUFDQTs7QUFFRDtBQUNBLE1BQUs4UyxLQUFLOVYsTUFBTCxHQUFjLENBQW5CLEVBQXVCO0FBQ3RCZixVQUFPa2dDLElBQVAsQ0FBWTtBQUNYVixTQUFLQSxHQURNOztBQUdYO0FBQ0F6N0IsVUFBTUEsSUFKSztBQUtYeTVCLGNBQVUsTUFMQztBQU1YOTRCLFVBQU13Z0M7QUFOSyxJQUFaLEVBT0c1OUIsSUFQSCxDQU9RLFVBQVV5OEIsWUFBVixFQUF5Qjs7QUFFaEM7QUFDQWpGLGVBQVc5OEIsU0FBWDs7QUFFQTZVLFNBQUt3VixJQUFMLENBQVdwc0I7O0FBRVY7QUFDQTtBQUNBRCxXQUFPLE9BQVAsRUFBZ0I4ckIsTUFBaEIsQ0FBd0I5ckIsT0FBT2lYLFNBQVAsQ0FBa0I4c0IsWUFBbEIsQ0FBeEIsRUFBMkQ5MUIsSUFBM0QsQ0FBaUVoTyxRQUFqRSxDQUpVOztBQU1WO0FBQ0E4akMsZ0JBUEQ7QUFTQSxJQXJCRCxFQXFCR3hOLFFBckJILENBcUJhNzBCLFlBQVksVUFBVWk4QixLQUFWLEVBQWlCMEQsTUFBakIsRUFBMEI7QUFDbER4cUIsU0FBS3BWLElBQUwsQ0FBV0MsUUFBWCxFQUFxQm85QixZQUFZLENBQUVuQixNQUFNb0csWUFBUixFQUFzQjFDLE1BQXRCLEVBQThCMUQsS0FBOUIsQ0FBakM7QUFDQSxJQXZCRDtBQXdCQTs7QUFFRCxTQUFPLElBQVA7QUFDQSxFQXZERDs7QUE0REEzOUIsUUFBT3NQLElBQVAsQ0FBWTJELE9BQVosQ0FBb0JreUIsUUFBcEIsR0FBK0IsVUFBVXRqQyxJQUFWLEVBQWlCO0FBQy9DLFNBQU83QixPQUFPMEYsSUFBUCxDQUFZMUYsT0FBT28zQixNQUFuQixFQUEyQixVQUFVajNCLEVBQVYsRUFBZTtBQUNoRCxVQUFPMEIsU0FBUzFCLEdBQUcwQixJQUFuQjtBQUNBLEdBRk0sRUFFSmQsTUFGSDtBQUdBLEVBSkQ7O0FBVUEsS0FBSWdHLFVBQVU3SCxPQUFPSCxRQUFQLENBQWdCa08sZUFBOUI7O0FBRUE7OztBQUdBLFVBQVNtNEIsU0FBVCxDQUFvQnZqQyxJQUFwQixFQUEyQjtBQUMxQixTQUFPN0IsT0FBT2lFLFFBQVAsQ0FBaUJwQyxJQUFqQixJQUNOQSxJQURNLEdBRU5BLEtBQUt5QyxRQUFMLEtBQWtCLENBQWxCLEdBQ0N6QyxLQUFLeUwsV0FBTCxJQUFvQnpMLEtBQUtpaUIsWUFEMUIsR0FFQyxLQUpGO0FBS0E7O0FBRUQ5akIsUUFBT3FsQyxNQUFQLEdBQWdCO0FBQ2ZDLGFBQVcsbUJBQVV6akMsSUFBVixFQUFnQmlCLE9BQWhCLEVBQXlCaEIsQ0FBekIsRUFBNkI7QUFDdkMsT0FBSXlqQyxXQUFKO0FBQUEsT0FBaUJDLE9BQWpCO0FBQUEsT0FBMEJDLFNBQTFCO0FBQUEsT0FBcUNDLE1BQXJDO0FBQUEsT0FBNkNDLFNBQTdDO0FBQUEsT0FBd0RDLFVBQXhEO0FBQUEsT0FBb0VDLGlCQUFwRTtBQUFBLE9BQ0NoVixXQUFXN3dCLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFVBQWxCLENBRFo7QUFBQSxPQUVDaWtDLFVBQVU5bEMsT0FBUTZCLElBQVIsQ0FGWDtBQUFBLE9BR0NzakIsUUFBUSxFQUhUOztBQUtBO0FBQ0EsT0FBSzBMLGFBQWEsUUFBbEIsRUFBNkI7QUFDNUJodkIsU0FBSzJiLEtBQUwsQ0FBV3FULFFBQVgsR0FBc0IsVUFBdEI7QUFDQTs7QUFFRDhVLGVBQVlHLFFBQVFULE1BQVIsRUFBWjtBQUNBSSxlQUFZemxDLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLEtBQWxCLENBQVo7QUFDQStqQyxnQkFBYTVsQyxPQUFPK2YsR0FBUCxDQUFZbGUsSUFBWixFQUFrQixNQUFsQixDQUFiO0FBQ0Fna0MsdUJBQW9CLENBQUVoVixhQUFhLFVBQWIsSUFBMkJBLGFBQWEsT0FBMUMsS0FDbkI3d0IsT0FBT3VGLE9BQVAsQ0FBZSxNQUFmLEVBQXVCLENBQUVrZ0MsU0FBRixFQUFhRyxVQUFiLENBQXZCLElBQXFELENBQUMsQ0FEdkQ7O0FBR0E7QUFDQSxPQUFLQyxpQkFBTCxFQUF5QjtBQUN4Qk4sa0JBQWNPLFFBQVFqVixRQUFSLEVBQWQ7QUFDQTZVLGFBQVNILFlBQVloNEIsR0FBckI7QUFDQWk0QixjQUFVRCxZQUFZMVcsSUFBdEI7QUFDQSxJQUpELE1BSU87QUFDTjZXLGFBQVN2aEMsV0FBWXNoQyxTQUFaLEtBQTJCLENBQXBDO0FBQ0FELGNBQVVyaEMsV0FBWXloQyxVQUFaLEtBQTRCLENBQXRDO0FBQ0E7O0FBRUQsT0FBSzVsQyxPQUFPa0QsVUFBUCxDQUFtQkosT0FBbkIsQ0FBTCxFQUFvQztBQUNuQ0EsY0FBVUEsUUFBUTdCLElBQVIsQ0FBY1ksSUFBZCxFQUFvQkMsQ0FBcEIsRUFBdUI2akMsU0FBdkIsQ0FBVjtBQUNBOztBQUVELE9BQUs3aUMsUUFBUXlLLEdBQVIsSUFBZSxJQUFwQixFQUEyQjtBQUMxQjRYLFVBQU01WCxHQUFOLEdBQWN6SyxRQUFReUssR0FBUixHQUFjbzRCLFVBQVVwNEIsR0FBMUIsR0FBa0NtNEIsTUFBOUM7QUFDQTtBQUNELE9BQUs1aUMsUUFBUStyQixJQUFSLElBQWdCLElBQXJCLEVBQTRCO0FBQzNCMUosVUFBTTBKLElBQU4sR0FBZS9yQixRQUFRK3JCLElBQVIsR0FBZThXLFVBQVU5VyxJQUEzQixHQUFvQzJXLE9BQWpEO0FBQ0E7O0FBRUQsT0FBSyxXQUFXMWlDLE9BQWhCLEVBQTBCO0FBQ3pCQSxZQUFRaWpDLEtBQVIsQ0FBYzlrQyxJQUFkLENBQW9CWSxJQUFwQixFQUEwQnNqQixLQUExQjtBQUNBLElBRkQsTUFFTztBQUNOMmdCLFlBQVEvbEIsR0FBUixDQUFhb0YsS0FBYjtBQUNBO0FBQ0Q7QUE1Q2MsRUFBaEI7O0FBK0NBbmxCLFFBQU9HLEVBQVAsQ0FBVXNDLE1BQVYsQ0FBaUI7QUFDaEI0aUMsVUFBUSxnQkFBVXZpQyxPQUFWLEVBQW9CO0FBQzNCLE9BQUtkLFVBQVVqQixNQUFmLEVBQXdCO0FBQ3ZCLFdBQU8rQixZQUFZTyxTQUFaLEdBQ04sSUFETSxHQUVOLEtBQUs1QixJQUFMLENBQVUsVUFBVUssQ0FBVixFQUFjO0FBQ3ZCOUIsWUFBT3FsQyxNQUFQLENBQWNDLFNBQWQsQ0FBeUIsSUFBekIsRUFBK0J4aUMsT0FBL0IsRUFBd0NoQixDQUF4QztBQUNBLEtBRkQsQ0FGRDtBQUtBOztBQUVELE9BQUlpRixPQUFKO0FBQUEsT0FBYWkvQixHQUFiO0FBQUEsT0FDQ0MsTUFBTSxFQUFFMTRCLEtBQUssQ0FBUCxFQUFVc2hCLE1BQU0sQ0FBaEIsRUFEUDtBQUFBLE9BRUNodEIsT0FBTyxLQUFNLENBQU4sQ0FGUjtBQUFBLE9BR0N1TCxNQUFNdkwsUUFBUUEsS0FBSzBJLGFBSHBCOztBQUtBLE9BQUssQ0FBQzZDLEdBQU4sRUFBWTtBQUNYO0FBQ0E7O0FBRURyRyxhQUFVcUcsSUFBSUgsZUFBZDs7QUFFQTtBQUNBLE9BQUssQ0FBQ2pOLE9BQU9tSCxRQUFQLENBQWlCSixPQUFqQixFQUEwQmxGLElBQTFCLENBQU4sRUFBeUM7QUFDeEMsV0FBT29rQyxHQUFQO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBLE9BQUssUUFBT3BrQyxLQUFLcWtDLHFCQUFaLE1BQXNDcCtCLFlBQTNDLEVBQTBEO0FBQ3pEbStCLFVBQU1wa0MsS0FBS3FrQyxxQkFBTCxFQUFOO0FBQ0E7QUFDREYsU0FBTVosVUFBV2g0QixHQUFYLENBQU47QUFDQSxVQUFPO0FBQ05HLFNBQUswNEIsSUFBSTE0QixHQUFKLElBQWF5NEIsSUFBSUcsV0FBSixJQUFtQnAvQixRQUFRbWYsU0FBeEMsS0FBeURuZixRQUFRb2YsU0FBUixJQUFzQixDQUEvRSxDQURDO0FBRU4wSSxVQUFNb1gsSUFBSXBYLElBQUosSUFBYW1YLElBQUlJLFdBQUosSUFBbUJyL0IsUUFBUStlLFVBQXhDLEtBQXlEL2UsUUFBUWdmLFVBQVIsSUFBc0IsQ0FBL0U7QUFGQSxJQUFQO0FBSUEsR0FwQ2U7O0FBc0NoQjhLLFlBQVUsb0JBQVc7QUFDcEIsT0FBSyxDQUFDLEtBQU0sQ0FBTixDQUFOLEVBQWtCO0FBQ2pCO0FBQ0E7O0FBRUQsT0FBSXdWLFlBQUo7QUFBQSxPQUFrQmhCLE1BQWxCO0FBQUEsT0FDQ2lCLGVBQWUsRUFBRS80QixLQUFLLENBQVAsRUFBVXNoQixNQUFNLENBQWhCLEVBRGhCO0FBQUEsT0FFQ2h0QixPQUFPLEtBQU0sQ0FBTixDQUZSOztBQUlBO0FBQ0EsT0FBSzdCLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFVBQWxCLE1BQW1DLE9BQXhDLEVBQWtEO0FBQ2pEO0FBQ0F3akMsYUFBU3hqQyxLQUFLcWtDLHFCQUFMLEVBQVQ7QUFDQSxJQUhELE1BR087QUFDTjtBQUNBRyxtQkFBZSxLQUFLQSxZQUFMLEVBQWY7O0FBRUE7QUFDQWhCLGFBQVMsS0FBS0EsTUFBTCxFQUFUO0FBQ0EsUUFBSyxDQUFDcmxDLE9BQU84RSxRQUFQLENBQWlCdWhDLGFBQWMsQ0FBZCxDQUFqQixFQUFvQyxNQUFwQyxDQUFOLEVBQXFEO0FBQ3BEQyxvQkFBZUQsYUFBYWhCLE1BQWIsRUFBZjtBQUNBOztBQUVEO0FBQ0FpQixpQkFBYS80QixHQUFiLElBQXFCdk4sT0FBTytmLEdBQVAsQ0FBWXNtQixhQUFjLENBQWQsQ0FBWixFQUErQixnQkFBL0IsRUFBaUQsSUFBakQsQ0FBckI7QUFDQUMsaUJBQWF6WCxJQUFiLElBQXFCN3VCLE9BQU8rZixHQUFQLENBQVlzbUIsYUFBYyxDQUFkLENBQVosRUFBK0IsaUJBQS9CLEVBQWtELElBQWxELENBQXJCO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBTztBQUNOOTRCLFNBQU04M0IsT0FBTzkzQixHQUFQLEdBQWMrNEIsYUFBYS80QixHQUEzQixHQUFpQ3ZOLE9BQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCLFdBQWxCLEVBQStCLElBQS9CLENBRGpDO0FBRU5ndEIsVUFBTXdXLE9BQU94VyxJQUFQLEdBQWN5WCxhQUFhelgsSUFBM0IsR0FBa0M3dUIsT0FBTytmLEdBQVAsQ0FBWWxlLElBQVosRUFBa0IsWUFBbEIsRUFBZ0MsSUFBaEM7QUFGbEMsSUFBUDtBQUlBLEdBekVlOztBQTJFaEJ3a0MsZ0JBQWMsd0JBQVc7QUFDeEIsVUFBTyxLQUFLemtDLEdBQUwsQ0FBUyxZQUFXO0FBQzFCLFFBQUl5a0MsZUFBZSxLQUFLQSxZQUFMLElBQXFCdC9CLE9BQXhDOztBQUVBLFdBQVFzL0IsZ0JBQWtCLENBQUNybUMsT0FBTzhFLFFBQVAsQ0FBaUJ1aEMsWUFBakIsRUFBK0IsTUFBL0IsQ0FBRCxJQUE0Q3JtQyxPQUFPK2YsR0FBUCxDQUFZc21CLFlBQVosRUFBMEIsVUFBMUIsTUFBMkMsUUFBakgsRUFBOEg7QUFDN0hBLG9CQUFlQSxhQUFhQSxZQUE1QjtBQUNBO0FBQ0QsV0FBT0EsZ0JBQWdCdC9CLE9BQXZCO0FBQ0EsSUFQTSxDQUFQO0FBUUE7QUFwRmUsRUFBakI7O0FBdUZBO0FBQ0EvRyxRQUFPeUIsSUFBUCxDQUFhLEVBQUVxa0IsWUFBWSxhQUFkLEVBQTZCSSxXQUFXLGFBQXhDLEVBQWIsRUFBc0UsVUFBVXdiLE1BQVYsRUFBa0I3YyxJQUFsQixFQUF5QjtBQUM5RixNQUFJdFgsTUFBTSxJQUFJeEMsSUFBSixDQUFVOFosSUFBVixDQUFWOztBQUVBN2tCLFNBQU9HLEVBQVAsQ0FBV3VoQyxNQUFYLElBQXNCLFVBQVVqeUIsR0FBVixFQUFnQjtBQUNyQyxVQUFPdVEsT0FBUSxJQUFSLEVBQWMsVUFBVW5lLElBQVYsRUFBZ0I2L0IsTUFBaEIsRUFBd0JqeUIsR0FBeEIsRUFBOEI7QUFDbEQsUUFBSXUyQixNQUFNWixVQUFXdmpDLElBQVgsQ0FBVjs7QUFFQSxRQUFLNE4sUUFBUXBNLFNBQWIsRUFBeUI7QUFDeEIsWUFBTzJpQyxNQUFPbmhCLFFBQVFtaEIsR0FBVCxHQUFnQkEsSUFBS25oQixJQUFMLENBQWhCLEdBQ1ptaEIsSUFBSWpuQyxRQUFKLENBQWFrTyxlQUFiLENBQThCeTBCLE1BQTlCLENBRE0sR0FFTjcvQixLQUFNNi9CLE1BQU4sQ0FGRDtBQUdBOztBQUVELFFBQUtzRSxHQUFMLEVBQVc7QUFDVkEsU0FBSU8sUUFBSixDQUNDLENBQUNoNUIsR0FBRCxHQUFPa0MsR0FBUCxHQUFhelAsT0FBUWdtQyxHQUFSLEVBQWNsZ0IsVUFBZCxFQURkLEVBRUN2WSxNQUFNa0MsR0FBTixHQUFZelAsT0FBUWdtQyxHQUFSLEVBQWM5ZixTQUFkLEVBRmI7QUFLQSxLQU5ELE1BTU87QUFDTnJrQixVQUFNNi9CLE1BQU4sSUFBaUJqeUIsR0FBakI7QUFDQTtBQUNELElBbEJNLEVBa0JKaXlCLE1BbEJJLEVBa0JJanlCLEdBbEJKLEVBa0JTek4sVUFBVWpCLE1BbEJuQixFQWtCMkIsSUFsQjNCLENBQVA7QUFtQkEsR0FwQkQ7QUFxQkEsRUF4QkQ7O0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FmLFFBQU95QixJQUFQLENBQWEsQ0FBRSxLQUFGLEVBQVMsTUFBVCxDQUFiLEVBQWdDLFVBQVVLLENBQVYsRUFBYStpQixJQUFiLEVBQW9CO0FBQ25EN2tCLFNBQU9peUIsUUFBUCxDQUFpQnBOLElBQWpCLElBQTBCcUssYUFBY3B2QixRQUFRb3dCLGFBQXRCLEVBQ3pCLFVBQVVydUIsSUFBVixFQUFnQjJzQixRQUFoQixFQUEyQjtBQUMxQixPQUFLQSxRQUFMLEVBQWdCO0FBQ2ZBLGVBQVdILE9BQVF4c0IsSUFBUixFQUFjZ2pCLElBQWQsQ0FBWDtBQUNBO0FBQ0EsV0FBT3NKLFVBQVVwakIsSUFBVixDQUFnQnlqQixRQUFoQixJQUNOeHVCLE9BQVE2QixJQUFSLEVBQWVndkIsUUFBZixHQUEyQmhNLElBQTNCLElBQW9DLElBRDlCLEdBRU4ySixRQUZEO0FBR0E7QUFDRCxHQVR3QixDQUExQjtBQVdBLEVBWkQ7O0FBZUE7QUFDQXh1QixRQUFPeUIsSUFBUCxDQUFhLEVBQUUra0MsUUFBUSxRQUFWLEVBQW9CQyxPQUFPLE9BQTNCLEVBQWIsRUFBbUQsVUFBVTVqQyxJQUFWLEVBQWdCa0IsSUFBaEIsRUFBdUI7QUFDekUvRCxTQUFPeUIsSUFBUCxDQUFhLEVBQUU2d0IsU0FBUyxVQUFVenZCLElBQXJCLEVBQTJCMG5CLFNBQVN4bUIsSUFBcEMsRUFBMEMsSUFBSSxVQUFVbEIsSUFBeEQsRUFBYixFQUE2RSxVQUFVNmpDLFlBQVYsRUFBd0JDLFFBQXhCLEVBQW1DO0FBQy9HO0FBQ0EzbUMsVUFBT0csRUFBUCxDQUFXd21DLFFBQVgsSUFBd0IsVUFBVXRVLE1BQVYsRUFBa0JydEIsS0FBbEIsRUFBMEI7QUFDakQsUUFBSWliLFlBQVlqZSxVQUFVakIsTUFBVixLQUFzQjJsQyxnQkFBZ0IsT0FBT3JVLE1BQVAsS0FBa0IsU0FBeEQsQ0FBaEI7QUFBQSxRQUNDVCxRQUFROFUsaUJBQWtCclUsV0FBVyxJQUFYLElBQW1CcnRCLFVBQVUsSUFBN0IsR0FBb0MsUUFBcEMsR0FBK0MsUUFBakUsQ0FEVDs7QUFHQSxXQUFPZ2IsT0FBUSxJQUFSLEVBQWMsVUFBVW5lLElBQVYsRUFBZ0JrQyxJQUFoQixFQUFzQmlCLEtBQXRCLEVBQThCO0FBQ2xELFNBQUlvSSxHQUFKOztBQUVBLFNBQUtwTixPQUFPaUUsUUFBUCxDQUFpQnBDLElBQWpCLENBQUwsRUFBK0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBT0EsS0FBSzlDLFFBQUwsQ0FBY2tPLGVBQWQsQ0FBK0IsV0FBV3BLLElBQTFDLENBQVA7QUFDQTs7QUFFRDtBQUNBLFNBQUtoQixLQUFLeUMsUUFBTCxLQUFrQixDQUF2QixFQUEyQjtBQUMxQjhJLFlBQU12TCxLQUFLb0wsZUFBWDs7QUFFQTtBQUNBO0FBQ0EsYUFBTzFKLEtBQUtpQyxHQUFMLENBQ04zRCxLQUFLNGEsSUFBTCxDQUFXLFdBQVc1WixJQUF0QixDQURNLEVBQ3dCdUssSUFBSyxXQUFXdkssSUFBaEIsQ0FEeEIsRUFFTmhCLEtBQUs0YSxJQUFMLENBQVcsV0FBVzVaLElBQXRCLENBRk0sRUFFd0J1SyxJQUFLLFdBQVd2SyxJQUFoQixDQUZ4QixFQUdOdUssSUFBSyxXQUFXdkssSUFBaEIsQ0FITSxDQUFQO0FBS0E7O0FBRUQsWUFBT21DLFVBQVUzQixTQUFWO0FBQ047QUFDQXJELFlBQU8rZixHQUFQLENBQVlsZSxJQUFaLEVBQWtCa0MsSUFBbEIsRUFBd0I2dEIsS0FBeEIsQ0FGTTs7QUFJTjtBQUNBNXhCLFlBQU93ZCxLQUFQLENBQWMzYixJQUFkLEVBQW9Ca0MsSUFBcEIsRUFBMEJpQixLQUExQixFQUFpQzRzQixLQUFqQyxDQUxEO0FBTUEsS0E3Qk0sRUE2Qko3dEIsSUE3QkksRUE2QkVrYyxZQUFZb1MsTUFBWixHQUFxQmh2QixTQTdCdkIsRUE2QmtDNGMsU0E3QmxDLEVBNkI2QyxJQTdCN0MsQ0FBUDtBQThCQSxJQWxDRDtBQW1DQSxHQXJDRDtBQXNDQSxFQXZDRDs7QUEwQ0E7QUFDQWpnQixRQUFPRyxFQUFQLENBQVV5bUMsSUFBVixHQUFpQixZQUFXO0FBQzNCLFNBQU8sS0FBSzdsQyxNQUFaO0FBQ0EsRUFGRDs7QUFJQWYsUUFBT0csRUFBUCxDQUFVMG1DLE9BQVYsR0FBb0I3bUMsT0FBT0csRUFBUCxDQUFVa1ksT0FBOUI7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUwsRUFBa0Q7QUFDakR5dUIsRUFBQSxpQ0FBa0IsRUFBbEIsbUNBQXNCLFlBQVc7QUFDaEMsVUFBTzltQyxNQUFQO0FBQ0EsR0FGRDtBQUFBO0FBR0E7O0FBS0Q7QUFDQztBQUNBK21DLFdBQVU3bkMsT0FBT2MsTUFGbEI7OztBQUlDO0FBQ0FnbkMsTUFBSzluQyxPQUFPK25DLENBTGI7O0FBT0FqbkMsUUFBT2tuQyxVQUFQLEdBQW9CLFVBQVVqa0MsSUFBVixFQUFpQjtBQUNwQyxNQUFLL0QsT0FBTytuQyxDQUFQLEtBQWFqbkMsTUFBbEIsRUFBMkI7QUFDMUJkLFVBQU8rbkMsQ0FBUCxHQUFXRCxFQUFYO0FBQ0E7O0FBRUQsTUFBSy9qQyxRQUFRL0QsT0FBT2MsTUFBUCxLQUFrQkEsTUFBL0IsRUFBd0M7QUFDdkNkLFVBQU9jLE1BQVAsR0FBZ0IrbUMsT0FBaEI7QUFDQTs7QUFFRCxTQUFPL21DLE1BQVA7QUFDQSxFQVZEOztBQVlBO0FBQ0E7QUFDQTtBQUNBLEtBQUssUUFBT2IsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQjJJLFlBQXpCLEVBQXdDO0FBQ3ZDNUksU0FBT2MsTUFBUCxHQUFnQmQsT0FBTytuQyxDQUFQLEdBQVdqbkMsTUFBM0I7QUFDQTs7QUFLRCxRQUFPQSxNQUFQO0FBRUMsQ0FsbFVBLENBQUQsQyIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2MS4xMS4wXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMDUsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNC0wMS0yM1QyMTowMlpcbiAqL1xuXG4oZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgd2luZG93IGlzIHByZXNlbnQsXG5cdFx0Ly8gZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeVxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaW5oZXJlbnRseSBwb3NzZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGpRdWVyeS1tYWtpbmcgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0c1xuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgd2luZG93XG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm9cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBDYW4ndCBkbyB0aGlzIGJlY2F1c2Ugc2V2ZXJhbCBhcHBzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vL1xuXG52YXIgZGVsZXRlZElkcyA9IFtdO1xuXG52YXIgc2xpY2UgPSBkZWxldGVkSWRzLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gZGVsZXRlZElkcy5jb25jYXQ7XG5cbnZhciBwdXNoID0gZGVsZXRlZElkcy5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGRlbGV0ZWRJZHMuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciB0cmltID0gXCJcIi50cmltO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjEuMTEuMFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQIChoZXJlJ3MgbG9va2luZyBhdCB5b3UsIFNhZmFyaSA1LjAgYW5kIElFKVxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBhICdjbGVhbicgYXJyYXlcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9iamVjdFxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHQvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xuXHQvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjaywgYXJncyApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrLCBhcmdzICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9KSk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1tqXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcihudWxsKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBkZWxldGVkSWRzLnNvcnQsXG5cdHNwbGljZTogZGVsZXRlZElkcy5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzcmMsIGNvcHlJc0FycmF5LCBjb3B5LCBuYW1lLCBvcHRpb25zLCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0Ly8gU2VlIHRlc3QvdW5pdC9jb3JlLmpzIGZvciBkZXRhaWxzIGNvbmNlcm5pbmcgaXNGdW5jdGlvbi5cblx0Ly8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydFxuXHQvLyBhcmVuJ3Qgc3VwcG9ydGVkLiBUaGV5IHJldHVybiBmYWxzZSBvbiBJRSAoIzI5NjgpLlxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImFycmF5XCI7XG5cdH0sXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0LyoganNoaW50IGVxZXFlcTogZmFsc2UgKi9cblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0cmV0dXJuIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApID49IDA7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Ly8gTXVzdCBiZSBhbiBPYmplY3QuXG5cdFx0Ly8gQmVjYXVzZSBvZiBJRSwgd2UgYWxzbyBoYXZlIHRvIGNoZWNrIHRoZSBwcmVzZW5jZSBvZiB0aGUgY29uc3RydWN0b3IgcHJvcGVydHkuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgRE9NIG5vZGVzIGFuZCB3aW5kb3cgb2JqZWN0cyBkb24ndCBwYXNzIHRocm91Z2gsIGFzIHdlbGxcblx0XHRpZiAoICFvYmogfHwgalF1ZXJ5LnR5cGUob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRcdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKG9iaiwgXCJjb25zdHJ1Y3RvclwiKSAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHQvLyBJRTgsOSBXaWxsIHRocm93IGV4Y2VwdGlvbnMgb24gY2VydGFpbiBob3N0IG9iamVjdHMgIzk4OTdcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gSGFuZGxlIGl0ZXJhdGlvbiBvdmVyIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGJlZm9yZSBvd24gcHJvcGVydGllcy5cblx0XHRpZiAoIHN1cHBvcnQub3duTGFzdCApIHtcblx0XHRcdGZvciAoIGtleSBpbiBvYmogKSB7XG5cdFx0XHRcdHJldHVybiBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0XHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblx0XHRmb3IgKCBrZXkgaW4gb2JqICkge31cblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwob2JqKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHQvLyBXb3JrYXJvdW5kcyBiYXNlZCBvbiBmaW5kaW5ncyBieSBKaW0gRHJpc2NvbGxcblx0Ly8gaHR0cDovL3dlYmxvZ3MuamF2YS5uZXQvYmxvZy9kcmlzY29sbC9hcmNoaXZlLzIwMDkvMDkvMDgvZXZhbC1qYXZhc2NyaXB0LWdsb2JhbC1jb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdGlmICggZGF0YSAmJiBqUXVlcnkudHJpbSggZGF0YSApICkge1xuXHRcdFx0Ly8gV2UgdXNlIGV4ZWNTY3JpcHQgb24gSW50ZXJuZXQgRXhwbG9yZXJcblx0XHRcdC8vIFdlIHVzZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gc28gdGhhdCBjb250ZXh0IGlzIHdpbmRvd1xuXHRcdFx0Ly8gcmF0aGVyIHRoYW4galF1ZXJ5IGluIEZpcmVmb3hcblx0XHRcdCggd2luZG93LmV4ZWNTY3JpcHQgfHwgZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdHdpbmRvd1sgXCJldmFsXCIgXS5jYWxsKCB3aW5kb3csIGRhdGEgKTtcblx0XHRcdH0gKSggZGF0YSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggb2JqICk7XG5cblx0XHRpZiAoIGFyZ3MgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkoIG9ialsgaSBdLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBVc2UgbmF0aXZlIFN0cmluZy50cmltIGZ1bmN0aW9uIHdoZXJldmVyIHBvc3NpYmxlXG5cdHRyaW06IHRyaW0gJiYgIXRyaW0uY2FsbChcIlxcdUZFRkZcXHhBMFwiKSA/XG5cdFx0ZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdHRyaW0uY2FsbCggdGV4dCApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHVzZSBvdXIgb3duIHRyaW1taW5nIGZ1bmN0aW9uYWxpdHlcblx0XHRmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdFx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlsaWtlKCBPYmplY3QoYXJyKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHZhciBsZW47XG5cblx0XHRpZiAoIGFyciApIHtcblx0XHRcdGlmICggaW5kZXhPZiApIHtcblx0XHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRpID0gaSA/IGkgPCAwID8gTWF0aC5tYXgoIDAsIGxlbiArIGkgKSA6IGkgOiAwO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Ly8gU2tpcCBhY2Nlc3NpbmcgaW4gc3BhcnNlIGFycmF5c1xuXHRcdFx0XHRpZiAoIGkgaW4gYXJyICYmIGFyclsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHR3aGlsZSAoIGogPCBsZW4gKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGorKyBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBXb3JrYXJvdW5kIGNhc3Rpbmcgb2YgLmxlbmd0aCB0byBOYU4gb24gb3RoZXJ3aXNlIGFycmF5bGlrZSBvYmplY3RzIChlLmcuLCBOb2RlTGlzdHMpXG5cdFx0aWYgKCBsZW4gIT09IGxlbiApIHtcblx0XHRcdHdoaWxlICggc2Vjb25kW2pdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBlbGVtcyApLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgYXJncywgcHJveHksIHRtcDtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICsoIG5ldyBEYXRlKCkgKTtcblx0fSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSk7XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlsaWtlKCBvYmogKSB7XG5cdHZhciBsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjEuMTAuMTZcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNC0wMS0xM1xuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHRjb21waWxlLFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIC0obmV3IERhdGUoKSksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQsXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGlmIHdlIGNhbid0IHVzZSBhIG5hdGl2ZSBvbmVcblx0aW5kZXhPZiA9IGFyci5pbmRleE9mIHx8IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCB0aGlzW2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBXaGl0ZXNwYWNlIGNoYXJhY3RlcnMgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvI2NoYXJhY3RlcnNcblx0Y2hhcmFjdGVyRW5jb2RpbmcgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIExvb3NlbHkgbW9kZWxlZCBvbiBDU1MgaWRlbnRpZmllciBjaGFyYWN0ZXJzXG5cdC8vIEFuIHVucXVvdGVkIHZhbHVlIHNob3VsZCBiZSBhIENTUyBpZGVudGlmaWVyIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdC8vIFByb3BlciBzeW50YXg6IGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZSggXCJ3XCIsIFwidyNcIiApLFxuXG5cdC8vIEFjY2VwdGFibGUgb3BlcmF0b3JzIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIiooPzooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfChcIiArIGlkZW50aWZpZXIgKyBcIil8KXwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHQvLyBQcmVmZXIgYXJndW1lbnRzIHF1b3RlZCxcblx0Ly8gICB0aGVuIG5vdCBjb250YWluaW5nIHBzZXVkb3MvYnJhY2tldHMsXG5cdC8vICAgdGhlbiBhdHRyaWJ1dGUgc2VsZWN0b3JzL25vbi1wYXJlbnRoZXRpY2FsIGV4cHJlc3Npb25zLFxuXHQvLyAgIHRoZW4gYW55dGhpbmcgZWxzZVxuXHQvLyBUaGVzZSBwcmVmZXJlbmNlcyBhcmUgaGVyZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnNcblx0Ly8gICBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBQU0VVRE8gcHJlRmlsdGVyXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlxcXFwoKChbJ1xcXCJdKSgoPzpcXFxcXFxcXC58W15cXFxcXFxcXF0pKj8pXFxcXDN8KCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcy5yZXBsYWNlKCAzLCA4ICkgKyBcIikqKXwuKilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3KlwiICkgKyBcIilcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblx0cmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuXHQvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH07XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG1hdGNoLCBlbGVtLCBtLCBub2RlVHlwZSxcblx0XHQvLyBRU0EgdmFyc1xuXHRcdGksIGdyb3Vwcywgb2xkLCBuaWQsIG5ld0NvbnRleHQsIG5ld1NlbGVjdG9yO1xuXG5cdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHRpZiAoICFzZWxlY3RvciB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHRpZiAoIChub2RlVHlwZSA9IGNvbnRleHQubm9kZVR5cGUpICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGlmICggZG9jdW1lbnRJc0hUTUwgJiYgIXNlZWQgKSB7XG5cblx0XHQvLyBTaG9ydGN1dHNcblx0XHRpZiAoIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiI0lEXCIpXG5cdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICk7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50IChqUXVlcnkgIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSwgT3BlcmEsIGFuZCBXZWJraXQgcmV0dXJuIGl0ZW1zXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudFxuXHRcdFx0XHRcdGlmICggY29udGV4dC5vd25lckRvY3VtZW50ICYmIChlbGVtID0gY29udGV4dC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiVEFHXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIi5DTEFTU1wiKVxuXHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUVNBIHBhdGhcblx0XHRpZiAoIHN1cHBvcnQucXNhICYmICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cdFx0XHRuaWQgPSBvbGQgPSBleHBhbmRvO1xuXHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRuZXdTZWxlY3RvciA9IG5vZGVUeXBlID09PSA5ICYmIHNlbGVjdG9yO1xuXG5cdFx0XHQvLyBxU0Egd29ya3Mgc3RyYW5nZWx5IG9uIEVsZW1lbnQtcm9vdGVkIHF1ZXJpZXNcblx0XHRcdC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3Rcblx0XHRcdC8vIGFuZCB3b3JraW5nIHVwIGZyb20gdGhlcmUgKFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGUgdGVjaG5pcXVlKVxuXHRcdFx0Ly8gSUUgOCBkb2Vzbid0IHdvcmsgb24gb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cblx0XHRcdFx0aWYgKCAob2xkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkgKSB7XG5cdFx0XHRcdFx0bmlkID0gb2xkLnJlcGxhY2UoIHJlc2NhcGUsIFwiXFxcXCQmXCIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCBuaWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuaWQgPSBcIltpZD0nXCIgKyBuaWQgKyBcIiddIFwiO1xuXG5cdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWQgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dDtcblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbihcIixcIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2gocXNhRXJyb3IpIHtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoICFvbGQgKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7RnVuY3Rpb24oc3RyaW5nLCBPYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZGl2LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0KCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtXG5cdFx0XHQoIH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApO1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jLFxuXHRcdHBhcmVudCA9IGRvYy5kZWZhdWx0VmlldztcblxuXHQvLyBJZiBubyBkb2N1bWVudCBhbmQgZG9jdW1lbnRFbGVtZW50IGlzIGF2YWlsYWJsZSwgcmV0dXJuXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gU2V0IG91ciBkb2N1bWVudFxuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gU3VwcG9ydCB0ZXN0c1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jICk7XG5cblx0Ly8gU3VwcG9ydDogSUU+OFxuXHQvLyBJZiBpZnJhbWUgZG9jdW1lbnQgaXMgYXNzaWduZWQgdG8gXCJkb2N1bWVudFwiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsXG5cdC8vIElFIHdpbGwgdGhyb3cgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gYWNjZXNzaW5nIFwiZG9jdW1lbnRcIiB2YXJpYWJsZSwgc2VlIGpRdWVyeSAjMTM5MzZcblx0Ly8gSUU2LTggZG8gbm90IHN1cHBvcnQgdGhlIGRlZmF1bHRWaWV3IHByb3BlcnR5IHNvIHBhcmVudCB3aWxsIGJlIHVuZGVmaW5lZFxuXHRpZiAoIHBhcmVudCAmJiBwYXJlbnQgIT09IHBhcmVudC50b3AgKSB7XG5cdFx0Ly8gSUUxMSBkb2VzIG5vdCBoYXZlIGF0dGFjaEV2ZW50LCBzbyBhbGwgbXVzdCBzdWZmZXJcblx0XHRpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZXREb2N1bWVudCgpO1xuXHRcdFx0fSwgZmFsc2UgKTtcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNldERvY3VtZW50KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllcyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgY2FuIGJlIHRydXN0ZWRcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2MuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApICYmIGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2EnPjwvZGl2PjxkaXYgY2xhc3M9J2EgaSc+PC9kaXY+XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmk8NFxuXHRcdC8vIENhdGNoIGNsYXNzIG92ZXItY2FjaGluZ1xuXHRcdGRpdi5maXJzdENoaWxkLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdC8vIFN1cHBvcnQ6IE9wZXJhPDEwXG5cdFx0Ly8gQ2F0Y2ggZ0VCQ04gZmFpbHVyZSB0byBmaW5kIG5vbi1sZWFkaW5nIGNsYXNzZXNcblx0XHRyZXR1cm4gZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJpXCIpLmxlbmd0aCA9PT0gMjtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvYy5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gc3RydW5kZWZpbmVkICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0cmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gW21dIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBzdHJ1bmRlZmluZWQgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBzdHJ1bmRlZmluZWQgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvYy5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIjxzZWxlY3QgdD0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDEwLTEyXG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3RePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2MuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IGRvZXMgbm90IGltcGxlbWVudCBpbmNsdXNpdmUgZGVzY2VuZGVudFxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2MgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2MgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvYyA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBhICkgLSBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2M7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2goZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbZWxlbV0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNV0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICYmIG1hdGNoWzRdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF07XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBzdHJ1bmRlZmluZWQgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgZGlmZiwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBwYXJlbnRbIGV4cGFuZG8gXSB8fCAocGFyZW50WyBleHBhbmRvIF0gPSB7fSk7XG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gb3V0ZXJDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsxXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzJdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHVzZUNhY2hlICYmIChjYWNoZSA9IChlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSkgJiYgY2FjaGVbMF0gPT09IGRpcnJ1bnMgKSB7XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBjYWNoZVsxXTtcblxuXHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKSBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJiArK2RpZmYgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQobm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mLmNhbGwoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbmZ1bmN0aW9uIHRva2VuaXplKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn1cblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSBvdXRlckNhY2hlWyBkaXIgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mLmNhbGwoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0cmV0dXJuICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIEtlZXAgYGlgIGEgc3RyaW5nIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBzbyBgbWF0Y2hlZENvdW50YCB3aWxsIGJlIFwiMDBcIiBiZWxvd1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGdyb3VwIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhZ3JvdXAgKSB7XG5cdFx0XHRncm91cCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gZ3JvdXAubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIGdyb3VwW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3QoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgZ3JvdXBcblx0XHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0Ly8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcblx0XHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0Y29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZTwxNFxuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZGl2MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGRpdi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdHJldHVybiBkaXYuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcbmpRdWVyeS5leHByW1wiOlwiXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuXG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSk7XG5cblx0fVxuXG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9KTtcblxuXHR9XG5cblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHRcdH1cblxuXHRcdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBxdWFsaWZpZXIgKSA+PSAwICkgIT09IG5vdDtcblx0fSk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0pKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0bGVuID0gc2VsZi5sZW5ndGg7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59KTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxuXHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3Rvci5jaGFyQXQoMCkgPT09IFwiPFwiICYmIHNlbGVjdG9yLmNoYXJBdCggc2VsZWN0b3IubGVuZ3RoIC0gMSApID09PSBcIj5cIiAmJiBzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbMV0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WzBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWzFdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWzFdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWzJdICk7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFIGFuZCBPcGVyYSByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkICE9PSBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJvb3RqUXVlcnkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB3ZSBpbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1swXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290alF1ZXJ5ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHJvb3RqUXVlcnkucmVhZHkgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRyb290alF1ZXJ5LnJlYWR5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXHQvLyBtZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0ZGlyOiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdFx0Y3VyID0gZWxlbVsgZGlyIF07XG5cblx0XHR3aGlsZSAoIGN1ciAmJiBjdXIubm9kZVR5cGUgIT09IDkgJiYgKHVudGlsID09PSB1bmRlZmluZWQgfHwgY3VyLm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkoIGN1ciApLmlzKCB1bnRpbCApKSApIHtcblx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0fVxuXHRcdFx0Y3VyID0gY3VyW2Rpcl07XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9LFxuXG5cdHNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHRcdHZhciByID0gW107XG5cblx0XHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRcdHIucHVzaCggbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgaSxcblx0XHRcdHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bGVuID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1tpXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KGN1cikgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW5cblx0Ly8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzXG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIGluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuaW5BcnJheSggdGhpc1swXSwgalF1ZXJ5KCBlbGVtICkgKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4galF1ZXJ5LmluQXJyYXkoXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVswXSA6IGVsZW0sIHRoaXMgKTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlKFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpXG5cdFx0KTtcblx0fVxufSk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHRkbyB7XG5cdFx0Y3VyID0gY3VyWyBkaXIgXTtcblx0fSB3aGlsZSAoIGN1ciAmJiBjdXIubm9kZVR5cGUgIT09IDEgKTtcblxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCh7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSA/XG5cdFx0XHRlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBlbGVtLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQgOlxuXHRcdFx0alF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciByZXQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCByZXQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS51bmlxdWUoIHJldCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRyZXQgPSByZXQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59KTtcbnZhciBybm90d2hpdGUgPSAoL1xcUysvZyk7XG5cblxuXG4vLyBTdHJpbmcgdG8gT2JqZWN0IG9wdGlvbnMgZm9ybWF0IGNhY2hlXG52YXIgb3B0aW9uc0NhY2hlID0ge307XG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9KTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHQoIG9wdGlvbnNDYWNoZVsgb3B0aW9ucyBdIHx8IGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcblx0XHRtZW1vcnksXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblx0XHQvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcblx0XHRmaXJpbmdMZW5ndGgsXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCxcblx0XHQvLyBGaXJzdCBjYWxsYmFjayB0byBmaXJlICh1c2VkIGludGVybmFsbHkgYnkgYWRkIGFuZCBmaXJlV2l0aClcblx0XHRmaXJpbmdTdGFydCxcblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblx0XHQvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0c3RhY2sgPSAhb3B0aW9ucy5vbmNlICYmIFtdLFxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0bWVtb3J5ID0gb3B0aW9ucy5tZW1vcnkgJiYgZGF0YTtcblx0XHRcdGZpcmVkID0gdHJ1ZTtcblx0XHRcdGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcblx0XHRcdGZpcmluZ1N0YXJ0ID0gMDtcblx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0ZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgbGlzdCAmJiBmaXJpbmdJbmRleCA8IGZpcmluZ0xlbmd0aDsgZmlyaW5nSW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBkYXRhWyAwIF0sIGRhdGFbIDEgXSApID09PSBmYWxzZSAmJiBvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlOyAvLyBUbyBwcmV2ZW50IGZ1cnRoZXIgY2FsbHMgdXNpbmcgYWRkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRpZiAoIHN0YWNrICkge1xuXHRcdFx0XHRcdGlmICggc3RhY2subGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZmlyZSggc3RhY2suc2hpZnQoKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmRpc2FibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdC8vIEZpcnN0LCB3ZSBzYXZlIHRoZSBjdXJyZW50IGxlbmd0aFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdChmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJnICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSkoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdC8vIERvIHdlIG5lZWQgdG8gYWRkIHRoZSBjYWxsYmFja3MgdG8gdGhlXG5cdFx0XHRcdFx0Ly8gY3VycmVudCBmaXJpbmcgYmF0Y2g/XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHQvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkIGNhbGwgcmlnaHQgYXdheVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRcdGZpcmluZ1N0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRmaXJlKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0xlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID8galF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6ICEhKCBsaXN0ICYmIGxpc3QubGVuZ3RoICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdGZpcmluZ0xlbmd0aCA9IDA7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIEhhdmUgdGhlIGxpc3QgZG8gbm90aGluZyBhbnltb3JlXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBJcyBpdCBkaXNhYmxlZD9cblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblx0XHRcdC8vIExvY2sgdGhlIGxpc3QgaW4gaXRzIGN1cnJlbnQgc3RhdGVcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdGFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGxvY2tlZD9cblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhc3RhY2s7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoIGxpc3QgJiYgKCAhZmlyZWQgfHwgc3RhY2sgKSApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0c3RhY2sucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBhcmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVqZWN0ZWRcIiBdLFxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsxXSBdKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcywgZm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0pLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsxXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Ly8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuXHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cblx0XHRcdFx0Ly8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuXHRcdFx0XHR9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVswXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0pO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8ICggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC4gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG5cdFx0XHRkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRjb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhKC0tcmVtYWluaW5nKSApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuXHRcdC8vIGFkZCBsaXN0ZW5lcnMgdG8gRGVmZXJyZWQgc3Vib3JkaW5hdGVzOyB0cmVhdCBvdGhlcnMgYXMgcmVzb2x2ZWRcblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0LmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5mYWlsKCBkZWZlcnJlZC5yZWplY3QgKVxuXHRcdFx0XHRcdFx0LnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LS1yZW1haW5pbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBpZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXG5cdFx0aWYgKCAhcmVtYWluaW5nICkge1xuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdDtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgYm9keSBleGlzdHMsIGF0IGxlYXN0LCBpbiBjYXNlIElFIGdldHMgYSBsaXR0bGUgb3ZlcnplYWxvdXMgKHRpY2tldCAjNTQ0MykuXG5cdFx0aWYgKCAhZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdHJldHVybiBzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXIoXCJyZWFkeVwiKS5vZmYoXCJyZWFkeVwiKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vKipcbiAqIENsZWFuLXVwIG1ldGhvZCBmb3IgZG9tIHJlYWR5IGV2ZW50c1xuICovXG5mdW5jdGlvbiBkZXRhY2goKSB7XG5cdGlmICggZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXG5cdH0gZWxzZSB7XG5cdFx0ZG9jdW1lbnQuZGV0YWNoRXZlbnQoIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIGNvbXBsZXRlZCApO1xuXHRcdHdpbmRvdy5kZXRhY2hFdmVudCggXCJvbmxvYWRcIiwgY29tcGxldGVkICk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICovXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdC8vIHJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiBpcyBnb29kIGVub3VnaCBmb3IgdXMgdG8gY2FsbCB0aGUgZG9tIHJlYWR5IGluIG9sZElFXG5cdGlmICggZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciB8fCBldmVudC50eXBlID09PSBcImxvYWRcIiB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0ZGV0YWNoKCk7XG5cdFx0alF1ZXJ5LnJlYWR5KCk7XG5cdH1cbn1cblxualF1ZXJ5LnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiggb2JqICkge1xuXHRpZiAoICFyZWFkeUxpc3QgKSB7XG5cblx0XHRyZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuXHRcdC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuXHRcdC8vIHdlIG9uY2UgdHJpZWQgdG8gdXNlIHJlYWR5U3RhdGUgXCJpbnRlcmFjdGl2ZVwiIGhlcmUsIGJ1dCBpdCBjYXVzZWQgaXNzdWVzIGxpa2UgdGhlIG9uZVxuXHRcdC8vIGRpc2NvdmVyZWQgYnkgQ2hyaXNTIGhlcmU6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMjgyI2NvbW1lbnQ6MTVcblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiApIHtcblx0XHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdFx0c2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHQvLyBTdGFuZGFyZHMtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydCBET01Db250ZW50TG9hZGVkXG5cdFx0fSBlbHNlIGlmICggZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuXHRcdC8vIElmIElFIGV2ZW50IG1vZGVsIGlzIHVzZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLCBtYXliZSBsYXRlIGJ1dCBzYWZlIGFsc28gZm9yIGlmcmFtZXNcblx0XHRcdGRvY3VtZW50LmF0dGFjaEV2ZW50KCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBjb21wbGV0ZWQgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hdHRhY2hFdmVudCggXCJvbmxvYWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIElmIElFIGFuZCBub3QgYSBmcmFtZVxuXHRcdFx0Ly8gY29udGludWFsbHkgY2hlY2sgdG8gc2VlIGlmIHRoZSBkb2N1bWVudCBpcyByZWFkeVxuXHRcdFx0dmFyIHRvcCA9IGZhbHNlO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0b3AgPSB3aW5kb3cuZnJhbWVFbGVtZW50ID09IG51bGwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0fSBjYXRjaChlKSB7fVxuXG5cdFx0XHRpZiAoIHRvcCAmJiB0b3AuZG9TY3JvbGwgKSB7XG5cdFx0XHRcdChmdW5jdGlvbiBkb1Njcm9sbENoZWNrKCkge1xuXHRcdFx0XHRcdGlmICggIWpRdWVyeS5pc1JlYWR5ICkge1xuXG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHRyaWNrIGJ5IERpZWdvIFBlcmluaVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkL1xuXHRcdFx0XHRcdFx0XHR0b3AuZG9TY3JvbGwoXCJsZWZ0XCIpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzZXRUaW1lb3V0KCBkb1Njcm9sbENoZWNrLCA1MCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBkZXRhY2ggYWxsIGRvbSByZWFkeSBldmVudHNcblx0XHRcdFx0XHRcdGRldGFjaCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBhbmQgZXhlY3V0ZSBhbnkgd2FpdGluZyBmdW5jdGlvbnNcblx0XHRcdFx0XHRcdGpRdWVyeS5yZWFkeSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWR5TGlzdC5wcm9taXNlKCBvYmogKTtcbn07XG5cblxudmFyIHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQ7XG5cblxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBJdGVyYXRpb24gb3ZlciBvYmplY3QncyBpbmhlcml0ZWQgcHJvcGVydGllcyBiZWZvcmUgaXRzIG93blxudmFyIGk7XG5mb3IgKCBpIGluIGpRdWVyeSggc3VwcG9ydCApICkge1xuXHRicmVhaztcbn1cbnN1cHBvcnQub3duTGFzdCA9IGkgIT09IFwiMFwiO1xuXG4vLyBOb3RlOiBtb3N0IHN1cHBvcnQgdGVzdHMgYXJlIGRlZmluZWQgaW4gdGhlaXIgcmVzcGVjdGl2ZSBtb2R1bGVzLlxuLy8gZmFsc2UgdW50aWwgdGhlIHRlc3QgaXMgcnVuXG5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgPSBmYWxzZTtcblxualF1ZXJ5KGZ1bmN0aW9uKCkge1xuXHQvLyBXZSBuZWVkIHRvIGV4ZWN1dGUgdGhpcyBvbmUgc3VwcG9ydCB0ZXN0IEFTQVAgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3dcblx0Ly8gaWYgYm9keS5zdHlsZS56b29tIG5lZWRzIHRvIGJlIHNldC5cblxuXHR2YXIgY29udGFpbmVyLCBkaXYsXG5cdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcblxuXHRpZiAoICFib2R5ICkge1xuXHRcdC8vIFJldHVybiBmb3IgZnJhbWVzZXQgZG9jcyB0aGF0IGRvbid0IGhhdmUgYSBib2R5XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU2V0dXBcblx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0Oi05OTk5cHg7bWFyZ2luLXRvcDoxcHhcIjtcblxuXHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdGJvZHkuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRpZiAoIHR5cGVvZiBkaXYuc3R5bGUuem9vbSAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHQvLyBDaGVjayBpZiBuYXRpdmVseSBibG9jay1sZXZlbCBlbGVtZW50cyBhY3QgbGlrZSBpbmxpbmUtYmxvY2tcblx0XHQvLyBlbGVtZW50cyB3aGVuIHNldHRpbmcgdGhlaXIgZGlzcGxheSB0byAnaW5saW5lJyBhbmQgZ2l2aW5nXG5cdFx0Ly8gdGhlbSBsYXlvdXRcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7bWFyZ2luOjA7d2lkdGg6MXB4O3BhZGRpbmc6MXB4O2Rpc3BsYXk6aW5saW5lO3pvb206MVwiO1xuXG5cdFx0aWYgKCAoc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gKCBkaXYub2Zmc2V0V2lkdGggPT09IDMgKSkgKSB7XG5cdFx0XHQvLyBQcmV2ZW50IElFIDYgZnJvbSBhZmZlY3RpbmcgbGF5b3V0IGZvciBwb3NpdGlvbmVkIGVsZW1lbnRzICMxMTA0OFxuXHRcdFx0Ly8gUHJldmVudCBJRSBmcm9tIHNocmlua2luZyB0aGUgYm9keSBpbiBJRSA3IG1vZGUgIzEyODY5XG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRib2R5LnN0eWxlLnpvb20gPSAxO1xuXHRcdH1cblx0fVxuXG5cdGJvZHkucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUVcblx0Y29udGFpbmVyID0gZGl2ID0gbnVsbDtcbn0pO1xuXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRXhlY3V0ZSB0aGUgdGVzdCBvbmx5IGlmIG5vdCBhbHJlYWR5IGV4ZWN1dGVkIGluIGFub3RoZXIgbW9kdWxlLlxuXHRpZiAoc3VwcG9ydC5kZWxldGVFeHBhbmRvID09IG51bGwpIHtcblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gdHJ1ZTtcblx0XHR0cnkge1xuXHRcdFx0ZGVsZXRlIGRpdi50ZXN0O1xuXHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHRzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvLyBOdWxsIGVsZW1lbnRzIHRvIGF2b2lkIGxlYWtzIGluIElFLlxuXHRkaXYgPSBudWxsO1xufSkoKTtcblxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxuICovXG5qUXVlcnkuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9EYXRhID0galF1ZXJ5Lm5vRGF0YVsgKGVsZW0ubm9kZU5hbWUgKyBcIiBcIikudG9Mb3dlckNhc2UoKSBdLFxuXHRcdG5vZGVUeXBlID0gK2VsZW0ubm9kZVR5cGUgfHwgMTtcblxuXHQvLyBEbyBub3Qgc2V0IGRhdGEgb24gbm9uLWVsZW1lbnQgRE9NIG5vZGVzIGJlY2F1c2UgaXQgd2lsbCBub3QgYmUgY2xlYXJlZCAoIzgzMzUpLlxuXHRyZXR1cm4gbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgP1xuXHRcdGZhbHNlIDpcblxuXHRcdC8vIE5vZGVzIGFjY2VwdCBkYXRhIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkOyByZWplY3Rpb24gY2FuIGJlIGNvbmRpdGlvbmFsXG5cdFx0IW5vRGF0YSB8fCBub0RhdGEgIT09IHRydWUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc2lkXCIpID09PSBub0RhdGE7XG59O1xuXG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0dmFyIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblx0XHRcdFx0XHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdCtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDpcblx0XHRcdFx0XHRyYnJhY2UudGVzdCggZGF0YSApID8galF1ZXJ5LnBhcnNlSlNPTiggZGF0YSApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fSBjYXRjaCggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0alF1ZXJ5LmRhdGEoIGVsZW0sIGtleSwgZGF0YSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbi8vIGNoZWNrcyBhIGNhY2hlIG9iamVjdCBmb3IgZW1wdGluZXNzXG5mdW5jdGlvbiBpc0VtcHR5RGF0YU9iamVjdCggb2JqICkge1xuXHR2YXIgbmFtZTtcblx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cblx0XHQvLyBpZiB0aGUgcHVibGljIGRhdGEgb2JqZWN0IGlzIGVtcHR5LCB0aGUgcHJpdmF0ZSBpcyBzdGlsbCBlbXB0eVxuXHRcdGlmICggbmFtZSA9PT0gXCJkYXRhXCIgJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9ialtuYW1lXSApICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggbmFtZSAhPT0gXCJ0b0pTT05cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxEYXRhKCBlbGVtLCBuYW1lLCBkYXRhLCBwdnQgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHJldCwgdGhpc0NhY2hlLFxuXHRcdGludGVybmFsS2V5ID0galF1ZXJ5LmV4cGFuZG8sXG5cblx0XHQvLyBXZSBoYXZlIHRvIGhhbmRsZSBET00gbm9kZXMgYW5kIEpTIG9iamVjdHMgZGlmZmVyZW50bHkgYmVjYXVzZSBJRTYtN1xuXHRcdC8vIGNhbid0IEdDIG9iamVjdCByZWZlcmVuY2VzIHByb3Blcmx5IGFjcm9zcyB0aGUgRE9NLUpTIGJvdW5kYXJ5XG5cdFx0aXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcblxuXHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgdGhlIGdsb2JhbCBqUXVlcnkgY2FjaGU7IEpTIG9iamVjdCBkYXRhIGlzXG5cdFx0Ly8gYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIG9iamVjdCBzbyBHQyBjYW4gb2NjdXIgYXV0b21hdGljYWxseVxuXHRcdGNhY2hlID0gaXNOb2RlID8galF1ZXJ5LmNhY2hlIDogZWxlbSxcblxuXHRcdC8vIE9ubHkgZGVmaW5pbmcgYW4gSUQgZm9yIEpTIG9iamVjdHMgaWYgaXRzIGNhY2hlIGFscmVhZHkgZXhpc3RzIGFsbG93c1xuXHRcdC8vIHRoZSBjb2RlIHRvIHNob3J0Y3V0IG9uIHRoZSBzYW1lIHBhdGggYXMgYSBET00gbm9kZSB3aXRoIG5vIGNhY2hlXG5cdFx0aWQgPSBpc05vZGUgPyBlbGVtWyBpbnRlcm5hbEtleSBdIDogZWxlbVsgaW50ZXJuYWxLZXkgXSAmJiBpbnRlcm5hbEtleTtcblxuXHQvLyBBdm9pZCBkb2luZyBhbnkgbW9yZSB3b3JrIHRoYW4gd2UgbmVlZCB0byB3aGVuIHRyeWluZyB0byBnZXQgZGF0YSBvbiBhblxuXHQvLyBvYmplY3QgdGhhdCBoYXMgbm8gZGF0YSBhdCBhbGxcblx0aWYgKCAoIWlkIHx8ICFjYWNoZVtpZF0gfHwgKCFwdnQgJiYgIWNhY2hlW2lkXS5kYXRhKSkgJiYgZGF0YSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggIWlkICkge1xuXHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgYSBuZXcgdW5pcXVlIElEIGZvciBlYWNoIGVsZW1lbnQgc2luY2UgdGhlaXIgZGF0YVxuXHRcdC8vIGVuZHMgdXAgaW4gdGhlIGdsb2JhbCBjYWNoZVxuXHRcdGlmICggaXNOb2RlICkge1xuXHRcdFx0aWQgPSBlbGVtWyBpbnRlcm5hbEtleSBdID0gZGVsZXRlZElkcy5wb3AoKSB8fCBqUXVlcnkuZ3VpZCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZCA9IGludGVybmFsS2V5O1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWNhY2hlWyBpZCBdICkge1xuXHRcdC8vIEF2b2lkIGV4cG9zaW5nIGpRdWVyeSBtZXRhZGF0YSBvbiBwbGFpbiBKUyBvYmplY3RzIHdoZW4gdGhlIG9iamVjdFxuXHRcdC8vIGlzIHNlcmlhbGl6ZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnlcblx0XHRjYWNoZVsgaWQgXSA9IGlzTm9kZSA/IHt9IDogeyB0b0pTT046IGpRdWVyeS5ub29wIH07XG5cdH1cblxuXHQvLyBBbiBvYmplY3QgY2FuIGJlIHBhc3NlZCB0byBqUXVlcnkuZGF0YSBpbnN0ZWFkIG9mIGEga2V5L3ZhbHVlIHBhaXI7IHRoaXMgZ2V0c1xuXHQvLyBzaGFsbG93IGNvcGllZCBvdmVyIG9udG8gdGhlIGV4aXN0aW5nIGNhY2hlXG5cdGlmICggdHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRpZiAoIHB2dCApIHtcblx0XHRcdGNhY2hlWyBpZCBdID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FjaGVbIGlkIF0uZGF0YSA9IGpRdWVyeS5leHRlbmQoIGNhY2hlWyBpZCBdLmRhdGEsIG5hbWUgKTtcblx0XHR9XG5cdH1cblxuXHR0aGlzQ2FjaGUgPSBjYWNoZVsgaWQgXTtcblxuXHQvLyBqUXVlcnkgZGF0YSgpIGlzIHN0b3JlZCBpbiBhIHNlcGFyYXRlIG9iamVjdCBpbnNpZGUgdGhlIG9iamVjdCdzIGludGVybmFsIGRhdGFcblx0Ly8gY2FjaGUgaW4gb3JkZXIgdG8gYXZvaWQga2V5IGNvbGxpc2lvbnMgYmV0d2VlbiBpbnRlcm5hbCBkYXRhIGFuZCB1c2VyLWRlZmluZWRcblx0Ly8gZGF0YS5cblx0aWYgKCAhcHZ0ICkge1xuXHRcdGlmICggIXRoaXNDYWNoZS5kYXRhICkge1xuXHRcdFx0dGhpc0NhY2hlLmRhdGEgPSB7fTtcblx0XHR9XG5cblx0XHR0aGlzQ2FjaGUgPSB0aGlzQ2FjaGUuZGF0YTtcblx0fVxuXG5cdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF0gPSBkYXRhO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIGJvdGggY29udmVydGVkLXRvLWNhbWVsIGFuZCBub24tY29udmVydGVkIGRhdGEgcHJvcGVydHkgbmFtZXNcblx0Ly8gSWYgYSBkYXRhIHByb3BlcnR5IHdhcyBzcGVjaWZpZWRcblx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdC8vIEZpcnN0IFRyeSB0byBmaW5kIGFzLWlzIHByb3BlcnR5IGRhdGFcblx0XHRyZXQgPSB0aGlzQ2FjaGVbIG5hbWUgXTtcblxuXHRcdC8vIFRlc3QgZm9yIG51bGx8dW5kZWZpbmVkIHByb3BlcnR5IGRhdGFcblx0XHRpZiAoIHJldCA9PSBudWxsICkge1xuXG5cdFx0XHQvLyBUcnkgdG8gZmluZCB0aGUgY2FtZWxDYXNlZCBwcm9wZXJ0eVxuXHRcdFx0cmV0ID0gdGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gdGhpc0NhY2hlO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCBwdnQgKSB7XG5cdGlmICggIWpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHRoaXNDYWNoZSwgaSxcblx0XHRpc05vZGUgPSBlbGVtLm5vZGVUeXBlLFxuXG5cdFx0Ly8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG5cdFx0Y2FjaGUgPSBpc05vZGUgPyBqUXVlcnkuY2FjaGUgOiBlbGVtLFxuXHRcdGlkID0gaXNOb2RlID8gZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXSA6IGpRdWVyeS5leHBhbmRvO1xuXG5cdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgbm8gY2FjaGUgZW50cnkgZm9yIHRoaXMgb2JqZWN0LCB0aGVyZSBpcyBub1xuXHQvLyBwdXJwb3NlIGluIGNvbnRpbnVpbmdcblx0aWYgKCAhY2FjaGVbIGlkIF0gKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCBuYW1lICkge1xuXG5cdFx0dGhpc0NhY2hlID0gcHZ0ID8gY2FjaGVbIGlkIF0gOiBjYWNoZVsgaWQgXS5kYXRhO1xuXG5cdFx0aWYgKCB0aGlzQ2FjaGUgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBuYW1lcyBmb3IgZGF0YSBrZXlzXG5cdFx0XHRpZiAoICFqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXG5cdFx0XHRcdC8vIHRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsgbmFtZSBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gc3BsaXQgdGhlIGNhbWVsIGNhc2VkIHZlcnNpb24gYnkgc3BhY2VzIHVubGVzcyBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzXG5cdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblx0XHRcdFx0XHRpZiAoIG5hbWUgaW4gdGhpc0NhY2hlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IFsgbmFtZSBdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gbmFtZS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0gbmFtZS5jb25jYXQoIGpRdWVyeS5tYXAoIG5hbWUsIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXNDYWNoZVsgbmFtZVtpXSBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBkYXRhIGxlZnQgaW4gdGhlIGNhY2hlLCB3ZSB3YW50IHRvIGNvbnRpbnVlXG5cdFx0XHQvLyBhbmQgbGV0IHRoZSBjYWNoZSBvYmplY3QgaXRzZWxmIGdldCBkZXN0cm95ZWRcblx0XHRcdGlmICggcHZ0ID8gIWlzRW1wdHlEYXRhT2JqZWN0KHRoaXNDYWNoZSkgOiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QodGhpc0NhY2hlKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRpZiAoICFwdnQgKSB7XG5cdFx0ZGVsZXRlIGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHQvLyBEb24ndCBkZXN0cm95IHRoZSBwYXJlbnQgY2FjaGUgdW5sZXNzIHRoZSBpbnRlcm5hbCBkYXRhIG9iamVjdFxuXHRcdC8vIGhhZCBiZWVuIHRoZSBvbmx5IHRoaW5nIGxlZnQgaW4gaXRcblx0XHRpZiAoICFpc0VtcHR5RGF0YU9iamVjdCggY2FjaGVbIGlkIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHQvLyBEZXN0cm95IHRoZSBjYWNoZVxuXHRpZiAoIGlzTm9kZSApIHtcblx0XHRqUXVlcnkuY2xlYW5EYXRhKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXG5cdC8vIFVzZSBkZWxldGUgd2hlbiBzdXBwb3J0ZWQgZm9yIGV4cGFuZG9zIG9yIGBjYWNoZWAgaXMgbm90IGEgd2luZG93IHBlciBpc1dpbmRvdyAoIzEwMDgwKVxuXHQvKiBqc2hpbnQgZXFlcWVxOiBmYWxzZSAqL1xuXHR9IGVsc2UgaWYgKCBzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gfHwgY2FjaGUgIT0gY2FjaGUud2luZG93ICkge1xuXHRcdC8qIGpzaGludCBlcWVxZXE6IHRydWUgKi9cblx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cblx0Ly8gV2hlbiBhbGwgZWxzZSBmYWlscywgbnVsbFxuXHR9IGVsc2Uge1xuXHRcdGNhY2hlWyBpZCBdID0gbnVsbDtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2FjaGU6IHt9LFxuXG5cdC8vIFRoZSBmb2xsb3dpbmcgZWxlbWVudHMgKHNwYWNlLXN1ZmZpeGVkIHRvIGF2b2lkIE9iamVjdC5wcm90b3R5cGUgY29sbGlzaW9ucylcblx0Ly8gdGhyb3cgdW5jYXRjaGFibGUgZXhjZXB0aW9ucyBpZiB5b3UgYXR0ZW1wdCB0byBzZXQgZXhwYW5kbyBwcm9wZXJ0aWVzXG5cdG5vRGF0YToge1xuXHRcdFwiYXBwbGV0IFwiOiB0cnVlLFxuXHRcdFwiZW1iZWQgXCI6IHRydWUsXG5cdFx0Ly8gLi4uYnV0IEZsYXNoIG9iamVjdHMgKHdoaWNoIGhhdmUgdGhpcyBjbGFzc2lkKSAqY2FuKiBoYW5kbGUgZXhwYW5kb3Ncblx0XHRcIm9iamVjdCBcIjogXCJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDBcIlxuXHR9LFxuXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGVsZW0gPSBlbGVtLm5vZGVUeXBlID8galF1ZXJ5LmNhY2hlWyBlbGVtW2pRdWVyeS5leHBhbmRvXSBdIDogZWxlbVsgalF1ZXJ5LmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gISFlbGVtICYmICFpc0VtcHR5RGF0YU9iamVjdCggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBpbnRlcm5hbERhdGEoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGludGVybmFsRGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgdHJ1ZSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gaW50ZXJuYWxSZW1vdmVEYXRhKCBlbGVtLCBuYW1lLCB0cnVlICk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1swXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBTcGVjaWFsIGV4cGVjdGlvbnMgb2YgLmRhdGEgYmFzaWNhbGx5IHRod2FydCBqUXVlcnkuYWNjZXNzLFxuXHRcdC8vIHNvIGltcGxlbWVudCB0aGUgcmVsZXZhbnQgYmVoYXZpb3Igb3Vyc2VsdmVzXG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGpRdWVyeS5kYXRhKCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwicGFyc2VkQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbaV0ubmFtZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoXCJkYXRhLVwiKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoNSkgKTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJwYXJzZWRBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5ICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgP1xuXG5cdFx0XHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSkgOlxuXG5cdFx0XHQvLyBHZXRzIG9uZSB2YWx1ZVxuXHRcdFx0Ly8gVHJ5IHRvIGZldGNoIGFueSBpbnRlcm5hbGx5IHN0b3JlZCBkYXRhIGZpcnN0XG5cdFx0XHRlbGVtID8gZGF0YUF0dHIoIGVsZW0sIGtleSwgalF1ZXJ5LmRhdGEoIGVsZW0sIGtleSApICkgOiB1bmRlZmluZWQ7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIHRoaXMsIGtleSApO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KGRhdGEpICkge1xuXHRcdFx0XHRcdHF1ZXVlID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gbm90IGludGVuZGVkIGZvciBwdWJsaWMgY29uc3VtcHRpb24gLSBnZW5lcmF0ZXMgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJucyB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGpRdWVyeS5fZGF0YSggZWxlbSwga2V5ICkgfHwgalF1ZXJ5Ll9kYXRhKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGVsZW0sIHR5cGUgKyBcInF1ZXVlXCIgKTtcblx0XHRcdFx0alF1ZXJ5Ll9yZW1vdmVEYXRhKCBlbGVtLCBrZXkgKTtcblx0XHRcdH0pXG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbMF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBlbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVswXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0pO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0galF1ZXJ5Ll9kYXRhKCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59KTtcbnZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8ICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBqUXVlcnkuYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRqUXVlcnkuYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Zm4oIGVsZW1zW2ldLCBrZXksIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbCggZWxlbXNbaV0sIGksIGZuKCBlbGVtc1tpXSwga2V5ICkgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuZ3RoID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICgvXig/OmNoZWNrYm94fHJhZGlvKSQvaSk7XG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXG5cdC8vIFNldHVwXG5cdGRpdi5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NOYW1lXCIsIFwidFwiICk7XG5cdGRpdi5pbm5lckhUTUwgPSBcIiAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJz5hPC9hPlwiO1xuXG5cdC8vIElFIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiAuaW5uZXJIVE1MIGlzIHVzZWRcblx0c3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSA9IGRpdi5maXJzdENoaWxkLm5vZGVUeXBlID09PSAzO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IHRib2R5IGVsZW1lbnRzIGFyZW4ndCBhdXRvbWF0aWNhbGx5IGluc2VydGVkXG5cdC8vIElFIHdpbGwgaW5zZXJ0IHRoZW0gaW50byBlbXB0eSB0YWJsZXNcblx0c3VwcG9ydC50Ym9keSA9ICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApLmxlbmd0aDtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBsaW5rIGVsZW1lbnRzIGdldCBzZXJpYWxpemVkIGNvcnJlY3RseSBieSBpbm5lckhUTUxcblx0Ly8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuXHRzdXBwb3J0Lmh0bWxTZXJpYWxpemUgPSAhIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJsaW5rXCIgKS5sZW5ndGg7XG5cblx0Ly8gTWFrZXMgc3VyZSBjbG9uaW5nIGFuIGh0bWw1IGVsZW1lbnQgZG9lcyBub3QgY2F1c2UgcHJvYmxlbXNcblx0Ly8gV2hlcmUgb3V0ZXJIVE1MIGlzIHVuZGVmaW5lZCwgdGhpcyBzdGlsbCB3b3Jrc1xuXHRzdXBwb3J0Lmh0bWw1Q2xvbmUgPVxuXHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwibmF2XCIgKS5jbG9uZU5vZGUoIHRydWUgKS5vdXRlckhUTUwgIT09IFwiPDpuYXY+PC86bmF2PlwiO1xuXG5cdC8vIENoZWNrIGlmIGEgZGlzY29ubmVjdGVkIGNoZWNrYm94IHdpbGwgcmV0YWluIGl0cyBjaGVja2VkXG5cdC8vIHZhbHVlIG9mIHRydWUgYWZ0ZXIgYXBwZW5kZWQgdG8gdGhlIERPTSAoSUU2LzcpXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cdGlucHV0LmNoZWNrZWQgPSB0cnVlO1xuXHRmcmFnbWVudC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0c3VwcG9ydC5hcHBlbmRDaGVja2VkID0gaW5wdXQuY2hlY2tlZDtcblxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHQvLyBTdXBwb3J0OiBJRTYtSUUxMStcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyAjMTEyMTcgLSBXZWJLaXQgbG9zZXMgY2hlY2sgd2hlbiB0aGUgbmFtZSBpcyBhZnRlciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGVcblx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQgdHlwZT0ncmFkaW8nIGNoZWNrZWQ9J2NoZWNrZWQnIG5hbWU9J3QnLz5cIjtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNS4xLCBpT1MgNS4xLCBBbmRyb2lkIDQueCwgQW5kcm9pZCAyLjNcblx0Ly8gb2xkIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHQvLyBPcGVyYSBkb2VzIG5vdCBjbG9uZSBldmVudHMgKGFuZCB0eXBlb2YgZGl2LmF0dGFjaEV2ZW50ID09PSB1bmRlZmluZWQpLlxuXHQvLyBJRTktMTAgY2xvbmVzIGV2ZW50cyBib3VuZCB2aWEgYXR0YWNoRXZlbnQsIGJ1dCB0aGV5IGRvbid0IHRyaWdnZXIgd2l0aCAuY2xpY2soKVxuXHRzdXBwb3J0Lm5vQ2xvbmVFdmVudCA9IHRydWU7XG5cdGlmICggZGl2LmF0dGFjaEV2ZW50ICkge1xuXHRcdGRpdi5hdHRhY2hFdmVudCggXCJvbmNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTtcblx0XHR9KTtcblxuXHRcdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbGljaygpO1xuXHR9XG5cblx0Ly8gRXhlY3V0ZSB0aGUgdGVzdCBvbmx5IGlmIG5vdCBhbHJlYWR5IGV4ZWN1dGVkIGluIGFub3RoZXIgbW9kdWxlLlxuXHRpZiAoc3VwcG9ydC5kZWxldGVFeHBhbmRvID09IG51bGwpIHtcblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0c3VwcG9ydC5kZWxldGVFeHBhbmRvID0gdHJ1ZTtcblx0XHR0cnkge1xuXHRcdFx0ZGVsZXRlIGRpdi50ZXN0O1xuXHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHRzdXBwb3J0LmRlbGV0ZUV4cGFuZG8gPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvLyBOdWxsIGVsZW1lbnRzIHRvIGF2b2lkIGxlYWtzIGluIElFLlxuXHRmcmFnbWVudCA9IGRpdiA9IGlucHV0ID0gbnVsbDtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgaSwgZXZlbnROYW1lLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5IChsYWNrIHN1Ym1pdC9jaGFuZ2UgYnViYmxlKSwgRmlyZWZveCAyMysgKGxhY2sgZm9jdXNpbiBldmVudClcblx0Zm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgY2hhbmdlOiB0cnVlLCBmb2N1c2luOiB0cnVlIH0pIHtcblx0XHRldmVudE5hbWUgPSBcIm9uXCIgKyBpO1xuXG5cdFx0aWYgKCAhKHN1cHBvcnRbIGkgKyBcIkJ1YmJsZXNcIiBdID0gZXZlbnROYW1lIGluIHdpbmRvdykgKSB7XG5cdFx0XHQvLyBCZXdhcmUgb2YgQ1NQIHJlc3RyaWN0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vU2VjdXJpdHkvQ1NQKVxuXHRcdFx0ZGl2LnNldEF0dHJpYnV0ZSggZXZlbnROYW1lLCBcInRcIiApO1xuXHRcdFx0c3VwcG9ydFsgaSArIFwiQnViYmxlc1wiIF0gPSBkaXYuYXR0cmlidXRlc1sgZXZlbnROYW1lIF0uZXhwYW5kbyA9PT0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRS5cblx0ZGl2ID0gbnVsbDtcbn0pKCk7XG5cblxudmFyIHJmb3JtRWxlbXMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2ksXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay8sXG5cdHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KSQvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblx0XHR2YXIgdG1wLCBldmVudHMsIHQsIGhhbmRsZU9iakluLFxuXHRcdFx0c3BlY2lhbCwgZXZlbnRIYW5kbGUsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0galF1ZXJ5Ll9kYXRhKCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBzdHJ1bmRlZmluZWQgJiYgKCFlIHx8IGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSkgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZXZlbnRIYW5kbGUuZWxlbSwgYXJndW1lbnRzICkgOlxuXHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0XHQvLyBBZGQgZWxlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUgZm4gdG8gcHJldmVudCBhIG1lbW9yeSBsZWFrIHdpdGggSUUgbm9uLW5hdGl2ZSBldmVudHNcblx0XHRcdGV2ZW50SGFuZGxlLmVsZW0gPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsyXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0pICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIvYXR0YWNoRXZlbnQgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gQmluZCB0aGUgZ2xvYmFsIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hdHRhY2hFdmVudCggXCJvblwiICsgdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBOdWxsaWZ5IGVsZW0gdG8gcHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcblx0XHRlbGVtID0gbnVsbDtcblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblx0XHR2YXIgaiwgaGFuZGxlT2JqLCB0bXAsXG5cdFx0XHRvcmlnQ291bnQsIHQsIGV2ZW50cyxcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLFxuXHRcdFx0bmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGpRdWVyeS5oYXNEYXRhKCBlbGVtICkgJiYgalF1ZXJ5Ll9kYXRhKCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsyXSAmJiBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cblx0XHRcdC8vIHJlbW92ZURhdGEgYWxzbyBjaGVja3MgZm9yIGVtcHRpbmVzcyBhbmQgY2xlYXJzIHRoZSBleHBhbmRvIGlmIGVtcHR5XG5cdFx0XHQvLyBzbyB1c2UgaXQgaW5zdGVhZCBvZiBkZWxldGVcblx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblx0XHR2YXIgaGFuZGxlLCBvbnR5cGUsIGN1cixcblx0XHRcdGJ1YmJsZVR5cGUsIHNwZWNpYWwsIHRtcCwgaSxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoXCIuXCIpID49IDAgKSB7XG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG5cdFx0ZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiYgalF1ZXJ5Ll9kYXRhKCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UpICYmXG5cdFx0XHRcdGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBDYW4ndCB1c2UgYW4gLmlzRnVuY3Rpb24oKSBjaGVjayBoZXJlIGJlY2F1c2UgSUU2LzcgZmFpbHMgdGhhdCB0ZXN0LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGVsZW1bIHR5cGUgXSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdC8vIElFPDkgZGllcyBvbiBmb2N1cy9ibHVyIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4NiwjMTI1MTgpXG5cdFx0XHRcdFx0XHQvLyBvbmx5IHJlcHJvZHVjaWJsZSBvbiB3aW5YUCBJRTggbmF0aXZlLCBub3QgSUU5IGluIElFOCBtb2RlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCByZXQsIGhhbmRsZU9iaiwgbWF0Y2hlZCwgaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGpRdWVyeS5fZGF0YSggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWzBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoIChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSkgJiYgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvclxuXHRcdFx0XHQvLyAyKSBoYXZlIG5hbWVzcGFjZShzKSBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQubmFtZXNwYWNlX3JlIHx8IGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHQuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgc2VsLCBoYW5kbGVPYmosIG1hdGNoZXMsIGksXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJiAoIWV2ZW50LmJ1dHRvbiB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHQvKiBqc2hpbnQgZXFlcWVxOiBmYWxzZSAqL1xuXHRcdFx0Zm9yICggOyBjdXIgIT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblx0XHRcdFx0LyoganNoaW50IGVxZXFlcTogdHJ1ZSAqL1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID49IDAgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIEZpeCB0YXJnZXQgcHJvcGVydHkgKCMxOTI1KVxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IG9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgMjMrLCBTYWZhcmk/XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBGb3IgbW91c2Uva2V5IGV2ZW50cywgbWV0YUtleT09ZmFsc2UgaWYgaXQncyB1bmRlZmluZWQgKCMzMzY4LCAjMTEzMjgpXG5cdFx0ZXZlbnQubWV0YUtleSA9ICEhZXZlbnQubWV0YUtleTtcblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6IFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGJvZHksIGV2ZW50RG9jLCBkb2MsXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbixcblx0XHRcdFx0ZnJvbUVsZW1lbnQgPSBvcmlnaW5hbC5mcm9tRWxlbWVudDtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHJlbGF0ZWRUYXJnZXQsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCAhZXZlbnQucmVsYXRlZFRhcmdldCAmJiBmcm9tRWxlbWVudCApIHtcblx0XHRcdFx0ZXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBvcmlnaW5hbC50b0VsZW1lbnQgOiBmcm9tRWxlbWVudDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdFx0XHRcdC8vIElmIHdlIGVycm9yIG9uIGZvY3VzIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4NiwgIzEyNTE4KSxcblx0XHRcdFx0XHRcdC8vIGxldCAudHJpZ2dlcigpIHJ1biB0aGUgaGFuZGxlcnNcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICYmIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gRXZlbiB3aGVuIHJldHVyblZhbHVlIGVxdWFscyB0byB1bmRlZmluZWQgRmlyZWZveCB3aWxsIHN0aWxsIHNob3cgYWxlcnRcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG5cdFx0Ly8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXG5cdFx0Ly8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlLFxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuXHRcdH1cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciA/XG5cdGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cdFx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSwgZmFsc2UgKTtcblx0XHR9XG5cdH0gOlxuXHRmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRcdHZhciBuYW1lID0gXCJvblwiICsgdHlwZTtcblxuXHRcdGlmICggZWxlbS5kZXRhY2hFdmVudCApIHtcblxuXHRcdFx0Ly8gIzg1NDUsICM3MDU0LCBwcmV2ZW50aW5nIG1lbW9yeSBsZWFrcyBmb3IgY3VzdG9tIGV2ZW50cyBpbiBJRTYtOFxuXHRcdFx0Ly8gZGV0YWNoRXZlbnQgbmVlZGVkIHByb3BlcnR5IG9uIGVsZW1lbnQsIGJ5IG5hbWUgb2YgdGhhdCBldmVudCwgdG8gcHJvcGVybHkgZXhwb3NlIGl0IHRvIEdDXG5cdFx0XHRpZiAoIHR5cGVvZiBlbGVtWyBuYW1lIF0gPT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZWxlbVsgbmFtZSBdID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5kZXRhY2hFdmVudCggbmFtZSwgaGFuZGxlICk7XG5cdFx0fVxuXHR9O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmIChcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPCA5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8IDQuMFxuXHRcdFx0XHRzcmMuZ2V0UHJldmVudERlZmF1bHQgJiYgc3JjLmdldFByZXZlbnREZWZhdWx0KCkgKSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblx0XHRpZiAoICFlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHByZXZlbnREZWZhdWx0IGV4aXN0cywgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXHRcdGlmICggZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gT3RoZXJ3aXNlIHNldCB0aGUgcmV0dXJuVmFsdWUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGZhbHNlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblx0XHRpZiAoICFlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBJZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzLCBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cdFx0aWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBTZXQgdGhlIGNhbmNlbEJ1YmJsZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gdHJ1ZVxuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcbmpRdWVyeS5lYWNoKHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBJRSBzdWJtaXQgZGVsZWdhdGlvblxuaWYgKCAhc3VwcG9ydC5zdWJtaXRCdWJibGVzICkge1xuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsLnN1Ym1pdCA9IHtcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBPbmx5IG5lZWQgdGhpcyBmb3IgZGVsZWdhdGVkIGZvcm0gc3VibWl0IGV2ZW50c1xuXHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiZm9ybVwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTGF6eS1hZGQgYSBzdWJtaXQgaGFuZGxlciB3aGVuIGEgZGVzY2VuZGFudCBmb3JtIG1heSBwb3RlbnRpYWxseSBiZSBzdWJtaXR0ZWRcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwiY2xpY2suX3N1Ym1pdCBrZXlwcmVzcy5fc3VibWl0XCIsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHQvLyBOb2RlIG5hbWUgY2hlY2sgYXZvaWRzIGEgVk1MLXJlbGF0ZWQgY3Jhc2ggaW4gSUUgKCM5ODA3KVxuXHRcdFx0XHR2YXIgZWxlbSA9IGUudGFyZ2V0LFxuXHRcdFx0XHRcdGZvcm0gPSBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApID8gZWxlbS5mb3JtIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoIGZvcm0gJiYgIWpRdWVyeS5fZGF0YSggZm9ybSwgXCJzdWJtaXRCdWJibGVzXCIgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBmb3JtLCBcInN1Ym1pdC5fc3VibWl0XCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGV2ZW50Ll9zdWJtaXRfYnViYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGZvcm0sIFwic3VibWl0QnViYmxlc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBzaW5jZSB3ZSBkb24ndCBuZWVkIGFuIGV2ZW50IGxpc3RlbmVyXG5cdFx0fSxcblxuXHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0Ly8gSWYgZm9ybSB3YXMgc3VibWl0dGVkIGJ5IHRoZSB1c2VyLCBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSB0cmVlXG5cdFx0XHRpZiAoIGV2ZW50Ll9zdWJtaXRfYnViYmxlICkge1xuXHRcdFx0XHRkZWxldGUgZXZlbnQuX3N1Ym1pdF9idWJibGU7XG5cdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcInN1Ym1pdFwiLCB0aGlzLnBhcmVudE5vZGUsIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBkZWxlZ2F0ZWQgaGFuZGxlcnM7IGNsZWFuRGF0YSBldmVudHVhbGx5IHJlYXBzIHN1Ym1pdCBoYW5kbGVycyBhdHRhY2hlZCBhYm92ZVxuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgXCIuX3N1Ym1pdFwiICk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBJRSBjaGFuZ2UgZGVsZWdhdGlvbiBhbmQgY2hlY2tib3gvcmFkaW8gZml4XG5pZiAoICFzdXBwb3J0LmNoYW5nZUJ1YmJsZXMgKSB7XG5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWwuY2hhbmdlID0ge1xuXG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAoIHJmb3JtRWxlbXMudGVzdCggdGhpcy5ub2RlTmFtZSApICkge1xuXHRcdFx0XHQvLyBJRSBkb2Vzbid0IGZpcmUgY2hhbmdlIG9uIGEgY2hlY2svcmFkaW8gdW50aWwgYmx1cjsgdHJpZ2dlciBpdCBvbiBjbGlja1xuXHRcdFx0XHQvLyBhZnRlciBhIHByb3BlcnR5Y2hhbmdlLiBFYXQgdGhlIGJsdXItY2hhbmdlIGluIHNwZWNpYWwuY2hhbmdlLmhhbmRsZS5cblx0XHRcdFx0Ly8gVGhpcyBzdGlsbCBmaXJlcyBvbmNoYW5nZSBhIHNlY29uZCB0aW1lIGZvciBjaGVjay9yYWRpbyBhZnRlciBibHVyLlxuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIFwicHJvcGVydHljaGFuZ2UuX2NoYW5nZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGV2ZW50Lm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lID09PSBcImNoZWNrZWRcIiApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fanVzdF9jaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLl9qdXN0X2NoYW5nZWQgJiYgIWV2ZW50LmlzVHJpZ2dlciApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fanVzdF9jaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBBbGxvdyB0cmlnZ2VyZWQsIHNpbXVsYXRlZCBjaGFuZ2UgZXZlbnRzICgjMTE1MDApXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwiY2hhbmdlXCIsIHRoaXMsIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGVsZWdhdGVkIGV2ZW50OyBsYXp5LWFkZCBhIGNoYW5nZSBoYW5kbGVyIG9uIGRlc2NlbmRhbnQgaW5wdXRzXG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gZS50YXJnZXQ7XG5cblx0XHRcdFx0aWYgKCByZm9ybUVsZW1zLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiAhalF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImNoYW5nZUJ1YmJsZXNcIiApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsZW0sIFwiY2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgJiYgIWV2ZW50LmlzU2ltdWxhdGVkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJjaGFuZ2VCdWJibGVzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGVsZW0gPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdC8vIFN3YWxsb3cgbmF0aXZlIGNoYW5nZSBldmVudHMgZnJvbSBjaGVja2JveC9yYWRpbywgd2UgYWxyZWFkeSB0cmlnZ2VyZWQgdGhlbSBhYm92ZVxuXHRcdFx0aWYgKCB0aGlzICE9PSBlbGVtIHx8IGV2ZW50LmlzU2ltdWxhdGVkIHx8IGV2ZW50LmlzVHJpZ2dlciB8fCAoZWxlbS50eXBlICE9PSBcInJhZGlvXCIgJiYgZWxlbS50eXBlICE9PSBcImNoZWNrYm94XCIpICkge1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCBcIi5fY2hhbmdlXCIgKTtcblxuXHRcdFx0cmV0dXJuICFyZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKTtcblx0XHR9XG5cdH07XG59XG5cbi8vIENyZWF0ZSBcImJ1YmJsaW5nXCIgZm9jdXMgYW5kIGJsdXIgZXZlbnRzXG5pZiAoICFzdXBwb3J0LmZvY3VzaW5CdWJibGVzICkge1xuXHRqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApLCB0cnVlICk7XG5cdFx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBqUXVlcnkuX2RhdGEoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGpRdWVyeS5fZGF0YSggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRqUXVlcnkuX3JlbW92ZURhdGEoIGRvYywgZml4ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XG5cdFx0dmFyIHR5cGUsIG9yaWdGbjtcblxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fTtcblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0pO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSk7XG5cblxuZnVuY3Rpb24gY3JlYXRlU2FmZUZyYWdtZW50KCBkb2N1bWVudCApIHtcblx0dmFyIGxpc3QgPSBub2RlTmFtZXMuc3BsaXQoIFwifFwiICksXG5cdFx0c2FmZUZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0aWYgKCBzYWZlRnJhZy5jcmVhdGVFbGVtZW50ICkge1xuXHRcdHdoaWxlICggbGlzdC5sZW5ndGggKSB7XG5cdFx0XHRzYWZlRnJhZy5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRsaXN0LnBvcCgpXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc2FmZUZyYWc7XG59XG5cbnZhciBub2RlTmFtZXMgPSBcImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8XCIgK1xuXHRcdFwiaGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW9cIixcblx0cmlubGluZWpRdWVyeSA9IC8galF1ZXJ5XFxkKz1cIig/Om51bGx8XFxkKylcIi9nLFxuXHRybm9zaGltY2FjaGUgPSBuZXcgUmVnRXhwKFwiPCg/OlwiICsgbm9kZU5hbWVzICsgXCIpW1xcXFxzLz5dXCIsIFwiaVwiKSxcblx0cmxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLyxcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLFxuXHRydGFnTmFtZSA9IC88KFtcXHc6XSspLyxcblx0cnRib2R5ID0gLzx0Ym9keS9pLFxuXHRyaHRtbCA9IC88fCYjP1xcdys7Lyxcblx0cm5vSW5uZXJodG1sID0gLzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxcblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGUgPSAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXG5cblx0Ly8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcblx0d3JhcE1hcCA9IHtcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblx0XHRsZWdlbmQ6IFsgMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIiBdLFxuXHRcdGFyZWE6IFsgMSwgXCI8bWFwPlwiLCBcIjwvbWFwPlwiIF0sXG5cdFx0cGFyYW06IFsgMSwgXCI8b2JqZWN0PlwiLCBcIjwvb2JqZWN0PlwiIF0sXG5cdFx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHRjb2w6IFsgMiwgXCI8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHRcdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRcdC8vIElFNi04IGNhbid0IHNlcmlhbGl6ZSBsaW5rLCBzY3JpcHQsIHN0eWxlLCBvciBhbnkgaHRtbDUgKE5vU2NvcGUpIHRhZ3MsXG5cdFx0Ly8gdW5sZXNzIHdyYXBwZWQgaW4gYSBkaXYgd2l0aCBub24tYnJlYWtpbmcgY2hhcmFjdGVycyBpbiBmcm9udCBvZiBpdC5cblx0XHRfZGVmYXVsdDogc3VwcG9ydC5odG1sU2VyaWFsaXplID8gWyAwLCBcIlwiLCBcIlwiIF0gOiBbIDEsIFwiWDxkaXY+XCIsIFwiPC9kaXY+XCIgIF1cblx0fSxcblx0c2FmZUZyYWdtZW50ID0gY3JlYXRlU2FmZUZyYWdtZW50KCBkb2N1bWVudCApLFxuXHRmcmFnbWVudERpdiA9IHNhZmVGcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuXG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXHR2YXIgZWxlbXMsIGVsZW0sXG5cdFx0aSA9IDAsXG5cdFx0Zm91bmQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0dHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gc3RydW5kZWZpbmVkID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0aWYgKCAhZm91bmQgKSB7XG5cdFx0Zm9yICggZm91bmQgPSBbXSwgZWxlbXMgPSBjb250ZXh0LmNoaWxkTm9kZXMgfHwgY29udGV4dDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCAhdGFnIHx8IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgdGFnICkgKSB7XG5cdFx0XHRcdGZvdW5kLnB1c2goIGVsZW0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggZm91bmQsIGdldEFsbCggZWxlbSwgdGFnICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIGZvdW5kICkgOlxuXHRcdGZvdW5kO1xufVxuXG4vLyBVc2VkIGluIGJ1aWxkRnJhZ21lbnQsIGZpeGVzIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZml4RGVmYXVsdENoZWNrZWQoIGVsZW0gKSB7XG5cdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWxlbS50eXBlICkgKSB7XG5cdFx0ZWxlbS5kZWZhdWx0Q2hlY2tlZCA9IGVsZW0uY2hlY2tlZDtcblx0fVxufVxuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9IChqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInR5cGVcIiApICE9PSBudWxsKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWzFdO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcblx0fVxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGkgPSAwO1xuXHRmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgalF1ZXJ5Ll9kYXRhKCByZWZFbGVtZW50c1tpXSwgXCJnbG9iYWxFdmFsXCIgKSApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHR5cGUsIGksIGwsXG5cdFx0b2xkRGF0YSA9IGpRdWVyeS5fZGF0YSggc3JjICksXG5cdFx0Y3VyRGF0YSA9IGpRdWVyeS5fZGF0YSggZGVzdCwgb2xkRGF0YSApLFxuXHRcdGV2ZW50cyA9IG9sZERhdGEuZXZlbnRzO1xuXG5cdGlmICggZXZlbnRzICkge1xuXHRcdGRlbGV0ZSBjdXJEYXRhLmhhbmRsZTtcblx0XHRjdXJEYXRhLmV2ZW50cyA9IHt9O1xuXG5cdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIG1ha2UgdGhlIGNsb25lZCBwdWJsaWMgZGF0YSBvYmplY3QgYSBjb3B5IGZyb20gdGhlIG9yaWdpbmFsXG5cdGlmICggY3VyRGF0YS5kYXRhICkge1xuXHRcdGN1ckRhdGEuZGF0YSA9IGpRdWVyeS5leHRlbmQoIHt9LCBjdXJEYXRhLmRhdGEgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBmaXhDbG9uZU5vZGVJc3N1ZXMoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lLCBlLCBkYXRhO1xuXG5cdC8vIFdlIGRvIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBub24tRWxlbWVudHNcblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIElFNi04IGNvcGllcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50IHdoZW4gdXNpbmcgY2xvbmVOb2RlLlxuXHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVFdmVudCAmJiBkZXN0WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdGRhdGEgPSBqUXVlcnkuX2RhdGEoIGRlc3QgKTtcblxuXHRcdGZvciAoIGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGRlc3QsIGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0fVxuXG5cdFx0Ly8gRXZlbnQgZGF0YSBnZXRzIHJlZmVyZW5jZWQgaW5zdGVhZCBvZiBjb3BpZWQgaWYgdGhlIGV4cGFuZG8gZ2V0cyBjb3BpZWQgdG9vXG5cdFx0ZGVzdC5yZW1vdmVBdHRyaWJ1dGUoIGpRdWVyeS5leHBhbmRvICk7XG5cdH1cblxuXHQvLyBJRSBibGFua3MgY29udGVudHMgd2hlbiBjbG9uaW5nIHNjcmlwdHMsIGFuZCB0cmllcyB0byBldmFsdWF0ZSBuZXdseS1zZXQgdGV4dFxuXHRpZiAoIG5vZGVOYW1lID09PSBcInNjcmlwdFwiICYmIGRlc3QudGV4dCAhPT0gc3JjLnRleHQgKSB7XG5cdFx0ZGlzYWJsZVNjcmlwdCggZGVzdCApLnRleHQgPSBzcmMudGV4dDtcblx0XHRyZXN0b3JlU2NyaXB0KCBkZXN0ICk7XG5cblx0Ly8gSUU2LTEwIGltcHJvcGVybHkgY2xvbmVzIGNoaWxkcmVuIG9mIG9iamVjdCBlbGVtZW50cyB1c2luZyBjbGFzc2lkLlxuXHQvLyBJRTEwIHRocm93cyBOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvciBpZiBwYXJlbnQgaXMgbnVsbCwgIzEyMTMyLlxuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRpZiAoIGRlc3QucGFyZW50Tm9kZSApIHtcblx0XHRcdGRlc3Qub3V0ZXJIVE1MID0gc3JjLm91dGVySFRNTDtcblx0XHR9XG5cblx0XHQvLyBUaGlzIHBhdGggYXBwZWFycyB1bmF2b2lkYWJsZSBmb3IgSUU5LiBXaGVuIGNsb25pbmcgYW4gb2JqZWN0XG5cdFx0Ly8gZWxlbWVudCBpbiBJRTksIHRoZSBvdXRlckhUTUwgc3RyYXRlZ3kgYWJvdmUgaXMgbm90IHN1ZmZpY2llbnQuXG5cdFx0Ly8gSWYgdGhlIHNyYyBoYXMgaW5uZXJIVE1MIGFuZCB0aGUgZGVzdGluYXRpb24gZG9lcyBub3QsXG5cdFx0Ly8gY29weSB0aGUgc3JjLmlubmVySFRNTCBpbnRvIHRoZSBkZXN0LmlubmVySFRNTC4gIzEwMzI0XG5cdFx0aWYgKCBzdXBwb3J0Lmh0bWw1Q2xvbmUgJiYgKCBzcmMuaW5uZXJIVE1MICYmICFqUXVlcnkudHJpbShkZXN0LmlubmVySFRNTCkgKSApIHtcblx0XHRcdGRlc3QuaW5uZXJIVE1MID0gc3JjLmlubmVySFRNTDtcblx0XHR9XG5cblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdC8vIElFNi04IGZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3hcblx0XHQvLyBvciByYWRpbyBidXR0b24uIFdvcnNlLCBJRTYtNyBmYWlsIHRvIGdpdmUgdGhlIGNsb25lZCBlbGVtZW50XG5cdFx0Ly8gYSBjaGVja2VkIGFwcGVhcmFuY2UgaWYgdGhlIGRlZmF1bHRDaGVja2VkIHZhbHVlIGlzbid0IGFsc28gc2V0XG5cblx0XHRkZXN0LmRlZmF1bHRDaGVja2VkID0gZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0XHQvLyBJRTYtNyBnZXQgY29uZnVzZWQgYW5kIGVuZCB1cCBzZXR0aW5nIHRoZSB2YWx1ZSBvZiBhIGNsb25lZFxuXHRcdC8vIGNoZWNrYm94L3JhZGlvIGJ1dHRvbiB0byBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiBcIm9uXCJcblx0XHRpZiAoIGRlc3QudmFsdWUgIT09IHNyYy52YWx1ZSApIHtcblx0XHRcdGRlc3QudmFsdWUgPSBzcmMudmFsdWU7XG5cdFx0fVxuXG5cdC8vIElFNi04IGZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkXG5cdC8vIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFNlbGVjdGVkID0gZGVzdC5zZWxlY3RlZCA9IHNyYy5kZWZhdWx0U2VsZWN0ZWQ7XG5cblx0Ly8gSUU2LTggZmFpbHMgdG8gc2V0IHRoZSBkZWZhdWx0VmFsdWUgdG8gdGhlIGNvcnJlY3QgdmFsdWUgd2hlblxuXHQvLyBjbG9uaW5nIG90aGVyIHR5cGVzIG9mIGlucHV0IGZpZWxkc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBkZXN0RWxlbWVudHMsIG5vZGUsIGNsb25lLCBpLCBzcmNFbGVtZW50cyxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRpZiAoIHN1cHBvcnQuaHRtbDVDbG9uZSB8fCBqUXVlcnkuaXNYTUxEb2MoZWxlbSkgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCBcIjxcIiArIGVsZW0ubm9kZU5hbWUgKyBcIj5cIiApICkge1xuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApO1xuXG5cdFx0Ly8gSUU8PTggZG9lcyBub3QgcHJvcGVybHkgY2xvbmUgZGV0YWNoZWQsIHVua25vd24gZWxlbWVudCBub2Rlc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmcmFnbWVudERpdi5pbm5lckhUTUwgPSBlbGVtLm91dGVySFRNTDtcblx0XHRcdGZyYWdtZW50RGl2LnJlbW92ZUNoaWxkKCBjbG9uZSA9IGZyYWdtZW50RGl2LmZpcnN0Q2hpbGQgKTtcblx0XHR9XG5cblx0XHRpZiAoICghc3VwcG9ydC5ub0Nsb25lRXZlbnQgfHwgIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQpICYmXG5cdFx0XHRcdChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExKSAmJiAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Ly8gRml4IGFsbCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdFx0Zm9yICggaSA9IDA7IChub2RlID0gc3JjRWxlbWVudHNbaV0pICE9IG51bGw7ICsraSApIHtcblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgdGhlIGRlc3RpbmF0aW9uIG5vZGUgaXMgbm90IG51bGw7IEZpeGVzICM5NTg3XG5cdFx0XHRcdGlmICggZGVzdEVsZW1lbnRzW2ldICkge1xuXHRcdFx0XHRcdGZpeENsb25lTm9kZUlzc3Vlcyggbm9kZSwgZGVzdEVsZW1lbnRzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgKG5vZGUgPSBzcmNFbGVtZW50c1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBub2RlLCBkZXN0RWxlbWVudHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0ZGVzdEVsZW1lbnRzID0gc3JjRWxlbWVudHMgPSBub2RlID0gbnVsbDtcblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiApIHtcblx0XHR2YXIgaiwgZWxlbSwgY29udGFpbnMsXG5cdFx0XHR0bXAsIHRhZywgdGJvZHksIHdyYXAsXG5cdFx0XHRsID0gZWxlbXMubGVuZ3RoLFxuXG5cdFx0XHQvLyBFbnN1cmUgYSBzYWZlIGZyYWdtZW50XG5cdFx0XHRzYWZlID0gY3JlYXRlU2FmZUZyYWdtZW50KCBjb250ZXh0ICksXG5cblx0XHRcdG5vZGVzID0gW10sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAgfHwgc2FmZS5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICk7XG5cblx0XHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdFx0dGFnID0gKHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSlbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXG5cdFx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbMV0gKyBlbGVtLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApICsgd3JhcFsyXTtcblxuXHRcdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRcdGogPSB3cmFwWzBdO1xuXHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBNYW51YWxseSBhZGQgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQgYnkgSUVcblx0XHRcdFx0XHRpZiAoICFzdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBybGVhZGluZ1doaXRlc3BhY2UuZXhlYyggZWxlbSApWzBdICkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZW1vdmUgSUUncyBhdXRvaW5zZXJ0ZWQgPHRib2R5PiBmcm9tIHRhYmxlIGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggIXN1cHBvcnQudGJvZHkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN0cmluZyB3YXMgYSA8dGFibGU+LCAqbWF5KiBoYXZlIHNwdXJpb3VzIDx0Ym9keT5cblx0XHRcdFx0XHRcdGVsZW0gPSB0YWcgPT09IFwidGFibGVcIiAmJiAhcnRib2R5LnRlc3QoIGVsZW0gKSA/XG5cdFx0XHRcdFx0XHRcdHRtcC5maXJzdENoaWxkIDpcblxuXHRcdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgYmFyZSA8dGhlYWQ+IG9yIDx0Zm9vdD5cblx0XHRcdFx0XHRcdFx0d3JhcFsxXSA9PT0gXCI8dGFibGU+XCIgJiYgIXJ0Ym9keS50ZXN0KCBlbGVtICkgP1xuXHRcdFx0XHRcdFx0XHRcdHRtcCA6XG5cdFx0XHRcdFx0XHRcdFx0MDtcblxuXHRcdFx0XHRcdFx0aiA9IGVsZW0gJiYgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggKHRib2R5ID0gZWxlbS5jaGlsZE5vZGVzW2pdKSwgXCJ0Ym9keVwiICkgJiYgIXRib2R5LmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlQ2hpbGQoIHRib2R5ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdFx0Ly8gRml4ICMxMjM5MiBmb3IgV2ViS2l0IGFuZCBJRSA+IDlcblx0XHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdFx0XHRcdFx0Ly8gRml4ICMxMjM5MiBmb3Igb2xkSUVcblx0XHRcdFx0XHR3aGlsZSAoIHRtcC5maXJzdENoaWxkICkge1xuXHRcdFx0XHRcdFx0dG1wLnJlbW92ZUNoaWxkKCB0bXAuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciBwcm9wZXIgY2xlYW51cFxuXHRcdFx0XHRcdHRtcCA9IHNhZmUubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRml4ICMxMTM1NjogQ2xlYXIgZWxlbWVudHMgZnJvbSBmcmFnbWVudFxuXHRcdGlmICggdG1wICkge1xuXHRcdFx0c2FmZS5yZW1vdmVDaGlsZCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgZGVmYXVsdENoZWNrZWQgZm9yIGFueSByYWRpb3MgYW5kIGNoZWNrYm94ZXNcblx0XHQvLyBhYm91dCB0byBiZSBhcHBlbmRlZCB0byB0aGUgRE9NIGluIElFIDYvNyAoIzgwNjApXG5cdFx0aWYgKCAhc3VwcG9ydC5hcHBlbmRDaGVja2VkICkge1xuXHRcdFx0alF1ZXJ5LmdyZXAoIGdldEFsbCggbm9kZXMsIFwiaW5wdXRcIiApLCBmaXhEZWZhdWx0Q2hlY2tlZCApO1xuXHRcdH1cblxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGVsZW0gPSBub2Rlc1sgaSsrIF0pICkge1xuXG5cdFx0XHQvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xuXHRcdFx0Ly8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmdcblx0XHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdFx0dG1wID0gZ2V0QWxsKCBzYWZlLmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSB0bXBbIGorKyBdKSApIHtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0bXAgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHNhZmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMsIC8qIGludGVybmFsICovIGFjY2VwdERhdGEgKSB7XG5cdFx0dmFyIGVsZW0sIHR5cGUsIGlkLCBkYXRhLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRpbnRlcm5hbEtleSA9IGpRdWVyeS5leHBhbmRvLFxuXHRcdFx0Y2FjaGUgPSBqUXVlcnkuY2FjaGUsXG5cdFx0XHRkZWxldGVFeHBhbmRvID0gc3VwcG9ydC5kZWxldGVFeHBhbmRvLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEgfHwgalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHRpZCA9IGVsZW1bIGludGVybmFsS2V5IF07XG5cdFx0XHRcdGRhdGEgPSBpZCAmJiBjYWNoZVsgaWQgXTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGNhY2hlIG9ubHkgaWYgaXQgd2FzIG5vdCBhbHJlYWR5IHJlbW92ZWQgYnkgalF1ZXJ5LmV2ZW50LnJlbW92ZVxuXHRcdFx0XHRcdGlmICggY2FjaGVbIGlkIF0gKSB7XG5cblx0XHRcdFx0XHRcdGRlbGV0ZSBjYWNoZVsgaWQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gSUUgZG9lcyBub3QgYWxsb3cgdXMgdG8gZGVsZXRlIGV4cGFuZG8gcHJvcGVydGllcyBmcm9tIG5vZGVzLFxuXHRcdFx0XHRcdFx0Ly8gbm9yIGRvZXMgaXQgaGF2ZSBhIHJlbW92ZUF0dHJpYnV0ZSBmdW5jdGlvbiBvbiBEb2N1bWVudCBub2Rlcztcblx0XHRcdFx0XHRcdC8vIHdlIG11c3QgaGFuZGxlIGFsbCBvZiB0aGVzZSBjYXNlc1xuXHRcdFx0XHRcdFx0aWYgKCBkZWxldGVFeHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgZWxlbVsgaW50ZXJuYWxLZXkgXTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIGVsZW0ucmVtb3ZlQXR0cmlidXRlICE9PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBpbnRlcm5hbEtleSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbGVtWyBpbnRlcm5hbEtleSBdID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGVsZXRlZElkcy5wdXNoKCBpZCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggKCB0aGlzWzBdICYmIHRoaXNbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApLmNyZWF0ZVRleHROb2RlKCB2YWx1ZSApICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IsIGtlZXBEYXRhIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0ZWxlbXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCB0aGlzICkgOiB0aGlzLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblxuXHRcdFx0aWYgKCAha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdHdoaWxlICggZWxlbS5maXJzdENoaWxkICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUNoaWxkKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHNlbGVjdCwgZW5zdXJlIHRoYXQgaXQgZGlzcGxheXMgZW1wdHkgKCMxMjMzNilcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdGlmICggZWxlbS5vcHRpb25zICYmIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJzZWxlY3RcIiApICkge1xuXHRcdFx0XHRlbGVtLm9wdGlvbnMubGVuZ3RoID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9KTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MLnJlcGxhY2UoIHJpbmxpbmVqUXVlcnksIFwiXCIgKSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0KCBzdXBwb3J0Lmh0bWxTZXJpYWxpemUgfHwgIXJub3NoaW1jYWNoZS50ZXN0KCB2YWx1ZSApICApICYmXG5cdFx0XHRcdCggc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSB8fCAhcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0pWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbaV0gfHwge307XG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoKGUpIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnID0gYXJndW1lbnRzWyAwIF07XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHR0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0YXJnID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXG5cdFx0XHRpZiAoIGFyZyApIHtcblx0XHRcdFx0YXJnLnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRm9yY2UgcmVtb3ZhbCBpZiB0aGVyZSB3YXMgbm8gbmV3IGNvbnRlbnQgKGUuZy4sIGZyb20gZW1wdHkgYXJndW1lbnRzKVxuXHRcdHJldHVybiBhcmcgJiYgKGFyZy5sZW5ndGggfHwgYXJnLm5vZGVUeXBlKSA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRkb21NYW5pcDogZnVuY3Rpb24oIGFyZ3MsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgZmlyc3QsIG5vZGUsIGhhc1NjcmlwdHMsXG5cdFx0XHRzY3JpcHRzLCBkb2MsIGZyYWdtZW50LFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZXQgPSB0aGlzLFxuXHRcdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHRcdHZhbHVlID0gYXJnc1swXSxcblx0XHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRcdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gc2V0LmVxKCBpbmRleCApO1xuXHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdFx0YXJnc1swXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIGNhbGxiYWNrICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIGwgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBhcmdzLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMgKTtcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmaXJzdCApIHtcblx0XHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXNbaV0sIG5vZGUsIGkgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdFx0IWpRdWVyeS5fZGF0YSggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJiBqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoICggbm9kZS50ZXh0IHx8IG5vZGUudGV4dENvbnRlbnQgfHwgbm9kZS5pbm5lckhUTUwgfHwgXCJcIiApLnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGaXggIzExODA5OiBBdm9pZCBsZWFraW5nIG1lbW9yeVxuXHRcdFx0XHRmcmFnbWVudCA9IGZpcnN0ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDE7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUodHJ1ZSk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFtpXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBNb2Rlcm4gYnJvd3NlcnMgY2FuIGFwcGx5IGpRdWVyeSBjb2xsZWN0aW9ucyBhcyBhcnJheXMsIGJ1dCBvbGRJRSBuZWVkcyBhIC5nZXQoKVxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59KTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHt9O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxuICovXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0Ly8gZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgbWlnaHQgYmUgcmVsaWFibHkgdXNlZCBvbmx5IG9uIGF0dGFjaGVkIGVsZW1lbnRcblx0XHRkaXNwbGF5ID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlID9cblxuXHRcdFx0Ly8gVXNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgdGVtcG9yYXJ5IGZpeCAobW9yZSBsaWtlIG9wdG1pemF0aW9uKSB1bnRpbCBzb21ldGhpbmcgYmV0dGVyIGNvbWVzIGFsb25nLFxuXHRcdFx0Ly8gc2luY2UgaXQgd2FzIHJlbW92ZWQgZnJvbSBzcGVjaWZpY2F0aW9uIGFuZCBzdXBwb3J0ZWQgb25seSBpbiBGRlxuXHRcdFx0d2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlKCBlbGVtWyAwIF0gKS5kaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbVsgMCBdLCBcImRpc3BsYXlcIiApO1xuXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxuXHQvLyBzbyB1c2UgXCJkZXRhY2hcIiBtZXRob2QgYXMgZmFzdCB3YXkgdG8gZ2V0IHJpZCBvZiB0aGUgZWxlbWVudFxuXHRlbGVtLmRldGFjaCgpO1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG4vKipcbiAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkoIG5vZGVOYW1lICkge1xuXHR2YXIgZG9jID0gZG9jdW1lbnQsXG5cdFx0ZGlzcGxheSA9IGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdO1xuXG5cdGlmICggIWRpc3BsYXkgKSB7XG5cdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkgKSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxuXHRcdFx0aWZyYW1lID0gKGlmcmFtZSB8fCBqUXVlcnkoIFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiICkpLmFwcGVuZFRvKCBkb2MuZG9jdW1lbnRFbGVtZW50ICk7XG5cblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxuXHRcdFx0ZG9jID0gKCBpZnJhbWVbIDAgXS5jb250ZW50V2luZG93IHx8IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudCApLmRvY3VtZW50O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0ZG9jLndyaXRlKCk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblxuXHRcdFx0ZGlzcGxheSA9IGFjdHVhbERpc3BsYXkoIG5vZGVOYW1lLCBkb2MgKTtcblx0XHRcdGlmcmFtZS5kZXRhY2goKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBhLCBzaHJpbmtXcmFwQmxvY2tzVmFsLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXZSZXNldCA9XG5cdFx0XHRcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcImRpc3BsYXk6YmxvY2s7cGFkZGluZzowO21hcmdpbjowO2JvcmRlcjowXCI7XG5cblx0Ly8gU2V0dXBcblx0ZGl2LmlubmVySFRNTCA9IFwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiYVwiIClbIDAgXTtcblxuXHRhLnN0eWxlLmNzc1RleHQgPSBcImZsb2F0OmxlZnQ7b3BhY2l0eTouNVwiO1xuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGVsZW1lbnQgb3BhY2l0eSBleGlzdHNcblx0Ly8gKElFIHVzZXMgZmlsdGVyIGluc3RlYWQpXG5cdC8vIFVzZSBhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgV2ViS2l0IGlzc3VlLiBTZWUgIzUxNDVcblx0c3VwcG9ydC5vcGFjaXR5ID0gL14wLjUvLnRlc3QoIGEuc3R5bGUub3BhY2l0eSApO1xuXG5cdC8vIFZlcmlmeSBzdHlsZSBmbG9hdCBleGlzdGVuY2Vcblx0Ly8gKElFIHVzZXMgc3R5bGVGbG9hdCBpbnN0ZWFkIG9mIGNzc0Zsb2F0KVxuXHRzdXBwb3J0LmNzc0Zsb2F0ID0gISFhLnN0eWxlLmNzc0Zsb2F0O1xuXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHQvLyBOdWxsIGVsZW1lbnRzIHRvIGF2b2lkIGxlYWtzIGluIElFLlxuXHRhID0gZGl2ID0gbnVsbDtcblxuXHRzdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYm9keSwgY29udGFpbmVyLCBkaXYsIGNvbnRhaW5lclN0eWxlcztcblxuXHRcdGlmICggc2hyaW5rV3JhcEJsb2Nrc1ZhbCA9PSBudWxsICkge1xuXHRcdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImJvZHlcIiApWyAwIF07XG5cdFx0XHRpZiAoICFib2R5ICkge1xuXHRcdFx0XHQvLyBUZXN0IGZpcmVkIHRvbyBlYXJseSBvciBpbiBhbiB1bnN1cHBvcnRlZCBlbnZpcm9ubWVudCwgZXhpdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250YWluZXJTdHlsZXMgPSBcImJvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDotOTk5OXB4XCI7XG5cdFx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdFx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0XHRcdGJvZHkuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdFx0Ly8gV2lsbCBiZSBjaGFuZ2VkIGxhdGVyIGlmIG5lZWRlZC5cblx0XHRcdHNocmlua1dyYXBCbG9ja3NWYWwgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCB0eXBlb2YgZGl2LnN0eWxlLnpvb20gIT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU2XG5cdFx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnRzIHdpdGggbGF5b3V0IHNocmluay13cmFwIHRoZWlyIGNoaWxkcmVuXG5cdFx0XHRcdGRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2UmVzZXQgKyBcIjt3aWR0aDoxcHg7cGFkZGluZzoxcHg7em9vbToxXCI7XG5cdFx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIjxkaXY+PC9kaXY+XCI7XG5cdFx0XHRcdGRpdi5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gXCI1cHhcIjtcblx0XHRcdFx0c2hyaW5rV3JhcEJsb2Nrc1ZhbCA9IGRpdi5vZmZzZXRXaWR0aCAhPT0gMztcblx0XHRcdH1cblxuXHRcdFx0Ym9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUUuXG5cdFx0XHRib2R5ID0gY29udGFpbmVyID0gZGl2ID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2hyaW5rV3JhcEJsb2Nrc1ZhbDtcblx0fTtcblxufSkoKTtcbnZhciBybWFyZ2luID0gKC9ebWFyZ2luLyk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxuXG5cbnZhciBnZXRTdHlsZXMsIGN1ckNTUyxcblx0cnBvc2l0aW9uID0gL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvO1xuXG5pZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0fTtcblxuXHRjdXJDU1MgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdFx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0XHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSBpbiBJRTksIHNlZSAjMTI1Mzdcblx0XHRyZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0XHQvLyBDaHJvbWUgPCAxNyBhbmQgU2FmYXJpIDUuMCB1c2VzIFwiY29tcHV0ZWQgdmFsdWVcIiBpbnN0ZWFkIG9mIFwidXNlZCB2YWx1ZVwiIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdC8vIFNhZmFyaSA1LjEuNyAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuXHRcdFx0Ly8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0dXJuIHJldCA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHJldCA6XG5cdFx0XHRyZXQgKyBcIlwiO1xuXHR9O1xufSBlbHNlIGlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSApIHtcblx0Z2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY3VycmVudFN0eWxlO1xuXHR9O1xuXG5cdGN1ckNTUyA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0XHR2YXIgbGVmdCwgcnMsIHJzTGVmdCwgcmV0LFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRyZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkWyBuYW1lIF0gOiB1bmRlZmluZWQ7XG5cblx0XHQvLyBBdm9pZCBzZXR0aW5nIHJldCB0byBlbXB0eSBzdHJpbmcgaGVyZVxuXHRcdC8vIHNvIHdlIGRvbid0IGRlZmF1bHQgdG8gYXV0b1xuXHRcdGlmICggcmV0ID09IG51bGwgJiYgc3R5bGUgJiYgc3R5bGVbIG5hbWUgXSApIHtcblx0XHRcdHJldCA9IHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gRnJvbSB0aGUgYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1xuXHRcdC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcblxuXHRcdC8vIElmIHdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggYSByZWd1bGFyIHBpeGVsIG51bWJlclxuXHRcdC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuXHRcdC8vIGJ1dCBub3QgcG9zaXRpb24gY3NzIGF0dHJpYnV0ZXMsIGFzIHRob3NlIGFyZSBwcm9wb3J0aW9uYWwgdG8gdGhlIHBhcmVudCBlbGVtZW50IGluc3RlYWRcblx0XHQvLyBhbmQgd2UgY2FuJ3QgbWVhc3VyZSB0aGUgcGFyZW50IGluc3RlYWQgYmVjYXVzZSBpdCBtaWdodCB0cmlnZ2VyIGEgXCJzdGFja2luZyBkb2xsc1wiIHByb2JsZW1cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiAhcnBvc2l0aW9uLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0bGVmdCA9IHN0eWxlLmxlZnQ7XG5cdFx0XHRycyA9IGVsZW0ucnVudGltZVN0eWxlO1xuXHRcdFx0cnNMZWZ0ID0gcnMgJiYgcnMubGVmdDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdHJzLmxlZnQgPSBlbGVtLmN1cnJlbnRTdHlsZS5sZWZ0O1xuXHRcdFx0fVxuXHRcdFx0c3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiByZXQ7XG5cdFx0XHRyZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCI7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdHJzLmxlZnQgPSByc0xlZnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldHVybiByZXQgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRyZXQgOlxuXHRcdFx0cmV0ICsgXCJcIiB8fCBcImF1dG9cIjtcblx0fTtcbn1cblxuXG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29uZGl0aW9uID0gY29uZGl0aW9uRm4oKTtcblxuXHRcdFx0aWYgKCBjb25kaXRpb24gPT0gbnVsbCApIHtcblx0XHRcdFx0Ly8gVGhlIHRlc3Qgd2FzIG5vdCByZWFkeSBhdCB0aGlzIHBvaW50OyBzY3JldyB0aGUgaG9vayB0aGlzIHRpbWVcblx0XHRcdFx0Ly8gYnV0IGNoZWNrIGFnYWluIHdoZW4gbmVlZGVkIG5leHQgdGltZS5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvbmRpdGlvbiApIHtcblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksXG5cdFx0XHRcdC8vIHJlbW92ZSBpdC5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgYXJlIG5vIG90aGVyIGhvb2tzIGZvciBtYXJnaW5SaWdodCwgcmVtb3ZlIHRoZSB3aG9sZSBvYmplY3QuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblxuXHRcdFx0cmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBhLCByZWxpYWJsZUhpZGRlbk9mZnNldHNWYWwsIGJveFNpemluZ1ZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsXG5cdFx0cGl4ZWxQb3NpdGlvblZhbCwgcmVsaWFibGVNYXJnaW5SaWdodFZhbCxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0Y29udGFpbmVyU3R5bGVzID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6LTk5OTlweFwiLFxuXHRcdGRpdlJlc2V0ID1cblx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFwiZGlzcGxheTpibG9jaztwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjBcIjtcblxuXHQvLyBTZXR1cFxuXHRkaXYuaW5uZXJIVE1MID0gXCIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIjtcblx0YSA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJhXCIgKVsgMCBdO1xuXG5cdGEuc3R5bGUuY3NzVGV4dCA9IFwiZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCI7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgZWxlbWVudCBvcGFjaXR5IGV4aXN0c1xuXHQvLyAoSUUgdXNlcyBmaWx0ZXIgaW5zdGVhZClcblx0Ly8gVXNlIGEgcmVnZXggdG8gd29yayBhcm91bmQgYSBXZWJLaXQgaXNzdWUuIFNlZSAjNTE0NVxuXHRzdXBwb3J0Lm9wYWNpdHkgPSAvXjAuNS8udGVzdCggYS5zdHlsZS5vcGFjaXR5ICk7XG5cblx0Ly8gVmVyaWZ5IHN0eWxlIGZsb2F0IGV4aXN0ZW5jZVxuXHQvLyAoSUUgdXNlcyBzdHlsZUZsb2F0IGluc3RlYWQgb2YgY3NzRmxvYXQpXG5cdHN1cHBvcnQuY3NzRmxvYXQgPSAhIWEuc3R5bGUuY3NzRmxvYXQ7XG5cblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUUuXG5cdGEgPSBkaXYgPSBudWxsO1xuXG5cdGpRdWVyeS5leHRlbmQoc3VwcG9ydCwge1xuXHRcdHJlbGlhYmxlSGlkZGVuT2Zmc2V0czogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJlbGlhYmxlSGlkZGVuT2Zmc2V0c1ZhbCAhPSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29udGFpbmVyLCB0ZHMsIGlzU3VwcG9ydGVkLFxuXHRcdFx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0XHRcdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdO1xuXG5cdFx0XHRpZiAoICFib2R5ICkge1xuXHRcdFx0XHQvLyBSZXR1cm4gZm9yIGZyYW1lc2V0IGRvY3MgdGhhdCBkb24ndCBoYXZlIGEgYm9keVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldHVwXG5cdFx0XHRkaXYuc2V0QXR0cmlidXRlKCBcImNsYXNzTmFtZVwiLCBcInRcIiApO1xuXHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cblx0XHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gY29udGFpbmVyU3R5bGVzO1xuXG5cdFx0XHRib2R5LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB0aGV5IGFyZSBzZXRcblx0XHRcdC8vIHRvIGRpc3BsYXk6bm9uZSBhbmQgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHZpc2libGUgdGFibGUgY2VsbHMgaW4gYVxuXHRcdFx0Ly8gdGFibGUgcm93OyBpZiBzbywgb2Zmc2V0V2lkdGgvSGVpZ2h0IGFyZSBub3QgcmVsaWFibGUgZm9yIHVzZSB3aGVuXG5cdFx0XHQvLyBkZXRlcm1pbmluZyBpZiBhbiBlbGVtZW50IGhhcyBiZWVuIGhpZGRlbiBkaXJlY3RseSB1c2luZ1xuXHRcdFx0Ly8gZGlzcGxheTpub25lIChpdCBpcyBzdGlsbCBzYWZlIHRvIHVzZSBvZmZzZXRzIGlmIGEgcGFyZW50IGVsZW1lbnQgaXNcblx0XHRcdC8vIGhpZGRlbjsgZG9uIHNhZmV0eSBnb2dnbGVzIGFuZCBzZWUgYnVnICM0NTEyIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIjx0YWJsZT48dHI+PHRkPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT5cIjtcblx0XHRcdHRkcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0ZFwiICk7XG5cdFx0XHR0ZHNbIDAgXS5zdHlsZS5jc3NUZXh0ID0gXCJwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjA7ZGlzcGxheTpub25lXCI7XG5cdFx0XHRpc1N1cHBvcnRlZCA9ICggdGRzWyAwIF0ub2Zmc2V0SGVpZ2h0ID09PSAwICk7XG5cblx0XHRcdHRkc1sgMCBdLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0dGRzWyAxIF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIENoZWNrIGlmIGVtcHR5IHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0XG5cdFx0XHRyZWxpYWJsZUhpZGRlbk9mZnNldHNWYWwgPSBpc1N1cHBvcnRlZCAmJiAoIHRkc1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMCApO1xuXG5cdFx0XHRib2R5LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdFx0Ly8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRS5cblx0XHRcdGRpdiA9IGJvZHkgPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gcmVsaWFibGVIaWRkZW5PZmZzZXRzVmFsO1xuXHRcdH0sXG5cblx0XHRib3hTaXppbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3hTaXppbmdWYWw7XG5cdFx0fSxcblxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHBpeGVsUG9zaXRpb25WYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBib2R5LCBjb250YWluZXIsIGRpdiwgbWFyZ2luRGl2O1xuXG5cdFx0XHQvLyBVc2Ugd2luZG93LmdldENvbXB1dGVkU3R5bGUgYmVjYXVzZSBqc2RvbSBvbiBub2RlLmpzIHdpbGwgYnJlYWsgd2l0aG91dCBpdC5cblx0XHRcdGlmICggcmVsaWFibGVNYXJnaW5SaWdodFZhbCA9PSBudWxsICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICkge1xuXHRcdFx0XHRib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiYm9keVwiIClbIDAgXTtcblx0XHRcdFx0aWYgKCAhYm9keSApIHtcblx0XHRcdFx0XHQvLyBUZXN0IGZpcmVkIHRvbyBlYXJseSBvciBpbiBhbiB1bnN1cHBvcnRlZCBlbnZpcm9ubWVudCwgZXhpdC5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cdFx0XHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRcdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBjb250YWluZXJTdHlsZXM7XG5cblx0XHRcdFx0Ym9keS5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG5cdFx0XHRcdC8vIEZhaWxzIGluIFdlYktpdCBiZWZvcmUgRmViIDIwMTEgbmlnaHRsaWVzXG5cdFx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2UmVzZXQ7XG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xuXG5cdFx0XHRcdHJlbGlhYmxlTWFyZ2luUmlnaHRWYWwgPVxuXHRcdFx0XHRcdCFwYXJzZUZsb2F0KCAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBtYXJnaW5EaXYsIG51bGwgKSB8fCB7fSApLm1hcmdpblJpZ2h0ICk7XG5cblx0XHRcdFx0Ym9keS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpblJpZ2h0VmFsO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciwgZGl2LFxuXHRcdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcImJvZHlcIiApWyAwIF07XG5cblx0XHRpZiAoICFib2R5ICkge1xuXHRcdFx0Ly8gVGVzdCBmaXJlZCB0b28gZWFybHkgb3IgaW4gYW4gdW5zdXBwb3J0ZWQgZW52aXJvbm1lbnQsIGV4aXQuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGNvbnRhaW5lclN0eWxlcztcblxuXHRcdGJvZHkuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFx0XCJwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6MXB4O2JvcmRlcjoxcHg7d2lkdGg6NHB4O1wiICtcblx0XHRcdFx0XCJtYXJnaW4tdG9wOjElO3RvcDoxJVwiO1xuXG5cdFx0Ly8gV29ya2Fyb3VuZCBmYWlsaW5nIGJveFNpemluZyB0ZXN0IGR1ZSB0byBvZmZzZXRXaWR0aCByZXR1cm5pbmcgd3JvbmcgdmFsdWVcblx0XHQvLyB3aXRoIHNvbWUgbm9uLTEgdmFsdWVzIG9mIGJvZHkgem9vbSwgdGlja2V0ICMxMzU0M1xuXHRcdGpRdWVyeS5zd2FwKCBib2R5LCBib2R5LnN0eWxlLnpvb20gIT0gbnVsbCA/IHsgem9vbTogMSB9IDoge30sIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ym94U2l6aW5nVmFsID0gZGl2Lm9mZnNldFdpZHRoID09PSA0O1xuXHRcdH0pO1xuXG5cdFx0Ly8gV2lsbCBiZSBjaGFuZ2VkIGxhdGVyIGlmIG5lZWRlZC5cblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHRydWU7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGZhbHNlO1xuXHRcdHJlbGlhYmxlTWFyZ2luUmlnaHRWYWwgPSB0cnVlO1xuXG5cdFx0Ly8gVXNlIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIGJlY2F1c2UganNkb20gb24gbm9kZS5qcyB3aWxsIGJyZWFrIHdpdGhvdXQgaXQuXG5cdFx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0XHRcdHBpeGVsUG9zaXRpb25WYWwgPSAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7fSApLnRvcCAhPT0gXCIxJVwiO1xuXHRcdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPVxuXHRcdFx0XHQoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKSB8fCB7IHdpZHRoOiBcIjRweFwiIH0gKS53aWR0aCA9PT0gXCI0cHhcIjtcblx0XHR9XG5cblx0XHRib2R5LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGwgZWxlbWVudHMgdG8gYXZvaWQgbGVha3MgaW4gSUUuXG5cdFx0ZGl2ID0gYm9keSA9IG51bGw7XG5cdH1cblxufSkoKTtcblxuXG4vLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLlxualF1ZXJ5LnN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXJcblx0XHRyYWxwaGEgPSAvYWxwaGFcXChbXildKlxcKS9pLFxuXHRyb3BhY2l0eSA9IC9vcGFjaXR5XFxzKj1cXHMqKFteKV0qKS8sXG5cblx0Ly8gc3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gc2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cm51bXNwbGl0ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSguKikkXCIsIFwiaVwiICksXG5cdHJyZWxOdW0gPSBuZXcgUmVnRXhwKCBcIl4oWystXSk9KFwiICsgcG51bSArIFwiKVwiLCBcImlcIiApLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogMCxcblx0XHRmb250V2VpZ2h0OiA0MDBcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdO1xuXG5cbi8vIHJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBzdHlsZSwgbmFtZSApIHtcblxuXHQvLyBzaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBjaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG5cdFx0b3JpZ05hbWUgPSBuYW1lLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvcmlnTmFtZTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGRlZmF1bHREaXNwbGF5KGVsZW0ubm9kZU5hbWUpICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZGlzcGxheSAmJiBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggZWxlbSwgXCJvbGRkaXNwbGF5XCIsIGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblx0dmFyIG1hdGNoZXMgPSBybnVtc3BsaXQuZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDEgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDIgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblx0XHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG5cdFx0bmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cblx0XHR2YWwgPSAwO1xuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblx0XHQvLyBib3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXHR2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsXG5cdFx0dmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdGlzQm9yZGVyQm94ID0gc3VwcG9ydC5ib3hTaXppbmcoKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIHNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KHZhbCkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIHdlIG5lZWQgdGhlIGNoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJiAoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyB1c2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0Ly8gbm9ybWFsaXplIGZsb2F0IGNzcyBwcm9wZXJ0eVxuXHRcdFwiZmxvYXRcIjogc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIGdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBjb252ZXJ0IHJlbGF0aXZlIG51bWJlciBzdHJpbmdzICgrPSBvciAtPSkgdG8gcmVsYXRpdmUgbnVtYmVycy4gIzczNDVcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAocmV0ID0gcnJlbE51bS5leGVjKCB2YWx1ZSApKSApIHtcblx0XHRcdFx0dmFsdWUgPSAoIHJldFsxXSArIDEgKSAqIHJldFsyXSArIHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKSApO1xuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldC4gU2VlOiAjNzExNlxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgJ3B4JyB0byB0aGUgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSApIHtcblx0XHRcdFx0dmFsdWUgKz0gXCJweFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaXhlcyAjODkwOCwgaXQgY2FuIGJlIGRvbmUgbW9yZSBjb3JyZWN0bHkgYnkgc3BlY2lmaW5nIHNldHRlcnMgaW4gY3NzSG9va3MsXG5cdFx0XHQvLyBidXQgaXQgd291bGQgbWVhbiB0byBkZWZpbmUgZWlnaHQgKGZvciBldmVyeSBwcm9ibGVtYXRpYyBwcm9wZXJ0eSkgaWRlbnRpY2FsIGZ1bmN0aW9uc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKFwiYmFja2dyb3VuZFwiKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRVxuXHRcdFx0XHQvLyBTd2FsbG93IGVycm9ycyBmcm9tICdpbnZhbGlkJyBDU1MgdmFsdWVzICgjNTUwOSlcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUsIFNhZmFyaVxuXHRcdFx0XHRcdC8vIFNldHRpbmcgc3R5bGUgdG8gYmxhbmsgc3RyaW5nIHJlcXVpcmVkIHRvIGRlbGV0ZSBcInN0eWxlOiB4ICFpbXBvcnRhbnQ7XCJcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJcIjtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciBudW0sIHZhbCwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggZWxlbS5zdHlsZSwgb3JpZ05hbWUgKSApO1xuXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxuXHRcdC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly9jb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiwgY29udmVydGluZyB0byBudW1iZXIgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgalF1ZXJ5LmlzTnVtZXJpYyggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHQvLyBjZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXNcblx0XHRcdFx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgJiYgcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5LnN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIGV4dHJhID9cblx0XHRcdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdHN1cHBvcnQuYm94U2l6aW5nKCkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KSA6IDBcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufSk7XG5cbmlmICggIXN1cHBvcnQub3BhY2l0eSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzLm9wYWNpdHkgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHQvLyBJRSB1c2VzIGZpbHRlcnMgZm9yIG9wYWNpdHlcblx0XHRcdHJldHVybiByb3BhY2l0eS50ZXN0KCAoY29tcHV0ZWQgJiYgZWxlbS5jdXJyZW50U3R5bGUgPyBlbGVtLmN1cnJlbnRTdHlsZS5maWx0ZXIgOiBlbGVtLnN0eWxlLmZpbHRlcikgfHwgXCJcIiApID9cblx0XHRcdFx0KCAwLjAxICogcGFyc2VGbG9hdCggUmVnRXhwLiQxICkgKSArIFwiXCIgOlxuXHRcdFx0XHRjb21wdXRlZCA/IFwiMVwiIDogXCJcIjtcblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdFx0XHRjdXJyZW50U3R5bGUgPSBlbGVtLmN1cnJlbnRTdHlsZSxcblx0XHRcdFx0b3BhY2l0eSA9IGpRdWVyeS5pc051bWVyaWMoIHZhbHVlICkgPyBcImFscGhhKG9wYWNpdHk9XCIgKyB2YWx1ZSAqIDEwMCArIFwiKVwiIDogXCJcIixcblx0XHRcdFx0ZmlsdGVyID0gY3VycmVudFN0eWxlICYmIGN1cnJlbnRTdHlsZS5maWx0ZXIgfHwgc3R5bGUuZmlsdGVyIHx8IFwiXCI7XG5cblx0XHRcdC8vIElFIGhhcyB0cm91YmxlIHdpdGggb3BhY2l0eSBpZiBpdCBkb2VzIG5vdCBoYXZlIGxheW91dFxuXHRcdFx0Ly8gRm9yY2UgaXQgYnkgc2V0dGluZyB0aGUgem9vbSBsZXZlbFxuXHRcdFx0c3R5bGUuem9vbSA9IDE7XG5cblx0XHRcdC8vIGlmIHNldHRpbmcgb3BhY2l0eSB0byAxLCBhbmQgbm8gb3RoZXIgZmlsdGVycyBleGlzdCAtIGF0dGVtcHQgdG8gcmVtb3ZlIGZpbHRlciBhdHRyaWJ1dGUgIzY2NTJcblx0XHRcdC8vIGlmIHZhbHVlID09PSBcIlwiLCB0aGVuIHJlbW92ZSBpbmxpbmUgb3BhY2l0eSAjMTI2ODVcblx0XHRcdGlmICggKCB2YWx1ZSA+PSAxIHx8IHZhbHVlID09PSBcIlwiICkgJiZcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgXCJcIiApICkgPT09IFwiXCIgJiZcblx0XHRcdFx0XHRzdHlsZS5yZW1vdmVBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0Ly8gU2V0dGluZyBzdHlsZS5maWx0ZXIgdG8gbnVsbCwgXCJcIiAmIFwiIFwiIHN0aWxsIGxlYXZlIFwiZmlsdGVyOlwiIGluIHRoZSBjc3NUZXh0XG5cdFx0XHRcdC8vIGlmIFwiZmlsdGVyOlwiIGlzIHByZXNlbnQgYXQgYWxsLCBjbGVhclR5cGUgaXMgZGlzYWJsZWQsIHdlIHdhbnQgdG8gYXZvaWQgdGhpc1xuXHRcdFx0XHQvLyBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUgaXMgSUUgT25seSwgYnV0IHNvIGFwcGFyZW50bHkgaXMgdGhpcyBjb2RlIHBhdGguLi5cblx0XHRcdFx0c3R5bGUucmVtb3ZlQXR0cmlidXRlKCBcImZpbHRlclwiICk7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgbm8gZmlsdGVyIHN0eWxlIGFwcGxpZWQgaW4gYSBjc3MgcnVsZSBvciB1bnNldCBpbmxpbmUgb3BhY2l0eSwgd2UgYXJlIGRvbmVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiB8fCBjdXJyZW50U3R5bGUgJiYgIWN1cnJlbnRTdHlsZS5maWx0ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSwgc2V0IG5ldyBmaWx0ZXIgdmFsdWVzXG5cdFx0XHRzdHlsZS5maWx0ZXIgPSByYWxwaGEudGVzdCggZmlsdGVyICkgP1xuXHRcdFx0XHRmaWx0ZXIucmVwbGFjZSggcmFscGhhLCBvcGFjaXR5ICkgOlxuXHRcdFx0XHRmaWx0ZXIgKyBcIiBcIiArIG9wYWNpdHk7XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcblx0XHRcdC8vIFdvcmsgYXJvdW5kIGJ5IHRlbXBvcmFyaWx5IHNldHRpbmcgZWxlbWVudCBkaXNwbGF5IHRvIGlubGluZS1ibG9ja1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5zd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goe1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gYXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoXCIgXCIpIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IFwic3dpbmdcIjtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdGlmICggdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiZcblx0XHRcdFx0KCF0d2Vlbi5lbGVtLnN0eWxlIHx8IHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsKSApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzXG5cdFx0XHQvLyBzbywgc2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQuXG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzIGlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0Ly8gdXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQgLSB1c2UgY3NzSG9vayBpZiBpdHMgdGhlcmUgLSB1c2UgLnN0eWxlIGlmIGl0c1xuXHRcdFx0Ly8gYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGVcblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0uc3R5bGUgJiYgKCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHwgalF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fVxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRyZnhudW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLyxcblx0YW5pbWF0aW9uUHJlZmlsdGVycyA9IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXHR0d2VlbmVycyA9IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApLFxuXHRcdFx0XHR0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcblx0XHRcdFx0cGFydHMgPSByZnhudW0uZXhlYyggdmFsdWUgKSxcblx0XHRcdFx0dW5pdCA9IHBhcnRzICYmIHBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHRcdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRcdFx0c3RhcnQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK3RhcmdldCApICYmXG5cdFx0XHRcdFx0cmZ4bnVtLmV4ZWMoIGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHByb3AgKSApLFxuXHRcdFx0XHRzY2FsZSA9IDEsXG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAyMDtcblxuXHRcdFx0aWYgKCBzdGFydCAmJiBzdGFydFsgMyBdICE9PSB1bml0ICkge1xuXHRcdFx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0XHRcdHVuaXQgPSB1bml0IHx8IHN0YXJ0WyAzIF07XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdFx0XHRwYXJ0cyA9IHBhcnRzIHx8IFtdO1xuXG5cdFx0XHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0XHRcdHN0YXJ0ID0gK3RhcmdldCB8fCAxO1xuXG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKlxuXHRcdFx0XHRcdC8vIFVzZSBhIHN0cmluZyBmb3IgZG91YmxpbmcgZmFjdG9yIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRcdFx0c3RhcnQgPSBzdGFydCAvIHNjYWxlO1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0ICk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKClcblx0XHRcdFx0Ly8gQW5kIGJyZWFraW5nIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2hcblx0XHRcdFx0fSB3aGlsZSAoIHNjYWxlICE9PSAoc2NhbGUgPSB0d2Vlbi5jdXIoKSAvIHRhcmdldCkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0d2VlbiBwcm9wZXJ0aWVzXG5cdFx0XHRpZiAoIHBhcnRzICkge1xuXHRcdFx0XHRzdGFydCA9IHR3ZWVuLnN0YXJ0ID0gK3N0YXJ0IHx8ICt0YXJnZXQgfHwgMDtcblx0XHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHRcdC8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvblxuXHRcdFx0XHR0d2Vlbi5lbmQgPSBwYXJ0c1sgMSBdID9cblx0XHRcdFx0XHRzdGFydCArICggcGFydHNbIDEgXSArIDEgKSAqIHBhcnRzWyAyIF0gOlxuXHRcdFx0XHRcdCtwYXJ0c1sgMiBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH07XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9KTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH0sXG5cdFx0aSA9IDA7XG5cblx0Ly8gaWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBpZiB3ZSBkb24ndCBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0IDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIHR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIHR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkpICkge1xuXG5cdFx0XHQvLyB3ZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBkRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGpRdWVyeS5fZGF0YSggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIGhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZG9pbmcgdGhpcyBtYWtlcyBzdXJlIHRoYXQgdGhlIGNvbXBsZXRlIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWRcblx0XHRcdC8vIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBoZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xuXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcyApICkge1xuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0ZERpc3BsYXkgPSBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRkaXNwbGF5ID0gZERpc3BsYXk7XG5cdFx0fVxuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdC8vIGlubGluZS1sZXZlbCBlbGVtZW50cyBhY2NlcHQgaW5saW5lLWJsb2NrO1xuXHRcdFx0Ly8gYmxvY2stbGV2ZWwgZWxlbWVudHMgbmVlZCB0byBiZSBpbmxpbmUgd2l0aCBsYXlvdXRcblx0XHRcdGlmICggIXN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCB8fCBkRGlzcGxheSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHlsZS56b29tID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGlmICggIXN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcygpICkge1xuXHRcdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIHNob3cvaGlkZSBwYXNzXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvdyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGFTaG93ID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIHN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGpRdWVyeS5fcmVtb3ZlRGF0YSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gbm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbnQgb3ZlcndyaXRlIGtleXMgYWxyZWFkeSBwcmVzZW50LlxuXHRcdFx0Ly8gYWxzbyAtIHJldXNpbmcgJ2luZGV4JyBmcm9tIGFib3ZlIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gZG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0pLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXHRcdFx0XHQvLyBhcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgMSAtICggMC41IHx8IDAgKSAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRcdC8vIGlmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWVcblx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0pLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gYW5pbWF0aW9uUHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0pXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0gPSB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gbm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gc2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gYW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGpRdWVyeS5fZGF0YSggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0galF1ZXJ5Ll9kYXRhKCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSkgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWRcblx0XHRcdC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXG5cdFx0XHQvLyBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZFxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuX2RhdGEoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gZW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBlbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGxvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaChbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCh7XG5cdHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxuXHRzbGlkZVVwOiBnZW5GeChcImhpZGVcIiksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59KTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0aSA9IDA7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0Y2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0pO1xufTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBhLCBpbnB1dCwgc2VsZWN0LCBvcHQsXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiICk7XG5cblx0Ly8gU2V0dXBcblx0ZGl2LnNldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiwgXCJ0XCIgKTtcblx0ZGl2LmlubmVySFRNTCA9IFwiICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWyAwIF07XG5cblx0Ly8gRmlyc3QgYmF0Y2ggb2YgdGVzdHMuXG5cdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG5cdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSApO1xuXHRpbnB1dCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWyAwIF07XG5cblx0YS5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6MXB4XCI7XG5cblx0Ly8gVGVzdCBzZXRBdHRyaWJ1dGUgb24gY2FtZWxDYXNlIGNsYXNzLiBJZiBpdCB3b3Jrcywgd2UgbmVlZCBhdHRyRml4ZXMgd2hlbiBkb2luZyBnZXQvc2V0QXR0cmlidXRlIChpZTYvNylcblx0c3VwcG9ydC5nZXRTZXRBdHRyaWJ1dGUgPSBkaXYuY2xhc3NOYW1lICE9PSBcInRcIjtcblxuXHQvLyBHZXQgdGhlIHN0eWxlIGluZm9ybWF0aW9uIGZyb20gZ2V0QXR0cmlidXRlXG5cdC8vIChJRSB1c2VzIC5jc3NUZXh0IGluc3RlYWQpXG5cdHN1cHBvcnQuc3R5bGUgPSAvdG9wLy50ZXN0KCBhLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpICk7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgVVJMcyBhcmVuJ3QgbWFuaXB1bGF0ZWRcblx0Ly8gKElFIG5vcm1hbGl6ZXMgaXQgYnkgZGVmYXVsdClcblx0c3VwcG9ydC5ocmVmTm9ybWFsaXplZCA9IGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIvYVwiO1xuXG5cdC8vIENoZWNrIHRoZSBkZWZhdWx0IGNoZWNrYm94L3JhZGlvIHZhbHVlIChcIlwiIG9uIFdlYktpdDsgXCJvblwiIGVsc2V3aGVyZSlcblx0c3VwcG9ydC5jaGVja09uID0gISFpbnB1dC52YWx1ZTtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhIHNlbGVjdGVkLWJ5LWRlZmF1bHQgb3B0aW9uIGhhcyBhIHdvcmtpbmcgc2VsZWN0ZWQgcHJvcGVydHkuXG5cdC8vIChXZWJLaXQgZGVmYXVsdHMgdG8gZmFsc2UgaW5zdGVhZCBvZiB0cnVlLCBJRSB0b28sIGlmIGl0J3MgaW4gYW4gb3B0Z3JvdXApXG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gVGVzdHMgZm9yIGVuY3R5cGUgc3VwcG9ydCBvbiBhIGZvcm0gKCM2NzQzKVxuXHRzdXBwb3J0LmVuY3R5cGUgPSAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLmVuY3R5cGU7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIG9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlbid0IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHQvLyAoV2ViS2l0IG1hcmtzIHRoZW0gYXMgZGlzYWJsZWQpXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFOCBvbmx5XG5cdC8vIENoZWNrIGlmIHdlIGNhbiB0cnVzdCBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRzdXBwb3J0LmlucHV0ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcblxuXHQvLyBDaGVjayBpZiBhbiBpbnB1dCBtYWludGFpbnMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcblxuXHQvLyBOdWxsIGVsZW1lbnRzIHRvIGF2b2lkIGxlYWtzIGluIElFLlxuXHRhID0gaW5wdXQgPSBzZWxlY3QgPSBvcHQgPSBkaXYgPSBudWxsO1xufSkoKTtcblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdC8vIGhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXHRcdFx0XHRcdGpRdWVyeS50ZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIG9sZElFIGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT09IG51bGwgKSAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTZcblx0XHRcdFx0XHRcdC8vIFdoZW4gbmV3IG9wdGlvbiBlbGVtZW50IGlzIGFkZGVkIHRvIHNlbGVjdCBib3ggd2UgbmVlZCB0b1xuXHRcdFx0XHRcdFx0Ly8gZm9yY2UgcmVmbG93IG9mIG5ld2x5IGFkZGVkIG5vZGUgaW4gb3JkZXIgdG8gd29ya2Fyb3VuZCBkZWxheVxuXHRcdFx0XHRcdFx0Ly8gb2YgaW5pdGlhbGl6YXRpb24gcHJvcGVydGllc1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uU2V0ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIF8gKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gV2lsbCBiZSBleGVjdXRlZCBvbmx5IGluIElFNlxuXHRcdFx0XHRcdFx0XHRvcHRpb24uc2Nyb2xsSGVpZ2h0O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBvcHRpb25zO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2Via2l0XG5cdFx0XHQvLyBcIlwiIGlzIHJldHVybmVkIGluc3RlYWQgb2YgXCJvblwiIGlmIGEgdmFsdWUgaXNuJ3Qgc3BlY2lmaWVkXG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbnZhciBub2RlSG9vaywgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlLFxuXHRydXNlRGVmYXVsdCA9IC9eKD86Y2hlY2tlZHxzZWxlY3RlZCkkL2ksXG5cdGdldFNldEF0dHJpYnV0ZSA9IHN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLFxuXHRnZXRTZXRJbnB1dCA9IHN1cHBvcnQuaW5wdXQ7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIGRvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IHN0cnVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IG5vZGVIb29rICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgP1xuXHRcdFx0XHR1bmRlZmluZWQgOlxuXHRcdFx0XHRyZXQ7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSwgcHJvcE5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoIChuYW1lID0gYXR0ck5hbWVzW2krK10pICkge1xuXHRcdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblxuXHRcdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50ICgjMTA4NzApXG5cdFx0XHRcdGlmICggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2Vcblx0XHRcdFx0XHRpZiAoIGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSB8fCAhcnVzZURlZmF1bHQudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHRcdFx0XHQvLyBBbHNvIGNsZWFyIGRlZmF1bHRDaGVja2VkL2RlZmF1bHRTZWxlY3RlZCAoaWYgYXBwcm9wcmlhdGUpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsZW1bIGpRdWVyeS5jYW1lbENhc2UoIFwiZGVmYXVsdC1cIiArIG5hbWUgKSBdID1cblx0XHRcdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZWUgIzk2OTkgZm9yIGV4cGxhbmF0aW9uIG9mIHRoaXMgYXBwcm9hY2ggKHNldHRpbmcgZmlyc3QsIHRoZW4gcmVtb3ZhbClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRqUXVlcnkuYXR0ciggZWxlbSwgbmFtZSwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGdldFNldEF0dHJpYnV0ZSA/IG5hbWUgOiBwcm9wTmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiYgalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwiaW5wdXRcIikgKSB7XG5cdFx0XHRcdFx0Ly8gU2V0dGluZyB0aGUgdHlwZSBvbiBhIHJhZGlvIGJ1dHRvbiBhZnRlciB0aGUgdmFsdWUgcmVzZXRzIHRoZSB2YWx1ZSBpbiBJRTYtOVxuXHRcdFx0XHRcdC8vIFJlc2V0IHZhbHVlIHRvIGRlZmF1bHQgaW4gY2FzZSB0eXBlIGlzIHNldCBhZnRlciB2YWx1ZSBkdXJpbmcgY3JlYXRpb25cblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIb29rIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIGlmICggZ2V0U2V0SW5wdXQgJiYgZ2V0U2V0QXR0cmlidXRlIHx8ICFydXNlRGVmYXVsdC50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHQvLyBJRTw4IG5lZWRzIHRoZSAqcHJvcGVydHkqIG5hbWVcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCAhZ2V0U2V0QXR0cmlidXRlICYmIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSwgbmFtZSApO1xuXG5cdFx0Ly8gVXNlIGRlZmF1bHRDaGVja2VkIGFuZCBkZWZhdWx0U2VsZWN0ZWQgZm9yIG9sZElFXG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1bIGpRdWVyeS5jYW1lbENhc2UoIFwiZGVmYXVsdC1cIiArIG5hbWUgKSBdID0gZWxlbVsgbmFtZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxuLy8gUmV0cmlldmUgYm9vbGVhbnMgc3BlY2lhbGx5XG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGdldFNldElucHV0ICYmIGdldFNldEF0dHJpYnV0ZSB8fCAhcnVzZURlZmF1bHQudGVzdCggbmFtZSApID9cblx0XHRmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG5cdFx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDtcblx0XHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gaGFuZGxlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1bIGpRdWVyeS5jYW1lbENhc2UoIFwiZGVmYXVsdC1cIiArIG5hbWUgKSBdID9cblx0XHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcbn0pO1xuXG4vLyBmaXggb2xkSUUgYXR0cm9wZXJ0aWVzXG5pZiAoICFnZXRTZXRJbnB1dCB8fCAhZ2V0U2V0QXR0cmlidXRlICkge1xuXHRqUXVlcnkuYXR0ckhvb2tzLnZhbHVlID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHQvLyBEb2VzIG5vdCByZXR1cm4gc28gdGhhdCBzZXRBdHRyaWJ1dGUgaXMgYWxzbyB1c2VkXG5cdFx0XHRcdGVsZW0uZGVmYXVsdFZhbHVlID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBVc2Ugbm9kZUhvb2sgaWYgZGVmaW5lZCAoIzE5NTQpOyBvdGhlcndpc2Ugc2V0QXR0cmlidXRlIGlzIGZpbmVcblx0XHRcdFx0cmV0dXJuIG5vZGVIb29rICYmIG5vZGVIb29rLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIElFNi83IGRvIG5vdCBzdXBwb3J0IGdldHRpbmcvc2V0dGluZyBzb21lIGF0dHJpYnV0ZXMgd2l0aCBnZXQvc2V0QXR0cmlidXRlXG5pZiAoICFnZXRTZXRBdHRyaWJ1dGUgKSB7XG5cblx0Ly8gVXNlIHRoaXMgZm9yIGFueSBhdHRyaWJ1dGUgaW4gSUU2Lzdcblx0Ly8gVGhpcyBmaXhlcyBhbG1vc3QgZXZlcnkgSUU2LzcgaXNzdWVcblx0bm9kZUhvb2sgPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0XHQvLyBTZXQgdGhlIGV4aXN0aW5nIG9yIGNyZWF0ZSBhIG5ldyBhdHRyaWJ1dGUgbm9kZVxuXHRcdFx0dmFyIHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xuXHRcdFx0aWYgKCAhcmV0ICkge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZU5vZGUoXG5cdFx0XHRcdFx0KHJldCA9IGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUoIG5hbWUgKSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0LnZhbHVlID0gdmFsdWUgKz0gXCJcIjtcblxuXHRcdFx0Ly8gQnJlYWsgYXNzb2NpYXRpb24gd2l0aCBjbG9uZWQgZWxlbWVudHMgYnkgYWxzbyB1c2luZyBzZXRBdHRyaWJ1dGUgKCM5NjQ2KVxuXHRcdFx0aWYgKCBuYW1lID09PSBcInZhbHVlXCIgfHwgdmFsdWUgPT09IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gU29tZSBhdHRyaWJ1dGVzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoIGVtcHR5LXN0cmluZyB2YWx1ZXMgd2hlbiBub3QgZGVmaW5lZFxuXHRhdHRySGFuZGxlLmlkID0gYXR0ckhhbmRsZS5uYW1lID0gYXR0ckhhbmRsZS5jb29yZHMgPVxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRcdHZhciByZXQ7XG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdFx0cmV0dXJuIChyZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgcmV0LnZhbHVlICE9PSBcIlwiID9cblx0XHRcdFx0XHRyZXQudmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHQvLyBGaXhpbmcgdmFsdWUgcmV0cmlldmFsIG9uIGEgYnV0dG9uIHJlcXVpcmVzIHRoaXMgbW9kdWxlXG5cdGpRdWVyeS52YWxIb29rcy5idXR0b24gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRcdHZhciByZXQgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKTtcblx0XHRcdGlmICggcmV0ICYmIHJldC5zcGVjaWZpZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQudmFsdWU7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZXQ6IG5vZGVIb29rLnNldFxuXHR9O1xuXG5cdC8vIFNldCBjb250ZW50ZWRpdGFibGUgdG8gZmFsc2Ugb24gcmVtb3ZhbHMoIzEwNDI5KVxuXHQvLyBTZXR0aW5nIHRvIGVtcHR5IHN0cmluZyB0aHJvd3MgYW4gZXJyb3IgYXMgYW4gaW52YWxpZCB2YWx1ZVxuXHRqUXVlcnkuYXR0ckhvb2tzLmNvbnRlbnRlZGl0YWJsZSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdG5vZGVIb29rLnNldCggZWxlbSwgdmFsdWUgPT09IFwiXCIgPyBmYWxzZSA6IHZhbHVlLCBuYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFNldCB3aWR0aCBhbmQgaGVpZ2h0IHRvIGF1dG8gaW5zdGVhZCBvZiAwIG9uIGVtcHR5IHN0cmluZyggQnVnICM4MTUwIClcblx0Ly8gVGhpcyBpcyBmb3IgcmVtb3ZhbHNcblx0alF1ZXJ5LmVhY2goWyBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0alF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdID0ge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIFwiYXV0b1wiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59XG5cbmlmICggIXN1cHBvcnQuc3R5bGUgKSB7XG5cdGpRdWVyeS5hdHRySG9va3Muc3R5bGUgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIFJldHVybiB1bmRlZmluZWQgaW4gdGhlIGNhc2Ugb2YgZW1wdHkgc3RyaW5nXG5cdFx0XHQvLyBOb3RlOiBJRSB1cHBlcmNhc2VzIGNzcyBwcm9wZXJ0eSBuYW1lcywgYnV0IGlmIHdlIHdlcmUgdG8gLnRvTG93ZXJDYXNlKClcblx0XHRcdC8vIC5jc3NUZXh0LCB0aGF0IHdvdWxkIGRlc3Ryb3kgY2FzZSBzZW5zdGl0aXZpdHkgaW4gVVJMJ3MsIGxpa2UgaW4gXCJiYWNrZ3JvdW5kXCJcblx0XHRcdHJldHVybiBlbGVtLnN0eWxlLmNzc1RleHQgfHwgdW5kZWZpbmVkO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtLnN0eWxlLmNzc1RleHQgPSB2YWx1ZSArIFwiXCIgKTtcblx0XHR9XG5cdH07XG59XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdCkkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdC8vIHRyeS9jYXRjaCBoYW5kbGVzIGNhc2VzIHdoZXJlIElFIGJhbGtzIChzdWNoIGFzIHJlbW92aW5nIGEgcHJvcGVydHkgb24gd2luZG93KVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpc1sgbmFtZSBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRkZWxldGUgdGhpc1sgbmFtZSBdO1xuXHRcdFx0fSBjYXRjaCggZSApIHt9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9LFxuXG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcywgbm90eG1sLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm90eG1sID0gblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApO1xuXG5cdFx0aWYgKCBub3R4bWwgKSB7XG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJldCA6XG5cdFx0XHRcdCggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsID9cblx0XHRcdFx0cmV0IDpcblx0XHRcdFx0ZWxlbVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgcmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gU29tZSBhdHRyaWJ1dGVzIHJlcXVpcmUgYSBzcGVjaWFsIGNhbGwgb24gSUVcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIXN1cHBvcnQuaHJlZk5vcm1hbGl6ZWQgKSB7XG5cdC8vIGhyZWYvc3JjIHByb3BlcnR5IHNob3VsZCBnZXQgdGhlIGZ1bGwgbm9ybWFsaXplZCBVUkwgKCMxMDI5OS8jMTI5MTUpXG5cdGpRdWVyeS5lYWNoKFsgXCJocmVmXCIsIFwic3JjXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0alF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCA0ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSwgSUU5K1xuLy8gbWlzLXJlcG9ydHMgdGhlIGRlZmF1bHQgc2VsZWN0ZWQgcHJvcGVydHkgb2YgYW4gb3B0aW9uXG4vLyBBY2Nlc3NpbmcgdGhlIHBhcmVudCdzIHNlbGVjdGVkSW5kZXggcHJvcGVydHkgZml4ZXMgaXRcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBpdCBhbHNvIHdvcmtzIHdpdGggb3B0Z3JvdXBzLCBzZWUgIzU3MDFcblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59KTtcblxuLy8gSUU2LzcgY2FsbCBlbmN0eXBlIGVuY29kaW5nXG5pZiAoICFzdXBwb3J0LmVuY3R5cGUgKSB7XG5cdGpRdWVyeS5wcm9wRml4LmVuY3R5cGUgPSBcImVuY29kaW5nXCI7XG59XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cHJvY2VlZCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9jZWVkICkge1xuXHRcdFx0Ly8gVGhlIGRpc2p1bmN0aW9uIGhlcmUgaXMgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSByZW1vdmVDbGFzcylcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIiBcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRwcm9jZWVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWU7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lICkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XG5cdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gdmFsdWUgPyBqUXVlcnkudHJpbSggY3VyICkgOiBcIlwiO1xuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gdG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoIChjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSkgKSB7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHN0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHQvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIFwiZmFsc2VcIixcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHR0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/IFwiXCIgOiBqUXVlcnkuX2RhdGEoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIjtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRpZiAoIHRoaXNbaV0ubm9kZVR5cGUgPT09IDEgJiYgKFwiIFwiICsgdGhpc1tpXS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShyY2xhc3MsIFwiIFwiKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxualF1ZXJ5LmVhY2goIChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiKS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH0sXG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDogdGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0pO1xuXG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICgvXFw/Lyk7XG5cblxuXG52YXIgcnZhbGlkdG9rZW5zID0gLygsKXwoXFxbfHspfCh9fF0pfFwiKD86W15cIlxcXFxcXHJcXG5dfFxcXFxbXCJcXFxcXFwvYmZucnRdfFxcXFx1W1xcZGEtZkEtRl17NH0pKlwiXFxzKjo/fHRydWV8ZmFsc2V8bnVsbHwtPyg/ITBcXGQpXFxkKyg/OlxcLlxcZCt8KSg/OltlRV1bKy1dP1xcZCt8KS9nO1xuXG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuXHRpZiAoIHdpbmRvdy5KU09OICYmIHdpbmRvdy5KU09OLnBhcnNlICkge1xuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0Ly8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcblx0XHRyZXR1cm4gd2luZG93LkpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG5cdH1cblxuXHR2YXIgcmVxdWlyZU5vbkNvbW1hLFxuXHRcdGRlcHRoID0gbnVsbCxcblx0XHRzdHIgPSBqUXVlcnkudHJpbSggZGF0YSArIFwiXCIgKTtcblxuXHQvLyBHdWFyZCBhZ2FpbnN0IGludmFsaWQgKGFuZCBwb3NzaWJseSBkYW5nZXJvdXMpIGlucHV0IGJ5IGVuc3VyaW5nIHRoYXQgbm90aGluZyByZW1haW5zXG5cdC8vIGFmdGVyIHJlbW92aW5nIHZhbGlkIHRva2Vuc1xuXHRyZXR1cm4gc3RyICYmICFqUXVlcnkudHJpbSggc3RyLnJlcGxhY2UoIHJ2YWxpZHRva2VucywgZnVuY3Rpb24oIHRva2VuLCBjb21tYSwgb3BlbiwgY2xvc2UgKSB7XG5cblx0XHQvLyBGb3JjZSB0ZXJtaW5hdGlvbiBpZiB3ZSBzZWUgYSBtaXNwbGFjZWQgY29tbWFcblx0XHRpZiAoIHJlcXVpcmVOb25Db21tYSAmJiBjb21tYSApIHtcblx0XHRcdGRlcHRoID0gMDtcblx0XHR9XG5cblx0XHQvLyBQZXJmb3JtIG5vIG1vcmUgcmVwbGFjZW1lbnRzIGFmdGVyIHJldHVybmluZyB0byBvdXRlcm1vc3QgZGVwdGhcblx0XHRpZiAoIGRlcHRoID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHRva2VuO1xuXHRcdH1cblxuXHRcdC8vIENvbW1hcyBtdXN0IG5vdCBmb2xsb3cgXCJbXCIsIFwie1wiLCBvciBcIixcIlxuXHRcdHJlcXVpcmVOb25Db21tYSA9IG9wZW4gfHwgY29tbWE7XG5cblx0XHQvLyBEZXRlcm1pbmUgbmV3IGRlcHRoXG5cdFx0Ly8gYXJyYXkvb2JqZWN0IG9wZW4gKFwiW1wiIG9yIFwie1wiKTogZGVwdGggKz0gdHJ1ZSAtIGZhbHNlIChpbmNyZW1lbnQpXG5cdFx0Ly8gYXJyYXkvb2JqZWN0IGNsb3NlIChcIl1cIiBvciBcIn1cIik6IGRlcHRoICs9IGZhbHNlIC0gdHJ1ZSAoZGVjcmVtZW50KVxuXHRcdC8vIG90aGVyIGNhc2VzIChcIixcIiBvciBwcmltaXRpdmUpOiBkZXB0aCArPSB0cnVlIC0gdHJ1ZSAobnVtZXJpYyBjYXN0KVxuXHRcdGRlcHRoICs9ICFjbG9zZSAtICFvcGVuO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoaXMgdG9rZW5cblx0XHRyZXR1cm4gXCJcIjtcblx0fSkgKSA/XG5cdFx0KCBGdW5jdGlvbiggXCJyZXR1cm4gXCIgKyBzdHIgKSApKCkgOlxuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIEpTT046IFwiICsgZGF0YSApO1xufTtcblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgdG1wO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHRyeSB7XG5cdFx0aWYgKCB3aW5kb3cuRE9NUGFyc2VyICkgeyAvLyBTdGFuZGFyZFxuXHRcdFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0eG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdFx0fSBlbHNlIHsgLy8gSUVcblx0XHRcdHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KCBcIk1pY3Jvc29mdC5YTUxET01cIiApO1xuXHRcdFx0eG1sLmFzeW5jID0gXCJmYWxzZVwiO1xuXHRcdFx0eG1sLmxvYWRYTUwoIGRhdGEgKTtcblx0XHR9XG5cdH0gY2F0Y2goIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cdGlmICggIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHQvLyBEb2N1bWVudCBsb2NhdGlvblxuXHRhamF4TG9jUGFydHMsXG5cdGFqYXhMb2NhdGlvbixcblxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL21nLCAvLyBJRSBsZWF2ZXMgYW4gXFxyIGNoYXJhY3RlciBhdCBFT0xcblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cdHJ1cmwgPSAvXihbXFx3ListXSs6KSg/OlxcL1xcLyg/OlteXFwvPyNdKkB8KShbXlxcLz8jOl0qKSg/OjooXFxkKyl8KXwpLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KFwiKlwiKTtcblxuLy8gIzgxMzgsIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3Npbmdcbi8vIGEgZmllbGQgZnJvbSB3aW5kb3cubG9jYXRpb24gaWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIHNldFxudHJ5IHtcblx0YWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZjtcbn0gY2F0Y2goIGUgKSB7XG5cdC8vIFVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgYW4gQSBlbGVtZW50XG5cdC8vIHNpbmNlIElFIHdpbGwgbW9kaWZ5IGl0IGdpdmVuIGRvY3VtZW50LmxvY2F0aW9uXG5cdGFqYXhMb2NhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdGFqYXhMb2NhdGlvbi5ocmVmID0gXCJcIjtcblx0YWpheExvY2F0aW9uID0gYWpheExvY2F0aW9uLmhyZWY7XG59XG5cbi8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xuYWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoZGF0YVR5cGUgPSBkYXRhVHlwZXNbaSsrXSkgKSB7XG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGUuY2hhckF0KCAwICkgPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiYgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBkZWVwLCBrZXksXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoZGVlcCA9IHt9KSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXHR2YXIgZmlyc3REYXRhVHlwZSwgY3QsIGZpbmFsRGF0YVR5cGUsIHR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgc1sgXCJ0aHJvd3NcIiBdICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgc3RhdGU6IFwicGFyc2VyZXJyb3JcIiwgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50IH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBhamF4TG9jUGFydHNbIDEgXSApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL3htbC8sXG5cdFx0XHRodG1sOiAvaHRtbC8sXG5cdFx0XHRqc29uOiAvanNvbi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgLy8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnMgYXMgc3RyaW5nXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHR0cmFuc3BvcnQsXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJiAoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUgPT09IDIgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3RhdGUgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkICgjNTg2NjogSUU3IGlzc3VlIHdpdGggcHJvdG9jb2wtbGVzcyB1cmxzKVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGFqYXhMb2NhdGlvbiApICsgXCJcIiApLnJlcGxhY2UoIHJoYXNoLCBcIlwiICkucmVwbGFjZSggcnByb3RvY29sLCBhamF4TG9jUGFydHNbIDEgXSArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gd2UgaGF2ZSBhIHByb3RvY29sOmhvc3Q6cG9ydCBtaXNtYXRjaFxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0cGFydHMgPSBydXJsLmV4ZWMoIHMudXJsLnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdHMuY3Jvc3NEb21haW4gPSAhISggcGFydHMgJiZcblx0XHRcdFx0KCBwYXJ0c1sgMSBdICE9PSBhamF4TG9jUGFydHNbIDEgXSB8fCBwYXJ0c1sgMiBdICE9PSBhamF4TG9jUGFydHNbIDIgXSB8fFxuXHRcdFx0XHRcdCggcGFydHNbIDMgXSB8fCAoIHBhcnRzWyAxIF0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIgKSApICE9PVxuXHRcdFx0XHRcdFx0KCBhamF4TG9jUGFydHNbIDMgXSB8fCAoIGFqYXhMb2NQYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSApXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0ZmlyZUdsb2JhbHMgPSBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0cy51cmwgPSBydHMudGVzdCggY2FjaGVVUkwgKSA/XG5cblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxuXHRcdFx0XHRcdGNhY2hlVVJMLnJlcGxhY2UoIHJ0cywgXCIkMV89XCIgKyBub25jZSsrICkgOlxuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFkZCBvbmUgdG8gdGhlIGVuZFxuXHRcdFx0XHRcdGNhY2hlVVJMICsgKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArIG5vbmNlKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSArICggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmICggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gYWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRmb3IgKCBpIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0gKSB7XG5cdFx0XHRqcVhIUlsgaSBdKCBzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c3RhdGUgPSAxO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIik7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIik7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXZSBleHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dFxuXHRcdFx0XHQvLyB0aGVuIG5vcm1hbGl6ZSBzdGF0dXNUZXh0IGFuZCBzdGF0dXMgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblx0XHQvLyBzaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0pO1xuXHR9O1xufSk7XG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggWyBcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiIF0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0pO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0dXJsOiB1cmwsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0pO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGpRdWVyeSh0aGlzKS53cmFwQWxsKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1swXSApIHtcblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR2YXIgd3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50ICkuZXEoMCkuY2xvbmUodHJ1ZSk7XG5cblx0XHRcdGlmICggdGhpc1swXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1swXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdENoaWxkICYmIGVsZW0uZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9KS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRqUXVlcnkodGhpcykud3JhcElubmVyKCBodG1sLmNhbGwodGhpcywgaSkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSkuZW5kKCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG5cdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtLm9mZnNldEhlaWdodCA8PSAwIHx8XG5cdFx0KCFzdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cygpICYmXG5cdFx0XHQoKGVsZW0uc3R5bGUgJiYgZWxlbS5zdHlsZS5kaXNwbGF5KSB8fCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApKSA9PT0gXCJub25lXCIpO1xufTtcblxualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oIGVsZW0gKTtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IGkgOiBcIlwiICkgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuXHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRpZiAoIHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSk7XG5cblx0fSBlbHNlIHtcblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9KVxuXHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblx0XHRcdC8vIFVzZSAuaXMoXCI6ZGlzYWJsZWRcIikgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSlcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSkuZ2V0KCk7XG5cdH1cbn0pO1xuXG5cbi8vIENyZWF0ZSB0aGUgcmVxdWVzdCBvYmplY3Rcbi8vIChUaGlzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGFqYXhTZXR0aW5ncyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gd2luZG93LkFjdGl2ZVhPYmplY3QgIT09IHVuZGVmaW5lZCA/XG5cdC8vIFN1cHBvcnQ6IElFNitcblx0ZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBYSFIgY2Fubm90IGFjY2VzcyBsb2NhbCBmaWxlcywgYWx3YXlzIHVzZSBBY3RpdmVYIGZvciB0aGF0IGNhc2Vcblx0XHRyZXR1cm4gIXRoaXMuaXNMb2NhbCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTctOFxuXHRcdFx0Ly8gb2xkSUUgWEhSIGRvZXMgbm90IHN1cHBvcnQgbm9uLVJGQzI2MTYgbWV0aG9kcyAoIzEzMjQwKVxuXHRcdFx0Ly8gU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9tczUzNjY0OCh2PXZzLjg1KS5hc3B4XG5cdFx0XHQvLyBhbmQgaHR0cDovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWM5Lmh0bWwjc2VjOVxuXHRcdFx0Ly8gQWx0aG91Z2ggdGhpcyBjaGVjayBmb3Igc2l4IG1ldGhvZHMgaW5zdGVhZCBvZiBlaWdodFxuXHRcdFx0Ly8gc2luY2UgSUUgYWxzbyBkb2VzIG5vdCBzdXBwb3J0IFwidHJhY2VcIiBhbmQgXCJjb25uZWN0XCJcblx0XHRcdC9eKGdldHxwb3N0fGhlYWR8cHV0fGRlbGV0ZXxvcHRpb25zKSQvaS50ZXN0KCB0aGlzLnR5cGUgKSAmJlxuXG5cdFx0XHRjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xuXHR9IDpcblx0Ly8gRm9yIGFsbCBvdGhlciBicm93c2VycywgdXNlIHRoZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBvYmplY3Rcblx0Y3JlYXRlU3RhbmRhcmRYSFI7XG5cbnZhciB4aHJJZCA9IDAsXG5cdHhockNhbGxiYWNrcyA9IHt9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4vLyBTdXBwb3J0OiBJRTwxMFxuLy8gT3BlbiByZXF1ZXN0cyBtdXN0IGJlIG1hbnVhbGx5IGFib3J0ZWQgb24gdW5sb2FkICgjNTI4MClcbmlmICggd2luZG93LkFjdGl2ZVhPYmplY3QgKSB7XG5cdGpRdWVyeSggd2luZG93ICkub24oIFwidW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuXHRcdGZvciAoIHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzICkge1xuXHRcdFx0eGhyQ2FsbGJhY2tzWyBrZXkgXSggdW5kZWZpbmVkLCB0cnVlICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gRGV0ZXJtaW5lIHN1cHBvcnQgcHJvcGVydGllc1xuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xueGhyU3VwcG9ydGVkID0gc3VwcG9ydC5hamF4ID0gISF4aHJTdXBwb3J0ZWQ7XG5cbi8vIENyZWF0ZSB0cmFuc3BvcnQgaWYgdGhlIGJyb3dzZXIgY2FuIHByb3ZpZGUgYW4geGhyXG5pZiAoIHhoclN1cHBvcnRlZCApIHtcblxuXHRqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiB8fCBzdXBwb3J0LmNvcnMgKSB7XG5cblx0XHRcdHZhciBjYWxsYmFjaztcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKSxcblx0XHRcdFx0XHRcdGlkID0gKyt4aHJJZDtcblxuXHRcdFx0XHRcdC8vIE9wZW4gdGhlIHNvY2tldFxuXHRcdFx0XHRcdHhoci5vcGVuKCBvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkICk7XG5cblx0XHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuXHRcdFx0XHRcdFx0aGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHRcdFx0XHQvLyBJRSdzIEFjdGl2ZVhPYmplY3QgdGhyb3dzIGEgJ1R5cGUgTWlzbWF0Y2gnIGV4Y2VwdGlvbiB3aGVuIHNldHRpbmdcblx0XHRcdFx0XHRcdC8vIHJlcXVlc3QgaGVhZGVyIHRvIGEgbnVsbC12YWx1ZS5cblx0XHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0XHQvLyBUbyBrZWVwIGNvbnNpc3RlbnQgd2l0aCBvdGhlciBYSFIgaW1wbGVtZW50YXRpb25zLCBjYXN0IHRoZSB2YWx1ZVxuXHRcdFx0XHRcdFx0Ly8gdG8gc3RyaW5nIGFuZCBpZ25vcmUgYHVuZGVmaW5lZGAuXG5cdFx0XHRcdFx0XHRpZiAoIGhlYWRlcnNbIGkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICsgXCJcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3Rcblx0XHRcdFx0XHQvLyBUaGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24gd2hpY2ggaXMgYWN0dWFsbHlcblx0XHRcdFx0XHQvLyBoYW5kbGVkIGluIGpRdWVyeS5hamF4IChzbyBubyB0cnkvY2F0Y2ggaGVyZSlcblx0XHRcdFx0XHR4aHIuc2VuZCggKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhICkgfHwgbnVsbCApO1xuXG5cdFx0XHRcdFx0Ly8gTGlzdGVuZXJcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0dmFyIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzO1xuXG5cdFx0XHRcdFx0XHQvLyBXYXMgbmV2ZXIgY2FsbGVkIGFuZCBpcyBhYm9ydGVkIG9yIGNvbXBsZXRlXG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICYmICggaXNBYm9ydCB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDbGVhbiB1cFxuXHRcdFx0XHRcdFx0XHRkZWxldGUgeGhyQ2FsbGJhY2tzWyBpZCBdO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGpRdWVyeS5ub29wO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFib3J0IG1hbnVhbGx5IGlmIG5lZWRlZFxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSAhPT0gNCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMgPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSB4aHIuc3RhdHVzO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8MTBcblx0XHRcdFx0XHRcdFx0XHQvLyBBY2Nlc3NpbmcgYmluYXJ5LWRhdGEgcmVzcG9uc2VUZXh0IHRocm93cyBhbiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyAoIzExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZXMudGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc3RhdHVzVGV4dCBmb3IgZmF1bHR5IGNyb3NzLWRvbWFpbiByZXF1ZXN0c1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0geGhyLnN0YXR1c1RleHQ7XG5cdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCggZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFdlIG5vcm1hbGl6ZSB3aXRoIFdlYmtpdCBnaXZpbmcgYW4gZW1wdHkgc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmlsdGVyIHN0YXR1cyBmb3Igbm9uIHN0YW5kYXJkIGJlaGF2aW9yc1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHJlcXVlc3QgaXMgbG9jYWwgYW5kIHdlIGhhdmUgZGF0YTogYXNzdW1lIGEgc3VjY2Vzc1xuXHRcdFx0XHRcdFx0XHRcdC8vIChzdWNjZXNzIHdpdGggbm8gZGF0YSB3b24ndCBnZXQgbm90aWZpZWQsIHRoYXQncyB0aGUgYmVzdCB3ZVxuXHRcdFx0XHRcdFx0XHRcdC8vIGNhbiBkbyBnaXZlbiBjdXJyZW50IGltcGxlbWVudGF0aW9ucylcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFzdGF0dXMgJiYgb3B0aW9ucy5pc0xvY2FsICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzID0gcmVzcG9uc2VzLnRleHQgPyAyMDAgOiA0MDQ7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSUUgLSAjMTQ1MDogc29tZXRpbWVzIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDEyMjMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSAyMDQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIENhbGwgY29tcGxldGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIHN0YXR1cywgc3RhdHVzVGV4dCwgcmVzcG9uc2VzLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy5hc3luYyApIHtcblx0XHRcdFx0XHRcdC8vIGlmIHdlJ3JlIGluIHN5bmMgbW9kZSB3ZSBmaXJlIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRcdC8vIChJRTYgJiBJRTcpIGlmIGl0J3MgaW4gY2FjaGUgYW5kIGhhcyBiZWVuXG5cdFx0XHRcdFx0XHQvLyByZXRyaWV2ZWQgZGlyZWN0bHkgd2UgbmVlZCB0byBmaXJlIHRoZSBjYWxsYmFja1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dCggY2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gQWRkIHRvIHRoZSBsaXN0IG9mIGFjdGl2ZSB4aHIgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0geGhyQ2FsbGJhY2tzWyBpZCBdID0gY2FsbGJhY2s7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soIHVuZGVmaW5lZCwgdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBGdW5jdGlvbnMgdG8gY3JlYXRlIHhocnNcbmZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkWEhSKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3RpdmVYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MSFRUUFwiICk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufVxuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogLyg/OmphdmF8ZWNtYSlzY3JpcHQvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgZ2xvYmFsXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0XHRzLmdsb2JhbCA9IGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24ocykge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGpRdWVyeShcImhlYWRcIilbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNhbGxiYWNrICkge1xuXG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cblx0XHRcdFx0c2NyaXB0LmFzeW5jID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIHMuc2NyaXB0Q2hhcnNldCApIHtcblx0XHRcdFx0XHRzY3JpcHQuY2hhcnNldCA9IHMuc2NyaXB0Q2hhcnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjcmlwdC5zcmMgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBBdHRhY2ggaGFuZGxlcnMgZm9yIGFsbCBicm93c2Vyc1xuXHRcdFx0XHRzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCBfLCBpc0Fib3J0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpc0Fib3J0IHx8ICFzY3JpcHQucmVhZHlTdGF0ZSB8fCAvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KCBzY3JpcHQucmVhZHlTdGF0ZSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgbWVtb3J5IGxlYWsgaW4gSUVcblx0XHRcdFx0XHRcdHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBzY3JpcHRcblx0XHRcdFx0XHRcdGlmICggc2NyaXB0LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRGVyZWZlcmVuY2UgdGhlIHNjcmlwdFxuXHRcdFx0XHRcdFx0c2NyaXB0ID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FsbGJhY2sgaWYgbm90IGFib3J0XG5cdFx0XHRcdFx0XHRpZiAoICFpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayggMjAwLCBcInN1Y2Nlc3NcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBDaXJjdW12ZW50IElFNiBidWdzIHdpdGggYmFzZSBlbGVtZW50cyAoIzI3MDkgYW5kICM0Mzc4KSBieSBwcmVwZW5kaW5nXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRoZWFkLmluc2VydEJlZm9yZSggc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQgKTtcblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBzY3JpcHQgKSB7XG5cdFx0XHRcdFx0c2NyaXB0Lm9ubG9hZCggdW5kZWZpbmVkLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59KTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbMV0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgcmVzcG9uc2UsIHR5cGUsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG5cdGlmICggb2ZmID49IDAgKSB7XG5cdFx0c2VsZWN0b3IgPSB1cmwuc2xpY2UoIG9mZiwgdXJsLmxlbmd0aCApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBpZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSkuZG9uZShmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeShcIjxkaXY+XCIpLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdH0pLmNvbXBsZXRlKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9KS5sZW5ndGg7XG59O1xuXG5cblxuXG5cbnZhciBkb2NFbGVtID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/XG5cdFx0ZWxlbSA6XG5cdFx0ZWxlbS5ub2RlVHlwZSA9PT0gOSA/XG5cdFx0XHRlbGVtLmRlZmF1bHRWaWV3IHx8IGVsZW0ucGFyZW50V2luZG93IDpcblx0XHRcdGZhbHNlO1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdGpRdWVyeS5pbkFycmF5KFwiYXV0b1wiLCBbIGN1ckNTU1RvcCwgY3VyQ1NTTGVmdCBdICkgPiAtMTtcblxuXHRcdC8vIG5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG5cdFx0aWYgKCAhZG9jICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG5cdFx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94O1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXG5cdFx0Ly8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH1cblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgICsgKCB3aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgKSAgLSAoIGRvY0VsZW0uY2xpZW50VG9wICB8fCAwICksXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArICggd2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCApIC0gKCBkb2NFbGVtLmNsaWVudExlZnQgfHwgMCApXG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0Ly8gZml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSwgYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0Ly8gd2UgYXNzdW1lIHRoYXQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGF2YWlsYWJsZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHQvLyBub3RlOiB3aGVuIGFuIGVsZW1lbnQgaGFzIG1hcmdpbjogYXV0byB0aGUgb2Zmc2V0TGVmdCBhbmQgbWFyZ2luTGVmdFxuXHRcdC8vIGFyZSB0aGUgc2FtZSBpbiBTYWZhcmkgY2F1c2luZyBvZmZzZXQubGVmdCB0byBpbmNvcnJlY3RseSBiZSAwXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogIG9mZnNldC50b3AgIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSlcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50LCBcImh0bWxcIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcblx0XHR9KTtcblx0fVxufSk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gL1kvLnRlc3QoIHByb3AgKTtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyAocHJvcCBpbiB3aW4pID8gd2luWyBwcm9wIF0gOlxuXHRcdFx0XHRcdHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIG1ldGhvZCBdIDpcblx0XHRcdFx0XHRlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxMZWZ0KCksXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxUb3AoKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuXHR9O1xufSk7XG5cbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHRcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCB3ZSBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXHRcdFx0XHQvLyBpZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0pO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXHRcdC8vIG1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0XHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxuXHRcdFx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLCB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHQvLyB1bmZvcnR1bmF0ZWx5LCB0aGlzIGNhdXNlcyBidWcgIzM4MzggaW4gSUU2Lzggb25seSwgYnV0IHRoZXJlIGlzIGN1cnJlbnRseSBubyBnb29kLCBzbWFsbCB3YXkgdG8gZml4IGl0LlxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9KTtcbn0pO1xuXG5cbi8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5qUXVlcnkuZm4uc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0pO1xufVxuXG5cblxuXG52YXJcblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluXG4vLyBBTUQgKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IHN0cnVuZGVmaW5lZCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xuXG59KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvanF1ZXJ5LzEuMTEuMC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///54\n");

/***/ }),

/***/ 55:
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///55\n");

/***/ })

/******/ });